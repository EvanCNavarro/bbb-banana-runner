<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Banana Runner</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: #000;
            font-family: monospace;
        }
        canvas {
            display: block;
            background: #FAFAFA;
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
        }
        /* Auth Modal Styles */
        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            z-index: 1000;
            justify-content: center;
            align-items: center;
            cursor: pointer;
        }
        .modal-overlay.active {
            display: flex;
        }
        .auth-modal {
            background: #1a1a2e;
            border: 3px solid #FFE135;
            border-radius: 12px;
            padding: 30px;
            max-width: 400px;
            width: 90%;
            box-shadow: 0 0 30px rgba(255, 225, 53, 0.3);
            cursor: default;
        }
        .auth-modal h2 {
            color: #FFE135;
            text-align: center;
            margin-bottom: 25px;
            font-size: 28px;
        }
        .auth-modal input {
            width: 100%;
            padding: 12px;
            margin-bottom: 15px;
            background: #16213e;
            border: 2px solid #444;
            border-radius: 6px;
            color: #fff;
            font-family: monospace;
            font-size: 16px;
            box-sizing: border-box;
        }
        .auth-modal input:focus {
            outline: none;
            border-color: #FFE135;
        }
        .auth-modal button {
            width: 100%;
            padding: 14px;
            margin-bottom: 10px;
            background: #FFE135;
            border: none;
            border-radius: 6px;
            color: #000;
            font-family: monospace;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            transition: transform 0.1s, background 0.2s;
        }
        .auth-modal button:hover {
            background: #FFC107;
            transform: scale(1.02);
        }
        .auth-modal button.secondary {
            background: transparent;
            border: 2px solid #666;
            color: #aaa;
        }
        .auth-modal button.secondary:hover {
            border-color: #FFE135;
            color: #FFE135;
        }
        .auth-modal .toggle-text {
            text-align: center;
            color: #888;
            margin-top: 15px;
        }
        .auth-modal .toggle-text a {
            color: #FFE135;
            cursor: pointer;
            text-decoration: underline;
        }
        .auth-modal .error-msg {
            color: #ff6b6b;
            text-align: center;
            margin-bottom: 15px;
            min-height: 20px;
        }
        .auth-modal .success-msg {
            color: #4CAF50;
            text-align: center;
            margin-bottom: 15px;
        }
        .user-info {
            position: fixed;
            top: 10px;
            right: 10px;
            color: #fff;
            font-family: monospace;
            font-size: 14px;
            z-index: 100;
            text-align: right;
        }
        .user-info .username {
            color: #FFE135;
            font-weight: bold;
        }
        .user-info .logout-btn {
            color: #888;
            cursor: pointer;
            margin-left: 10px;
        }
        .user-info .logout-btn:hover {
            color: #ff6b6b;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>

    <!-- Hidden input for native keyboard on mobile/desktop -->
    <input type="text" id="lobbyCodeInput" autocomplete="off" autocorrect="off" autocapitalize="characters"
           style="position: absolute; left: -9999px; opacity: 0; pointer-events: none;"
           maxlength="6" pattern="[A-Za-z]{6}">

    <!-- User Info Display -->
    <div id="userInfo" class="user-info" style="display: none;">
        <span class="username" id="displayUsername"></span>
        <span class="logout-btn" onclick="logout()">[Logout]</span>
    </div>

    <!-- Auth Modal -->
    <div id="authModal" class="modal-overlay">
        <div class="auth-modal">
            <h2 id="authTitle">Sign Up</h2>
            <div id="authError" class="error-msg"></div>
            <div id="authSuccess" class="success-msg" style="display: none;"></div>
            <form id="authForm">
                <input type="text" id="authUsername" placeholder="Username" autocomplete="username" required>
                <input type="password" id="authPassword" placeholder="Password" autocomplete="current-password" required>
                <button type="submit" id="authSubmit">Create Account</button>
            </form>
            <div class="toggle-text" id="authToggle">
                Already have an account? <a onclick="toggleAuthMode()">Login</a>
            </div>
        </div>
    </div>

    <!-- Supabase SDK -->
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>

    <script type="module">
        // ============================================
        // MODULE IMPORTS
        // ============================================

        // Core configuration
        import {
            SUPABASE_URL,
            SUPABASE_ANON_KEY,
            PLAYER_SCALE,
            ENTITY_SCALE,
            BANANA_HEIGHT_OFFSET,
            JUMP_BUFFER_MS,
            INITIAL_SPEED,
            JUMP_VELOCITY,
            GRAVITY,
            SPAWN_INTERVAL,
            BANANA_SPAWN_CHANCE,
            BANANA_POINTS,
            GROUND_HEIGHT_RATIO,
            GAME_STATES,
            GAME_MODES
        } from './src/core/config.js';

        // Design system
        import { createDesignSystem } from './src/core/designSystem.js';

        // Utilities
        import {
            drawSprite as drawSpriteUtil,
            pointInBounds as pointInBoundsUtil,
            clamp,
            lerp,
            randomInt
        } from './src/core/utils.js';

        // UI Components (available for future use)
        import { createUIComponents } from './src/ui/components.js';

        // Click handling (available for future use)
        import { createClickManager, createInputHandler } from './src/ui/clickHandler.js';

        // Services
        import { createAuthService, usernameToEmail as authUsernameToEmail, validateUsername } from './src/services/auth.js';
        import { createDatabaseService } from './src/services/database.js';
        import { createMultiplayerService } from './src/services/multiplayer.js';

        // ============================================
        // CANVAS SETUP
        // ============================================
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        ctx.imageSmoothingEnabled = false;

        // Initialize design system bound to canvas
        const DS = createDesignSystem(canvas);

        // ============================================
        // UI COMPONENTS
        // ============================================

        // Navigation stack for back button
        let navigationStack = [];

        function navigateTo(screen, addToStack = true) {
            if (addToStack && gameState !== 'welcome' && gameState !== 'playing') {
                navigationStack.push(gameState);
            }
            gameState = screen;
        }

        function navigateBack() {
            if (navigationStack.length > 0) {
                gameState = navigationStack.pop();
            } else {
                gameState = 'menu';
            }
        }

        // Draw a styled button - returns bounds for click detection
        function drawStyledButton(x, y, width, height, label, options = {}) {
            const {
                primary = true,
                disabled = false,
                centered = true
            } = options;

            const actualX = centered ? x - width / 2 : x;
            const actualY = y;

            // Background
            if (disabled) {
                ctx.fillStyle = DS.colors.locked;
            } else if (primary) {
                ctx.fillStyle = DS.colors.primary;
            } else {
                ctx.fillStyle = 'transparent';
                ctx.strokeStyle = DS.colors.primary;
                ctx.lineWidth = 2;
            }

            // Draw rounded rect
            const r = DS.button.radius;
            ctx.beginPath();
            ctx.roundRect(actualX, actualY, width, height, r);
            if (primary || disabled) {
                ctx.fill();
            } else {
                ctx.stroke();
            }

            // Text
            ctx.fillStyle = primary ? DS.colors.bgDark : DS.colors.primary;
            if (disabled) ctx.fillStyle = DS.colors.textMuted;
            ctx.font = DS.font('body', 'bold');
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(label, actualX + width / 2, actualY + height / 2);

            // Return bounds for click detection
            return { x: actualX, y: actualY, w: width, h: height, action: options.action || label };
        }

        // Draw header with title and optional back button
        function drawHeader(title, showBack = true) {
            const height = DS.header.height();

            // Background
            ctx.fillStyle = DS.colors.bgOverlay;
            ctx.fillRect(0, 0, canvas.width, height);

            // Bottom border
            ctx.strokeStyle = DS.colors.primary;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(0, height);
            ctx.lineTo(canvas.width, height);
            ctx.stroke();

            // Back button
            let backBounds = null;
            if (showBack) {
                const backSize = height - DS.spacing.lg;
                const backX = DS.spacing.md;
                const backY = (height - backSize) / 2;

                ctx.fillStyle = DS.colors.primary;
                ctx.font = DS.font('h3', 'bold');
                ctx.textAlign = 'left';
                ctx.textBaseline = 'middle';
                ctx.fillText('â†', backX, height / 2);

                backBounds = { x: 0, y: 0, w: height, h: height, action: 'back' };
            }

            // Title
            ctx.fillStyle = DS.colors.white;
            ctx.font = DS.font('h3', 'bold');
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(title, canvas.width / 2, height / 2);

            return { height, backBounds };
        }

        // Draw a panel/card
        function drawPanel(x, y, width, height, options = {}) {
            const { centered = false, title = null } = options;
            const actualX = centered ? x - width / 2 : x;

            // Background
            ctx.fillStyle = DS.colors.bgPanel;
            ctx.beginPath();
            ctx.roundRect(actualX, y, width, height, 12);
            ctx.fill();

            // Border
            ctx.strokeStyle = DS.colors.primary;
            ctx.lineWidth = 2;
            ctx.stroke();

            // Title if provided
            if (title) {
                ctx.fillStyle = DS.colors.primary;
                ctx.font = DS.font('body', 'bold');
                ctx.textAlign = 'left';
                ctx.textBaseline = 'top';
                ctx.fillText(title, actualX + DS.spacing.md, y + DS.spacing.md);
            }

            return { x: actualX, y, w: width, h: height };
        }

        // Draw section title
        function drawSectionTitle(text, y) {
            ctx.fillStyle = DS.colors.textSecondary;
            ctx.font = DS.font('small', 'bold');
            ctx.textAlign = 'center';
            ctx.textBaseline = 'top';
            ctx.fillText(text.toUpperCase(), canvas.width / 2, y);
            return y + DS.fontSize('small') + DS.spacing.sm;
        }

        // Check if point is in bounds
        function pointInBounds(px, py, bounds) {
            if (!bounds) return false;
            return px >= bounds.x && px <= bounds.x + bounds.w &&
                   py >= bounds.y && py <= bounds.y + bounds.h;
        }

        // Store clickable areas for current frame
        let clickableAreas = [];

        function resetClickables() {
            clickableAreas = [];
        }

        function addClickable(bounds) {
            if (bounds) clickableAreas.push(bounds);
        }

        // ============================================
        // SUPABASE INITIALIZATION
        // Config imported from ./src/core/config.js
        // ============================================

        // Initialize Supabase client
        let supabaseClient = null;
        let currentUser = null;
        let userProfile = null;
        let isAuthMode = 'signup'; // 'signup' or 'login' - default to signup for new users

        // Declare early to avoid temporal dead zone issues with callbacks and resize handlers
        let gameState = 'welcome';
        let player = null;
        let entities = [];
        let spawnCounter = 0;

        // ============================================
        // SEEDED RANDOM NUMBER GENERATOR
        // For synchronized multiplayer - all players use same seed = same obstacles
        // ============================================
        let gameSeed = 0;
        let seededRandom = null;

        /**
         * Create a seeded PRNG using mulberry32 algorithm
         * @param {number} seed - The seed value
         * @returns {function} A function that returns random numbers 0-1
         */
        function createSeededRandom(seed) {
            return function() {
                seed |= 0;
                seed = seed + 0x6D2B79F5 | 0;
                let t = Math.imul(seed ^ seed >>> 15, 1 | seed);
                t = t + Math.imul(t ^ t >>> 7, 61 | t) ^ t;
                return ((t ^ t >>> 14) >>> 0) / 4294967296;
            };
        }

        /**
         * Initialize the game with a specific seed
         * @param {number} seed - Seed for random generation
         */
        function initGameSeed(seed) {
            gameSeed = seed;
            seededRandom = createSeededRandom(seed);
            console.log(`[Game] Initialized with seed: ${seed}`);
        }

        /**
         * Get a seeded random number (falls back to Math.random if not initialized)
         * @returns {number} Random number between 0 and 1
         */
        function getRandom() {
            return seededRandom ? seededRandom() : Math.random();
        }

        function initSupabase() {
            if (SUPABASE_URL !== 'YOUR_SUPABASE_URL' && typeof window.supabase !== 'undefined') {
                supabaseClient = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
                checkAuth();
            } else {
                console.log('Supabase not configured - running in guest mode');
            }
        }

        // ============================================
        // AUTHENTICATION FUNCTIONS
        // ============================================
        async function checkAuth() {
            if (!supabaseClient) return;

            const { data: { session } } = await supabaseClient.auth.getSession();
            if (session) {
                currentUser = session.user;
                // Set fallback profile immediately
                userProfile = {
                    id: currentUser.id,
                    username: currentUser.user_metadata?.username || 'Player'
                };
                await loadUserProfileWithTimeout();
                updateUserDisplay();
                // Go to menu if already logged in
                gameState = 'menu';
            }

            // Listen for auth changes (e.g., from other tabs)
            supabaseClient.auth.onAuthStateChange(async (event, session) => {
                // Skip if this is from our own signIn (already handled)
                if (event === 'SIGNED_IN' && currentUser?.id === session?.user?.id) {
                    return;
                }

                if (session) {
                    currentUser = session.user;
                    userProfile = {
                        id: currentUser.id,
                        username: currentUser.user_metadata?.username || 'Player'
                    };
                    await loadUserProfileWithTimeout();
                    updateUserDisplay();
                    if (gameState === 'welcome') {
                        gameState = 'menu';
                    }
                } else {
                    currentUser = null;
                    userProfile = null;
                    updateUserDisplay();
                    gameState = 'welcome';
                }
            });
        }

        async function loadUserProfile() {
            if (!supabaseClient || !currentUser) return;

            try {
                const { data, error } = await supabaseClient
                    .from('profiles')
                    .select('*')
                    .eq('id', currentUser.id)
                    .single();

                if (error) {
                    // Keep fallback profile that was already set
                } else if (data) {
                    userProfile = data;

                    // Sync playerStats with loaded profile data
                    playerStats = {
                        total_games: data.total_games || 0,
                        high_score: data.high_score || 0,
                        total_score: data.total_score || 0,
                        total_bananas: data.total_bananas || 0,
                        spendable_bananas: data.spendable_bananas || 0,
                        total_time_played: data.total_time_played || 0,
                        jetpacks_collected: data.jetpacks_collected || 0,
                        dino_stomps_collected: data.dino_stomps_collected || 0,
                        snow_games_played: data.snow_games_played || 0,
                        desert_games_played: data.desert_games_played || 0,
                        jungle_games_played: data.jungle_games_played || 0,
                        ocean_games_played: data.ocean_games_played || 0,
                        snow_best_score: data.snow_best_score || 0,
                        desert_best_score: data.desert_best_score || 0,
                        jungle_best_score: data.jungle_best_score || 0,
                        ocean_best_score: data.ocean_best_score || 0,
                        first_game_at: data.first_game_at || null,
                        last_game_at: data.last_game_at || null,
                        highest_level_reached: data.highest_level_reached || 0,
                        times_reached_rank_one: data.times_reached_rank_one || 0,
                        total_purchases: data.total_purchases || 0,
                        total_spent: data.total_spent || 0,
                        multiplayer_games: data.multiplayer_games || 0,
                        multiplayer_wins: data.multiplayer_wins || 0
                    };

                    // Initialize lands played set from loaded data
                    landsPlayed = new Set();
                    if (data.snow_games_played > 0) landsPlayed.add('snow');
                    if (data.desert_games_played > 0) landsPlayed.add('desert');
                    if (data.jungle_games_played > 0) landsPlayed.add('jungle');
                    if (data.ocean_games_played > 0) landsPlayed.add('ocean');
                }

                // Also load skins and achievements
                await loadPlayerProgress();
            } catch (err) {
                // Keep fallback profile that was already set
            }
        }

        // Convert username to internal email format for Supabase auth
        function usernameToEmail(username) {
            return `${username.toLowerCase()}@banana-jump.local`;
        }

        async function signUp(username, password) {
            if (!supabaseClient) {
                showAuthError('Supabase not configured');
                return false;
            }

            // Validate username
            if (username.length < 3) {
                showAuthError('Username must be at least 3 characters');
                return false;
            }
            if (!/^[a-zA-Z0-9_]+$/.test(username)) {
                showAuthError('Username can only contain letters, numbers, and underscores');
                return false;
            }

            const email = usernameToEmail(username);

            const { data, error } = await supabaseClient.auth.signUp({
                email,
                password,
                options: {
                    data: { username }
                }
            });

            if (error) {
                // Make error messages more user-friendly
                if (error.message.includes('already registered')) {
                    showAuthError('Username already taken');
                } else {
                    showAuthError(error.message);
                }
                return false;
            }

            // Create profile
            if (data.user) {
                const { error: profileError } = await supabaseClient
                    .from('profiles')
                    .upsert({
                        id: data.user.id,
                        username: username
                    });

                if (profileError) {
                    console.error('Profile creation error:', profileError);
                }
            }

            // Auto-login after signup (since email confirmation is disabled)
            if (data.session && data.user) {
                // Session already exists, user is logged in
                // Set user immediately (don't wait for onAuthStateChange)
                currentUser = data.user;
                // Set a basic profile immediately (the upsert above created it)
                userProfile = { id: data.user.id, username: username };
                updateUserDisplay();
                closeAuthModal();
                return true;
            } else {
                // Manually sign in if no session returned
                const signInResult = await signIn(username, password);
                return signInResult;
            }
        }

        async function signIn(username, password) {
            if (!supabaseClient) {
                showAuthError('Supabase not configured');
                return false;
            }

            // Check if already logged in (e.g., from another tab)
            const { data: { session: existingSession } } = await supabaseClient.auth.getSession();
            if (existingSession) {
                // Already authenticated - just load profile and proceed
                currentUser = existingSession.user;
                userProfile = {
                    id: currentUser.id,
                    username: currentUser.user_metadata?.username || 'Player'
                };
                await loadUserProfileWithTimeout();
                updateUserDisplay();
                closeAuthModal();
                return true;
            }

            const email = usernameToEmail(username);

            try {
                const { data, error } = await supabaseClient.auth.signInWithPassword({
                    email,
                    password
                });

                if (error) {
                    if (error.message.includes('Invalid login')) {
                        showAuthError('Invalid username or password');
                    } else {
                        showAuthError(error.message);
                    }
                    return false;
                }

                if (data && data.user) {
                    currentUser = data.user;
                    userProfile = {
                        id: data.user.id,
                        username: data.user.user_metadata?.username || 'Player'
                    };

                    await loadUserProfileWithTimeout();
                    updateUserDisplay();
                    closeAuthModal();
                    return true;
                } else {
                    showAuthError('Login failed - please try again');
                    return false;
                }
            } catch (err) {
                console.error('SignIn error:', err);
                showAuthError('Login failed - please try again');
                return false;
            }
        }

        // Helper to load profile with timeout protection
        async function loadUserProfileWithTimeout() {
            try {
                const profilePromise = loadUserProfile();
                const timeoutPromise = new Promise((_, reject) =>
                    setTimeout(() => reject(new Error('timeout')), 5000)
                );
                await Promise.race([profilePromise, timeoutPromise]);
            } catch (err) {
                // Profile load failed/timed out, fallback profile already set
            }
        }

        async function logout() {
            if (!supabaseClient) return;

            await supabaseClient.auth.signOut();
            currentUser = null;
            userProfile = null;
            updateUserDisplay();
            gameState = 'welcome';
        }

        // ============================================
        // SCORE PERSISTENCE
        // ============================================
        async function saveScore(finalScore, bananas, landPlayed, isMultiplayer = false, didWin = false) {
            if (!supabaseClient || !currentUser) return;

            // Calculate game duration in seconds (gameTime is in frames at 60fps)
            const gameDurationSeconds = Math.floor(gameTime / 60);

            // Save to game_sessions with all tracked data
            const { error: sessionError } = await supabaseClient
                .from('game_sessions')
                .insert({
                    player_id: currentUser.id,
                    score: finalScore,
                    bananas_collected: bananas,
                    land_played: landPlayed,
                    game_mode: isMultiplayer ? 'multiplayer' : 'solo',
                    duration: gameDurationSeconds,
                    highest_level: highestLevelReached,
                    jetpacks_used: sessionJetpacksCollected,
                    dino_stomps_used: sessionDinoStompsCollected
                });

            if (sessionError) {
                console.error('Error saving session:', sessionError);
                return;
            }

            // Update profile stats with comprehensive tracking
            if (userProfile) {
                const now = new Date().toISOString();
                const updates = {
                    // Core stats
                    total_games: (userProfile.total_games || 0) + 1,
                    total_bananas: (userProfile.total_bananas || 0) + bananas,
                    total_score: (userProfile.total_score || 0) + finalScore,
                    spendable_bananas: (userProfile.spendable_bananas || 0) + bananas,
                    total_time_played: (userProfile.total_time_played || 0) + gameDurationSeconds,

                    // Power-up stats
                    jetpacks_collected: (userProfile.jetpacks_collected || 0) + sessionJetpacksCollected,
                    dino_stomps_collected: (userProfile.dino_stomps_collected || 0) + sessionDinoStompsCollected,

                    // Timestamps
                    last_game_at: now
                };

                // Set first_game_at if this is the first game
                if (!userProfile.first_game_at) {
                    updates.first_game_at = now;
                }

                // Update high score if this is a new personal best
                if (finalScore > (userProfile.high_score || 0)) {
                    updates.high_score = finalScore;
                }

                // Update highest level reached if this game reached higher
                if (highestLevelReached > (userProfile.highest_level_reached || 0)) {
                    updates.highest_level_reached = highestLevelReached;
                }

                // Update land-specific stats
                const landKey = landPlayed.toLowerCase();
                const landGamesKey = `${landKey}_games_played`;
                const landBestKey = `${landKey}_best_score`;

                updates[landGamesKey] = (userProfile[landGamesKey] || 0) + 1;

                if (finalScore > (userProfile[landBestKey] || 0)) {
                    updates[landBestKey] = finalScore;
                }

                const { error: updateError } = await supabaseClient
                    .from('profiles')
                    .update(updates)
                    .eq('id', currentUser.id);

                if (!updateError) {
                    userProfile = { ...userProfile, ...updates };
                    spendableBananas = userProfile.spendable_bananas;  // Update local state

                    // Update local playerStats object for achievement checking
                    Object.assign(playerStats, updates);
                }

                // Save multiplayer stats to database (separate update to handle the isMultiplayer flag)
                if (isMultiplayer) {
                    const mpUpdates = {
                        multiplayer_games: (userProfile.multiplayer_games || 0) + 1
                    };
                    if (didWin) {
                        mpUpdates.multiplayer_wins = (userProfile.multiplayer_wins || 0) + 1;
                    }

                    const { error: mpError } = await supabaseClient
                        .from('profiles')
                        .update(mpUpdates)
                        .eq('id', currentUser.id);

                    if (!mpError) {
                        userProfile = { ...userProfile, ...mpUpdates };
                        Object.assign(playerStats, mpUpdates);
                    }
                }
            }
        }

        async function getLeaderboard(land = null, limit = 10) {
            if (!supabaseClient) return [];

            let query = supabaseClient
                .from('leaderboard')
                .select('*')
                .order('high_score', { ascending: false })
                .limit(limit);

            if (land) {
                // Get land-specific leaderboard from game_sessions
                const { data, error } = await supabaseClient
                    .from('game_sessions')
                    .select('player_id, score, profiles!inner(username)')
                    .eq('land_played', land)
                    .order('score', { ascending: false })
                    .limit(limit);

                return data || [];
            }

            const { data, error } = await query;
            return data || [];
        }

        // Fetch stats for game over screen
        async function fetchGameOverStats(currentScore, landPlayed) {
            gameOverStats.loading = true;

            if (!supabaseClient) {
                gameOverStats.loading = false;
                return;
            }

            try {
                // Fetch global top score (from profiles - overall high score)
                const { data: globalData } = await supabaseClient
                    .from('profiles')
                    .select('username, high_score')
                    .order('high_score', { ascending: false })
                    .limit(1)
                    .single();

                if (globalData) {
                    gameOverStats.globalTopScore = globalData.high_score;
                    gameOverStats.globalTopPlayer = globalData.username;
                    gameOverStats.isNewGlobalBest = currentUser && currentScore > globalData.high_score;

                    // Track reaching #1 rank
                    if (gameOverStats.isNewGlobalBest && currentUser) {
                        playerStats.times_reached_rank_one = (playerStats.times_reached_rank_one || 0) + 1;

                        // Persist to database
                        await supabaseClient
                            .from('profiles')
                            .update({ times_reached_rank_one: playerStats.times_reached_rank_one })
                            .eq('id', currentUser.id);

                        if (userProfile) {
                            userProfile.times_reached_rank_one = playerStats.times_reached_rank_one;
                        }
                    }
                }

                // Fetch biome/land top score
                const { data: biomeData } = await supabaseClient
                    .from('game_sessions')
                    .select('score, profiles!inner(username)')
                    .eq('land_played', landPlayed)
                    .order('score', { ascending: false })
                    .limit(1)
                    .single();

                if (biomeData) {
                    gameOverStats.biomeTopScore = biomeData.score;
                    gameOverStats.biomeTopPlayer = biomeData.profiles?.username || 'Unknown';
                }

                // Fetch personal best for this biome (only if logged in)
                if (currentUser) {
                    const { data: personalData } = await supabaseClient
                        .from('game_sessions')
                        .select('score')
                        .eq('player_id', currentUser.id)
                        .eq('land_played', landPlayed)
                        .order('score', { ascending: false })
                        .limit(1)
                        .single();

                    if (personalData) {
                        // This is the previous best (before this game was saved)
                        gameOverStats.personalBiomeBest = personalData.score;
                        gameOverStats.isNewBiomeBest = currentScore > personalData.score;
                    } else {
                        // First time playing this biome
                        gameOverStats.personalBiomeBest = 0;
                        gameOverStats.isNewBiomeBest = true;
                    }
                }
            } catch (err) {
                console.error('Error fetching game over stats:', err);
            }

            gameOverStats.loading = false;
        }

        // ============================================
        // MULTIPLAYER LOBBY FUNCTIONS
        // ============================================
        async function createLobby() {
            if (!supabaseClient || !currentUser) return null;

            const lobbyCode = Math.random().toString(36).substring(2, 8).toUpperCase();

            const { data, error } = await supabaseClient
                .from('game_lobbies')
                .insert({
                    code: lobbyCode,
                    host_id: currentUser.id,
                    land: selectedLand,
                    status: 'waiting'
                })
                .select()
                .single();

            if (error) {
                console.error('Error creating lobby:', error);
                return null;
            }

            currentLobby = data;
            isLobbyHost = true;
            await joinLobbyAsPlayer(data.id);
            subscribeLobbyUpdates(data.id);
            return data;
        }

        async function findOrCreateLobby() {
            if (!supabaseClient || !currentUser) return;

            // First try to find an existing waiting lobby
            const { data: existingLobbies, error } = await supabaseClient
                .from('game_lobbies')
                .select('*')
                .eq('status', 'waiting')
                .neq('host_id', currentUser.id)
                .order('created_at', { ascending: true })
                .limit(1);

            if (existingLobbies && existingLobbies.length > 0) {
                // Join existing lobby
                currentLobby = existingLobbies[0];
                isLobbyHost = false;
                selectedLand = currentLobby.land;
                await joinLobbyAsPlayer(currentLobby.id);
                subscribeLobbyUpdates(currentLobby.id);
            } else {
                // Create new lobby
                await createLobby();
            }

            gameState = 'lobby';
        }

        async function joinLobbyAsPlayer(lobbyId) {
            if (!supabaseClient || !currentUser) return;

            const { error } = await supabaseClient
                .from('lobby_players')
                .insert({
                    lobby_id: lobbyId,
                    player_id: currentUser.id,
                    is_ready: true  // Joining = ready (no toggle needed)
                });

            if (error) {
                console.error('Error joining lobby:', error);
            }
        }

        function subscribeLobbyUpdates(lobbyId) {
            if (!supabaseClient) return;

            // Subscribe to lobby changes
            lobbySubscription = supabaseClient
                .channel(`lobby:${lobbyId}`)
                .on('postgres_changes',
                    { event: '*', schema: 'public', table: 'lobby_players', filter: `lobby_id=eq.${lobbyId}` },
                    (payload) => {
                        loadLobbyPlayers(lobbyId);
                    }
                )
                .on('postgres_changes',
                    { event: 'UPDATE', schema: 'public', table: 'game_lobbies', filter: `id=eq.${lobbyId}` },
                    (payload) => {
                        if (payload.new.status === 'playing') {
                            startMultiplayerGame();
                        }
                    }
                )
                .subscribe();

            loadLobbyPlayers(lobbyId);
        }

        async function loadLobbyPlayers(lobbyId) {
            if (!supabaseClient) return;

            const { data, error } = await supabaseClient
                .from('lobby_players')
                .select('*, profiles:player_id(username)')
                .eq('lobby_id', lobbyId)
                .order('joined_at', { ascending: true });

            if (data) {
                lobbyPlayers = data;

                // Calculate local player index for multiplayer rendering
                const myIndex = data.findIndex(p => currentUser && p.player_id === currentUser.id);
                if (myIndex !== -1) {
                    localPlayerIndex = myIndex;
                }
            }
        }

        // toggleReady is no longer needed - joining = ready
        async function toggleReady() {
            // Deprecated - kept for compatibility
            if (!supabaseClient || !currentUser || !currentLobby) return;

            const currentPlayer = lobbyPlayers.find(p => p.player_id === currentUser.id);
            if (!currentPlayer) return;

            await supabaseClient
                .from('lobby_players')
                .update({ is_ready: !currentPlayer.is_ready })
                .eq('lobby_id', currentLobby.id)
                .eq('player_id', currentUser.id);
        }

        async function startLobbyGame() {
            if (!supabaseClient || !currentLobby || !isLobbyHost) return;

            await supabaseClient
                .from('game_lobbies')
                .update({ status: 'playing' })
                .eq('id', currentLobby.id);
        }

        // Visual stagger: each player is 60px apart horizontally
        const PLAYER_STAGGER_X = 60;

        function startMultiplayerGame() {
            gameMode = 'multiplayer';
            localPlayerAlive = true;
            gameResult = null;

            // Initialize seeded random with shared seed for synchronized obstacles
            if (multiplayerGameSeed) {
                initGameSeed(multiplayerGameSeed);
            } else {
                // Fallback: use lobby ID as seed if no seed received
                const fallbackSeed = currentLobby?.id ?
                    currentLobby.id.split('').reduce((a, c) => a + c.charCodeAt(0), 0) :
                    Date.now();
                initGameSeed(fallbackSeed);
                console.warn('[Game] No seed received, using fallback:', fallbackSeed);
            }

            // Initialize all players states from lobby
            initializeMultiplayerPlayers();

            // Start the game
            startGame();

            // Position local player based on their index (host rightmost, joiners to left)
            if (player) {
                const playerCount = lobbyPlayers.length;
                player.x = 80 + ((playerCount - 1 - localPlayerIndex) * PLAYER_STAGGER_X);
            }

            // Subscribe to game updates from all players
            if (supabaseClient && currentLobby) {
                subscribeGameUpdates();
            }
        }

        function initializeMultiplayerPlayers() {
            // Create player state objects for all lobby players
            // Position: host (index 0) is RIGHTMOST, joiners to the LEFT in join order
            const playerCount = lobbyPlayers.length;
            allPlayersStates = {};
            multiplayerPlayers = lobbyPlayers.map((lp, index) => {
                // Reverse the X position: host at right, later joiners at left
                const xPosition = 80 + ((playerCount - 1 - index) * PLAYER_STAGGER_X);
                const playerState = {
                    id: lp.player_id,
                    username: lp.profiles?.username || 'Player',
                    playerIndex: index,
                    x: xPosition,
                    yOffset: 0,  // Offset from ground (0 = standing, negative = jumping)
                    score: 0,
                    bananas: 0,
                    isAlive: true,
                    isLocal: lp.player_id === currentUser?.id
                };
                allPlayersStates[lp.player_id] = playerState;
                return playerState;
            });

            // Find local player index
            localPlayerIndex = multiplayerPlayers.findIndex(p => p.isLocal);
        }

        let gameChannelReady = false;

        function subscribeGameUpdates() {
            if (!supabaseClient || !currentLobby) return;

            // Clean up existing channel
            if (gameChannel) {
                supabaseClient.removeChannel(gameChannel);
                gameChannel = null;
            }
            gameChannelReady = false;

            gameChannel = supabaseClient
                .channel(`game:${currentLobby.id}`)
                .on('broadcast', { event: 'player_update' }, (payload) => {
                    const data = payload.payload;
                    if (data.playerId !== currentUser?.id) {
                        // Update remote player state
                        if (allPlayersStates[data.playerId]) {
                            // Store yOffset (offset from ground) for screen-size-independent positioning
                            allPlayersStates[data.playerId].yOffset = data.yOffset || 0;
                            allPlayersStates[data.playerId].score = data.score;
                            allPlayersStates[data.playerId].bananas = data.bananas;
                            allPlayersStates[data.playerId].isAlive = data.isAlive;
                            allPlayersStates[data.playerId].skin = data.skin || 'default';
                            // Debug: log received state occasionally
                            if (Math.random() < 0.02) { // ~2% of updates to reduce spam
                                console.log(`[Received] ${allPlayersStates[data.playerId].username}: score=${data.score}, bananas=${data.bananas}, yOffset=${data.yOffset}`);
                            }
                        }

                        // Check if all players are dead
                        checkRoundOver();
                    }
                })
                .on('broadcast', { event: 'round_over' }, (payload) => {
                    // Someone detected round is over - transition everyone
                    if (gameState === 'playing') {
                        // Update final states from payload
                        if (payload.payload?.finalStates) {
                            Object.assign(allPlayersStates, payload.payload.finalStates);
                        }
                        endMultiplayerRound();
                    }
                })
                .on('broadcast', { event: 'play_again' }, async (payload) => {
                    // Host triggered play again - includes new seed
                    if (gameState === 'multiplayer-results') {
                        if (payload.payload?.seed) {
                            multiplayerGameSeed = payload.payload.seed;
                            console.log(`[Play Again] Received seed: ${multiplayerGameSeed}`);
                        }
                        // Reload active players from database to remove anyone who left
                        await resetMultiplayerGame();
                    }
                })
                .on('broadcast', { event: 'game_seed' }, (payload) => {
                    // Receive seed from host before game starts
                    if (payload.payload?.seed) {
                        multiplayerGameSeed = payload.payload.seed;
                        console.log(`[Game] Received seed from host: ${multiplayerGameSeed}`);
                    }
                })
                .subscribe((status) => {
                    if (status === 'SUBSCRIBED') {
                        gameChannelReady = true;
                        // Send initial state once connected
                        broadcastPlayerState();
                    }
                });
        }

        function broadcastPlayerState() {
            if (!gameChannel || !gameChannelReady || gameMode !== 'multiplayer') return;

            // Calculate Y offset from ground (negative when jumping)
            // This normalizes across different screen sizes
            const yOffset = player ? (player.y - player.groundY) : 0;

            gameChannel.send({
                type: 'broadcast',
                event: 'player_update',
                payload: {
                    playerId: currentUser?.id,
                    playerIndex: localPlayerIndex,
                    yOffset: yOffset,  // Offset from ground, not absolute Y
                    score: score,
                    bananas: bananasCollected,
                    isAlive: localPlayerAlive,
                    skin: selectedSkin  // Include skin for visual rendering
                }
            });
        }

        function checkRoundOver() {
            if (gameMode !== 'multiplayer' || gameState !== 'playing') return;

            // Check if all players are dead
            const allDead = Object.values(allPlayersStates).every(p => !p.isAlive);
            if (allDead) {
                // Broadcast round_over to ensure everyone transitions
                if (gameChannel && gameChannelReady) {
                    gameChannel.send({
                        type: 'broadcast',
                        event: 'round_over',
                        payload: { finalStates: allPlayersStates }
                    });
                }
                endMultiplayerRound();
            }
        }

        function endMultiplayerRound() {
            if (gameState === 'multiplayer-results') return; // Already ended

            // Determine results - sort by score descending
            const results = Object.values(allPlayersStates)
                .sort((a, b) => b.score - a.score);

            // Find local player's position
            const localResult = results.find(p => p.isLocal);
            if (localResult) {
                const position = results.indexOf(localResult);
                if (position === 0) {
                    gameResult = 'win';
                } else {
                    gameResult = 'lose';
                }
            }

            // Save score for local player and check achievements
            if (currentUser && !scoreSaved) {
                scoreSaved = true;
                const gameTimeSeconds = Math.floor(gameTime / 60);
                const didWin = gameResult === 'win';

                // Wait for score to save (with multiplayer flags), then check achievements
                saveScore(score, bananasCollected, selectedLand, true, didWin).then(() => {
                    checkAchievements(score, bananasCollected, gameTimeSeconds, true, didWin);
                });
            }

            gameState = 'multiplayer-results';
        }

        // Legacy function for compatibility
        function broadcastGameState(isGameOver = false) {
            broadcastPlayerState();
        }

        async function leaveLobby() {
            if (!supabaseClient || !currentLobby) {
                gameState = 'menu';
                return;
            }

            // Unsubscribe from updates
            if (lobbySubscription) {
                supabaseClient.removeChannel(lobbySubscription);
                lobbySubscription = null;
            }

            // Remove player from lobby
            await supabaseClient
                .from('lobby_players')
                .delete()
                .eq('lobby_id', currentLobby.id)
                .eq('player_id', currentUser.id);

            // If host, delete the lobby
            if (isLobbyHost) {
                await supabaseClient
                    .from('game_lobbies')
                    .delete()
                    .eq('id', currentLobby.id);
            }

            currentLobby = null;
            lobbyPlayers = [];
            isLobbyHost = false;
            gameState = 'menu';
        }

        // New multiplayer functions for Create/Join flow
        async function createNewLobby() {
            if (!supabaseClient || !currentUser) return;

            const code = await generateLobbyCode();
            const { data, error } = await supabaseClient
                .from('game_lobbies')
                .insert({
                    code: code,
                    host_id: currentUser.id,
                    land: selectedLand,
                    status: 'waiting'
                })
                .select()
                .single();

            if (error) {
                console.error('Error creating lobby:', error);
                return;
            }

            currentLobby = data;
            isLobbyHost = true;
            await joinLobbyAsPlayer(currentLobby.id);
            subscribeLobbyUpdates(currentLobby.id);
            gameState = 'lobby';
        }

        // ============================================
        // MEMORABLE LOBBY WORDS (6 letters, child-friendly)
        // ============================================
        const LOBBY_WORDS = [
            // Animals
            'MONKEY', 'BANANA', 'TURTLE', 'RABBIT', 'KITTEN', 'PUPPY', 'DRAGON', 'PARROT',
            'PANDA', 'TIGER', 'LION', 'ZEBRA', 'GOPHER', 'BADGER', 'BEAVER', 'FALCON',
            'CONDOR', 'JAGUAR', 'COUGAR', 'DONKEY', 'LIZARD', 'IGUANA', 'SALMON', 'SHRIMP',
            'OYSTER', 'HERMIT', 'CANARY', 'TOUCAN', 'SPIDER', 'BEETLE', 'CICADA', 'MANTIS',
            'WALRUS', 'GIBBON', 'BABOON', 'FERRET', 'WEASEL', 'POSSUM', 'ALPACA', 'VICUNA',
            // Food & Drinks
            'CHEESE', 'COOKIE', 'MUFFIN', 'WAFFLE', 'NOODLE', 'PICKLE', 'TOMATO', 'POTATO',
            'CARROT', 'CELERY', 'PEPPER', 'RADISH', 'TURNIP', 'SQUASH', 'CHERRY', 'ORANGE',
            'LEMON', 'MANGO', 'PAPAYA', 'GRAPES', 'MELON', 'APPLES', 'COFFEE', 'BUTTER',
            'YOGURT', 'PASTRY', 'DONUT', 'BAGEL', 'PRETZE', 'CEREAL', 'OATMEA', 'TACOS',
            'NACHOS', 'FUDGE', 'TOFFEE', 'SUNDAE', 'SORBET', 'GELATO', 'MOUSSE', 'TRUFFLE',
            // Nature & Weather
            'FOREST', 'GARDEN', 'MEADOW', 'VALLEY', 'CANYON', 'ISLAND', 'LAGOON', 'STREAM',
            'BREEZE', 'SUMMER', 'WINTER', 'SPRING', 'AUTUMN', 'SUNSET', 'CLOUDS', 'STORMY',
            'SNOWY', 'FROSTY', 'MISTY', 'FLOWER', 'POLLEN', 'PEBBLE', 'GRAVEL', 'BAMBOO',
            'WILLOW', 'MAPLE', 'SPRUCE', 'JUNGLE', 'DESERT', 'TUNDRA', 'ARCTIC', 'TROPIC',
            'CORAL', 'OYSTER', 'FOSSIL', 'MARBLE', 'QUARTZ', 'COPPER', 'SILVER', 'GOLDEN',
            // Colors & Patterns
            'PURPLE', 'YELLOW', 'ORANGE', 'INDIGO', 'VIOLET', 'MAROON', 'SALMON', 'CORAL',
            'GOLDEN', 'SILVER', 'BRONZE', 'STRIPE', 'POLKA', 'ZIGZAG', 'SWIRLY', 'DOTTED',
            'BRIGHT', 'GLOSSY', 'SHINY', 'SPARKL', 'GLITTE', 'PASTEL', 'NEON',
            // Objects & Things
            'ROCKET', 'PLANET', 'METEOR', 'COMET', 'GALAXY', 'CASTLE', 'PALACE', 'THRONE',
            'CROWN', 'SHIELD', 'SWORD', 'HELMET', 'ARMOR', 'BANNER', 'TROPHY', 'MEDAL',
            'RIBBON', 'BUTTON', 'ZIPPER', 'POCKET', 'BASKET', 'BUCKET', 'MIRROR', 'PILLOW',
            'BLANKE', 'CANDLE', 'LANTERN', 'BEACON', 'BRIDGE', 'TUNNEL', 'TOWERS', 'TEMPLE',
            'MARKET', 'BAKERY', 'CIRCUS', 'ARCADE', 'MUSEUM', 'STUDIO', 'GARAGE', 'CABINS',
            // Actions & Adjectives
            'JUMPIN', 'RUNNIN', 'DANCIN', 'FLYING', 'SWIMMI', 'BOUNCI', 'ZOOMIN', 'RACIN',
            'SMILIN', 'LAUGHI', 'HAPPY', 'JOLLY', 'MERRY', 'CHEERF', 'PLAYFU', 'CLEVER',
            'MIGHTY', 'SPEEDY', 'SNAPPY', 'GROOVY', 'FUNKY', 'WACKY', 'ZANY', 'SILLY',
            'GOOFY', 'FLUFFY', 'FUZZY', 'CRISPY', 'CRUNCHY', 'SQUISHY', 'BOUNCY', 'WIGGLY',
            // Fantasy & Magic
            'WIZARD', 'FAERIE', 'SPRITE', 'GOBLIN', 'TROLL', 'GNOME', 'PIXIE', 'MERMAID',
            'UNICOR', 'PHOENIX', 'GRIFFIN', 'KRAKEN', 'SPIRIT', 'MAGICA', 'MYSTIC', 'LEGEND',
            'MYTHIC', 'COSMIC', 'ASTRAL', 'DREAMM', 'FANTSY', 'WONDER', 'MARVEL', 'ENIGMA',
            // Music & Sound
            'MELODY', 'RHYTHM', 'JINGLE', 'CHIMES', 'WHISPE', 'ECHOES', 'STEREO', 'TEMPO',
            'GUITAR', 'VIOLIN', 'FLUTE', 'DRUMS', 'PIANO', 'TRUMPE', 'CYMBAL', 'UKULEL',
            // Sports & Games
            'SOCCER', 'TENNIS', 'HOCKEY', 'BASKET', 'VOLLEY', 'RACKET', 'TROPHY', 'ARCADE',
            'PUZZLE', 'RIDDLE', 'TRIVIA', 'BINGO', 'CHESS', 'DOMINO', 'MARBLE', 'JIGSAW',
            // Places & Geography
            'ALASKA', 'HAWAII', 'LONDON', 'PARIS', 'TOKYO', 'SYDNEY', 'DENVER', 'AUSTIN',
            'BOSTON', 'DALLAS', 'MIAMI', 'VEGAS', 'SEATTLE', 'CHICAGO', 'BERLIN', 'MADRID',
            // Space & Science
            'NEBULA', 'QUASAR', 'PULSAR', 'PHOTON', 'PROTON', 'NEUTRON', 'PLASMA', 'ATOMIC',
            'CARBON', 'OXYGEN', 'HELIUM', 'NEON', 'ARGON', 'XENON', 'RADON', 'KRYPTON',
            // Misc Fun Words
            'DOODLE', 'NOODLE', 'GIGGLE', 'WIGGLE', 'JIGGLE', 'BUBBLE', 'PEBBLE', 'NIBBLE',
            'WOBBLE', 'COBBLE', 'GOBBLE', 'HOBBIT', 'WADDLE', 'PADDLE', 'SADDLE', 'FIDDLE',
            'RIDDLE', 'MIDDLE', 'PUDDLE', 'CUDDLE', 'MUDDLE', 'HUDDLE', 'BUMBLE', 'HUMBLE',
            'JUMBLE', 'MUMBLE', 'RUMBLE', 'TUMBLE', 'FUMBLE', 'CRUMBL', 'GRUMBL', 'STUMBL',
            'JUNGLE', 'BUNGLE', 'TANGLE', 'MANGLE', 'DANGLE', 'JANGLE', 'WRANGLE', 'SPANGLE',
            'TWINKL', 'SPRINKL', 'CRINKL', 'WRINKL', 'TINKLE', 'JINGLE', 'MINGLE', 'SINGLE',
            'SIMPLE', 'DIMPLE', 'PIMPLE', 'RIPPLE', 'NIPPLE', 'TIPPLE', 'SUPPLE', 'PURPLE',
            'TURTLE', 'HURTLE', 'MYRTLE', 'RUSTLE', 'BUSTLE', 'HUSTLE', 'MUSCLE', 'CASTLE',
            'HASSLE', 'TASSEL', 'VESSEL', 'NESTLE', 'WRESTL', 'THISTLE', 'WHISTLE', 'BRISTLE',
            // More Animals
            'BEAGLE', 'POODLE', 'COLLIE', 'HUSKY', 'CORGI', 'DACHSH', 'TERRIE', 'SETTER',
            'HERON', 'CRANE', 'STORK', 'EGRET', 'PELICA', 'SEAGUL', 'PIGEON', 'SPAROW',
            'FINCH', 'ROBIN', 'THRUSH', 'WREN', 'RAVEN', 'MAGPIE', 'BLUEJA', 'CARDIN',
            'CONDOR', 'VULTUR', 'OSPREY', 'KESTRL', 'PEREGR', 'MERLIN', 'HOBBY',
            // Food continued
            'BISCUI', 'CRUMPE', 'SCONE', 'CROISS', 'DANISH', 'ECLAIR', 'CANOLI', 'STRUDE',
            'COBBLE', 'CRISP', 'TART', 'TORTE', 'GATEAU', 'FONDUO', 'RACLTTE', 'QUICHE',
            'BISQUE', 'CHOWDE', 'GUMBO', 'JAMBAL', 'PAELLA', 'RISOTT', 'GNOCCHI', 'RAVIOL',
            'TORTLL', 'BURRIT', 'FAJITA', 'TAMALE', 'ENCHIA', 'QUESAD', 'SALSA', 'GUACAM',
            // Ocean & Beach
            'ANCHOR', 'SAILOR', 'PIRATE', 'CAPTAI', 'VOYAGE', 'HARBOR', 'MARINA', 'LIGHTHOUSE',
            'BEACON', 'BUOY', 'KAYAK', 'CANOE', 'PADDLE', 'SURFIN', 'DIVING', 'SNORKL',
            'SCUBA', 'REEF', 'ATOLL', 'SHOAL', 'SANDBA', 'DRIFTW', 'SHELLS', 'CONCH',
            // Adventure
            'QUEST', 'SAFARI', 'VOYAGE', 'JOURNY', 'ADVENT', 'EXPLOR', 'DISCOV', 'TREASR',
            'BOUNTY', 'REWARD', 'SECRET', 'HIDDEN', 'MYSTIC', 'ENIGMA', 'PUZZLE', 'RIDDLE',
            // Positive Words
            'KINDLY', 'GENTLE', 'TENDER', 'CARING', 'LOVING', 'GIVING', 'HELPFUL', 'HONEST',
            'TRUSTY', 'LOYAL', 'BRAVE', 'BOLD', 'DARING', 'FIERCE', 'STRONG', 'MIGHTY',
            'HEROIC', 'NOBLE', 'ROYAL', 'REGAL', 'GRAND', 'SUPERB', 'DIVINE', 'BLISSS',
            // Technology
            'ROBOT', 'CYBORG', 'ANDROID', 'GADGET', 'WIDGET', 'DEVICE', 'GIZMO', 'TECHNO',
            'DIGITAL', 'BINARY', 'PIXEL', 'VECTOR', 'MATRIX', 'CIPHER', 'CRYPTO', 'QUANTUM',
            // Weather continued
            'BLIZZA', 'FLURRY', 'DRIZZL', 'SHOWRS', 'THUNDR', 'LIGHTN', 'TORNAD', 'CYCLONE',
            'TYPHOO', 'MONSOO', 'SQUALL', 'GUST', 'BREEZE', 'ZEPHYR', 'TRADES', 'JETSTR',
            // Buildings
            'CABIN', 'LODGE', 'CHALET', 'VILLA', 'MANOR', 'ESTATE', 'PALACE', 'CASTLE',
            'TOWER', 'TURRET', 'SPIRE', 'STEEPL', 'DOME', 'VAULT', 'CRYPT', 'CHAPEL',
            'ABBEY', 'PRIORY', 'CLOISTER', 'SHRINE', 'TEMPLE', 'PAGODA', 'MOSQUE', 'CATHEDRAL'
        ].filter(w => w.length === 6); // Ensure all are exactly 6 letters

        /**
         * Generate a unique lobby code from memorable words
         * Checks database to ensure code isn't already in use
         */
        async function generateLobbyCode() {
            // Shuffle and try words until we find an unused one
            const shuffled = [...LOBBY_WORDS].sort(() => Math.random() - 0.5);

            for (const word of shuffled.slice(0, 20)) { // Try up to 20 words
                if (supabaseClient) {
                    const { data: existing } = await supabaseClient
                        .from('game_lobbies')
                        .select('code')
                        .eq('code', word)
                        .eq('status', 'waiting')
                        .single();

                    if (!existing) {
                        return word; // Word is available
                    }
                } else {
                    return word; // No database, just return first word
                }
            }

            // Fallback: combine two short words or use random
            const fallback = LOBBY_WORDS[Math.floor(Math.random() * LOBBY_WORDS.length)];
            return fallback || Math.random().toString(36).substring(2, 8).toUpperCase();
        }

        async function joinLobbyWithCode() {
            if (!supabaseClient || !currentUser || !lobbyCodeInput) {
                lobbyJoinError = 'Please enter a lobby code';
                return;
            }

            const code = lobbyCodeInput.toUpperCase().trim();
            if (code.length !== 6) {
                lobbyJoinError = 'Code must be 6 characters';
                return;
            }

            // Find lobby by code
            const { data: lobby, error } = await supabaseClient
                .from('game_lobbies')
                .select('*')
                .eq('code', code)
                .eq('status', 'waiting')
                .single();

            if (error || !lobby) {
                lobbyJoinError = 'Lobby not found or game already started';
                return;
            }

            // Check if lobby is full
            const { data: players } = await supabaseClient
                .from('lobby_players')
                .select('id')
                .eq('lobby_id', lobby.id);

            if (players && players.length >= MAX_LOBBY_PLAYERS) {
                lobbyJoinError = 'Lobby is full (max 7 players)';
                return;
            }

            // Join the lobby
            currentLobby = lobby;
            isLobbyHost = false;
            selectedLand = lobby.land;
            await joinLobbyAsPlayer(currentLobby.id);
            subscribeLobbyUpdates(currentLobby.id);
            lobbyJoinError = '';
            gameState = 'lobby';
        }

        // Multiplayer game seed - shared across all players
        let multiplayerGameSeed = 0;

        async function hostStartGame() {
            if (!supabaseClient || !currentLobby || !isLobbyHost) return;
            if (lobbyPlayers.length < 2) return;

            // Generate a random seed for this game
            multiplayerGameSeed = Math.floor(Math.random() * 2147483647);
            console.log(`[Host] Generated game seed: ${multiplayerGameSeed}`);

            // First, ensure game channel is ready, then broadcast seed
            if (!gameChannel) {
                subscribeGameUpdates();
            }

            // Wait a moment for channel to be ready, then broadcast seed and start
            setTimeout(async () => {
                // Broadcast seed to all players
                if (gameChannel) {
                    gameChannel.send({
                        type: 'broadcast',
                        event: 'game_seed',
                        payload: { seed: multiplayerGameSeed }
                    });
                }

                // Update lobby status to trigger game start for all
                await supabaseClient
                    .from('game_lobbies')
                    .update({ status: 'playing' })
                    .eq('id', currentLobby.id);
            }, 500);
        }

        async function hostPlayAgain() {
            if (!supabaseClient || !currentLobby || !isLobbyHost) return;

            // Generate new seed for this round
            multiplayerGameSeed = Math.floor(Math.random() * 2147483647);
            console.log(`[Host] Generated new game seed for play again: ${multiplayerGameSeed}`);

            // Broadcast play again signal with new seed
            if (gameChannel) {
                gameChannel.send({
                    type: 'broadcast',
                    event: 'play_again',
                    payload: { seed: multiplayerGameSeed }
                });
            }

            // Start locally (reload players to remove anyone who left)
            await resetMultiplayerGame();
        }

        function leaveMultiplayerResults() {
            // Clean up and go to menu
            if (gameChannel) {
                supabaseClient.removeChannel(gameChannel);
                gameChannel = null;
            }
            if (lobbySubscription) {
                supabaseClient.removeChannel(lobbySubscription);
                lobbySubscription = null;
            }
            currentLobby = null;
            lobbyPlayers = [];
            isLobbyHost = false;
            multiplayerPlayers = [];
            allPlayersStates = {};
            gameMode = 'solo';
            gameState = 'menu';
        }

        async function resetMultiplayerGame() {
            // Reset local state for new round
            localPlayerAlive = true;
            gameResult = null;
            scoreSaved = false;

            // IMPORTANT: Reload lobby players from database to get current active players
            // This removes players who left during the previous round
            if (supabaseClient && currentLobby) {
                await loadLobbyPlayers(currentLobby.id);
                console.log(`[Reset] Reloaded ${lobbyPlayers.length} active players`);
            }

            // Initialize seeded random with shared seed for synchronized obstacles
            if (multiplayerGameSeed) {
                initGameSeed(multiplayerGameSeed);
            }

            // Reinitialize all players from lobby (only active players)
            initializeMultiplayerPlayers();

            // Start the game
            startGame();

            // Position local player based on their index (host rightmost, joiners to left)
            if (player) {
                const playerCount = lobbyPlayers.length;
                player.x = 80 + ((playerCount - 1 - localPlayerIndex) * PLAYER_STAGGER_X);
            }

            // Set game state to playing
            gameState = 'playing';
        }

        // ============================================
        // SKINS & ACHIEVEMENTS FUNCTIONS
        // ============================================
        async function loadPlayerProgress() {
            if (!supabaseClient || !currentUser) return;

            try {
                // Load unlocked skins
                const { data: skins, error: skinsError } = await supabaseClient
                    .from('player_skins')
                    .select('skin_id')
                    .eq('player_id', currentUser.id);

                if (!skinsError && skins) {
                    unlockedSkins = ['default', ...skins.map(s => s.skin_id)];
                }

                // Load equipped skin and spendable bananas from profile
                if (userProfile?.equipped_skin) {
                    selectedSkin = userProfile.equipped_skin;
                }
                // Load spendable bananas (default to total_bananas for migration)
                spendableBananas = userProfile?.spendable_bananas ?? userProfile?.total_bananas ?? 0;

                // Load achievements
                const { data: achievements, error: achievementsError } = await supabaseClient
                    .from('player_achievements')
                    .select('achievement_id')
                    .eq('player_id', currentUser.id);

                if (!achievementsError && achievements) {
                    unlockedAchievements = achievements.map(a => a.achievement_id);
                }
            } catch (err) {
                // Continue anyway - skins/achievements are not critical
            }
        }

        async function unlockSkin(skinId) {
            if (!supabaseClient || !currentUser || unlockedSkins.includes(skinId)) return;

            const { error } = await supabaseClient
                .from('player_skins')
                .insert({ player_id: currentUser.id, skin_id: skinId });

            if (!error) {
                unlockedSkins.push(skinId);
                showNotification(`Skin Unlocked: ${SKINS[skinId].name}!`);
            }
        }

        async function unlockAchievement(achievementId) {
            if (!currentUser || unlockedAchievements.includes(achievementId)) return;

            const achievement = ACHIEVEMENTS[achievementId];
            if (!achievement) return;

            // Persist to database
            if (supabaseClient) {
                const { error } = await supabaseClient
                    .from('player_achievements')
                    .insert({ player_id: currentUser.id, achievement_id: achievementId });

                if (error) {
                    console.error('Error unlocking achievement:', error);
                    return;
                }

                // Award banana reward
                if (achievement.reward > 0) {
                    spendableBananas += achievement.reward;

                    await supabaseClient
                        .from('profiles')
                        .update({ spendable_bananas: spendableBananas })
                        .eq('id', currentUser.id);

                    if (userProfile) {
                        userProfile.spendable_bananas = spendableBananas;
                    }
                }
            }

            unlockedAchievements.push(achievementId);
            showNotification(`Achievement: ${achievement.name}! +${achievement.reward} bananas`);
        }

        async function equipSkin(skinId) {
            if (!unlockedSkins.includes(skinId)) return;

            selectedSkin = skinId;

            if (supabaseClient && currentUser) {
                await supabaseClient
                    .from('profiles')
                    .update({ equipped_skin: skinId })
                    .eq('id', currentUser.id);
            }
        }

        async function purchaseSkin(skinId) {
            const skin = SKINS[skinId];

            // Validation
            if (!skin || skin.type !== 'purchasable') return;
            if (unlockedSkins.includes(skinId)) return; // Already owned
            if (spendableBananas < skin.price) return; // Can't afford

            // Deduct and unlock
            spendableBananas -= skin.price;
            unlockedSkins.push(skinId);
            showNotification(`Purchased: ${skin.name}!`);

            // Update local stats
            playerStats.total_purchases = (playerStats.total_purchases || 0) + 1;
            playerStats.total_spent = (playerStats.total_spent || 0) + skin.price;

            // Persist to Supabase
            if (supabaseClient && currentUser) {
                // Update profile with new balance and purchase stats
                const { error: updateError } = await supabaseClient
                    .from('profiles')
                    .update({
                        spendable_bananas: spendableBananas,
                        total_purchases: playerStats.total_purchases,
                        total_spent: playerStats.total_spent
                    })
                    .eq('id', currentUser.id);

                if (updateError) {
                    console.error('Error updating balance:', updateError);
                    // Rollback on error
                    spendableBananas += skin.price;
                    unlockedSkins = unlockedSkins.filter(s => s !== skinId);
                    playerStats.total_purchases--;
                    playerStats.total_spent -= skin.price;
                    return;
                }

                // Record skin purchase
                const { error: skinError } = await supabaseClient
                    .from('player_skins')
                    .insert({ player_id: currentUser.id, skin_id: skinId });

                if (skinError) {
                    console.error('Error recording skin:', skinError);
                }

                // Update local profile
                if (userProfile) {
                    userProfile.spendable_bananas = spendableBananas;
                    userProfile.total_purchases = playerStats.total_purchases;
                    userProfile.total_spent = playerStats.total_spent;
                }
            }
        }

        /**
         * Check all achievements against current player stats
         * Called after each game to award any newly earned achievements
         * Note: This is called AFTER saveScore(), so playerStats should be updated
         */
        function checkAchievements(gameScore, gameBananas, gameTimeSeconds, isMultiplayer, didWin) {
            if (!userProfile) return;

            // Track land played locally
            landsPlayed.add(selectedLand);

            // Get the current land key for checking land-specific stats
            const landKey = selectedLand.toLowerCase();

            // Build current stats object for checking
            // Include the current game's contributions
            const stats = {
                // Core stats (playerStats should already include this game's data)
                total_games: playerStats.total_games || 0,
                high_score: Math.max(playerStats.high_score || 0, gameScore),
                total_bananas: playerStats.total_bananas || 0,
                total_time_played: (playerStats.total_time_played || 0) + gameTimeSeconds,
                jetpacks_collected: playerStats.jetpacks_collected || 0,
                dino_stomps_collected: playerStats.dino_stomps_collected || 0,
                highest_level_reached: Math.max(playerStats.highest_level_reached || 0, highestLevelReached),

                // Land-specific (use playerStats which was just updated)
                snow_games_played: playerStats.snow_games_played || 0,
                desert_games_played: playerStats.desert_games_played || 0,
                jungle_games_played: playerStats.jungle_games_played || 0,
                ocean_games_played: playerStats.ocean_games_played || 0,

                // These need special handling since they're not always persisted
                times_reached_rank_one: playerStats.times_reached_rank_one || 0,
                total_purchases: playerStats.total_purchases || 0,

                // Multiplayer stats - add current game contribution
                multiplayer_games: (playerStats.multiplayer_games || 0) + (isMultiplayer ? 1 : 0),
                multiplayer_wins: (playerStats.multiplayer_wins || 0) + (isMultiplayer && didWin ? 1 : 0),

                // Special check for all lands
                all_lands_played: landsPlayed.size >= 4
            };

            // Check each achievement
            for (const [achievementId, achievement] of Object.entries(ACHIEVEMENTS)) {
                // Skip if already unlocked
                if (unlockedAchievements.includes(achievementId)) continue;

                const req = achievement.requirement;
                if (!req) continue;

                let shouldUnlock = false;

                // Special handling for all_lands_played
                if (req.type === 'all_lands_played') {
                    shouldUnlock = stats.all_lands_played;
                }
                // Standard numeric comparisons
                else if (stats[req.type] !== undefined) {
                    shouldUnlock = stats[req.type] >= req.value;
                }

                if (shouldUnlock) {
                    unlockAchievement(achievementId);
                }
            }

            // Check skin unlocks based on achievements
            // Pass multiplayer wins from this game
            const mpWinsThisGame = (isMultiplayer && didWin) ? 1 : 0;
            checkSkinUnlocks(gameScore, mpWinsThisGame);
        }

        function checkSkinUnlocks(gameScore, multiplayerWins = 0) {
            if (!userProfile) return;

            // Golden - 100 total bananas
            if ((userProfile.total_bananas || 0) >= 100) {
                unlockSkin('golden');
            }

            // Speedster - 5000 points in one game
            if (gameScore >= 5000) {
                unlockSkin('speedster');
            }

            // Veteran - 50 games
            if ((userProfile.total_games || 0) >= 50) {
                unlockSkin('veteran');
            }

            // Champion - 10 multiplayer wins
            const totalMpWins = (playerStats.multiplayer_wins || 0) + multiplayerWins;
            if (totalMpWins >= 10) {
                unlockSkin('champion');
            }
        }

        /**
         * Retroactively check all achievements against current player stats.
         * Fetches fresh data from database, checks each incomplete achievement,
         * and unlocks any that should have been earned.
         *
         * @returns {Promise<{checked: number, unlocked: number, newRewards: number}>}
         */
        async function checkAllAchievementsRetroactive() {
            if (!currentUser || !supabaseClient) {
                return { checked: 0, unlocked: 0, newRewards: 0 };
            }

            // Fetch fresh profile data from database
            const { data: profile, error } = await supabaseClient
                .from('profiles')
                .select('*')
                .eq('id', currentUser.id)
                .single();

            if (error || !profile) {
                console.error('Error fetching profile for achievement check:', error);
                return { checked: 0, unlocked: 0, newRewards: 0 };
            }

            // Update local state with fresh data
            Object.assign(playerStats, {
                total_games: profile.total_games || 0,
                high_score: profile.high_score || 0,
                total_score: profile.total_score || 0,
                total_bananas: profile.total_bananas || 0,
                spendable_bananas: profile.spendable_bananas || 0,
                total_time_played: profile.total_time_played || 0,
                jetpacks_collected: profile.jetpacks_collected || 0,
                dino_stomps_collected: profile.dino_stomps_collected || 0,
                snow_games_played: profile.snow_games_played || 0,
                desert_games_played: profile.desert_games_played || 0,
                jungle_games_played: profile.jungle_games_played || 0,
                ocean_games_played: profile.ocean_games_played || 0,
                highest_level_reached: profile.highest_level_reached || 0,
                times_reached_rank_one: profile.times_reached_rank_one || 0,
                total_purchases: profile.total_purchases || 0,
                total_spent: profile.total_spent || 0,
                multiplayer_games: profile.multiplayer_games || 0,
                multiplayer_wins: profile.multiplayer_wins || 0
            });

            // Also update userProfile
            if (userProfile) {
                Object.assign(userProfile, profile);
            }
            spendableBananas = profile.spendable_bananas || 0;

            // Build stats object for checking
            const stats = {
                total_games: playerStats.total_games,
                high_score: playerStats.high_score,
                total_bananas: playerStats.total_bananas,
                total_time_played: playerStats.total_time_played,
                jetpacks_collected: playerStats.jetpacks_collected,
                dino_stomps_collected: playerStats.dino_stomps_collected,
                highest_level_reached: playerStats.highest_level_reached,
                snow_games_played: playerStats.snow_games_played,
                desert_games_played: playerStats.desert_games_played,
                jungle_games_played: playerStats.jungle_games_played,
                ocean_games_played: playerStats.ocean_games_played,
                times_reached_rank_one: playerStats.times_reached_rank_one,
                total_purchases: playerStats.total_purchases,
                multiplayer_games: playerStats.multiplayer_games || 0,
                multiplayer_wins: playerStats.multiplayer_wins || 0,
                // Check if all 4 lands have been played
                all_lands_played: (playerStats.snow_games_played > 0) &&
                                   (playerStats.desert_games_played > 0) &&
                                   (playerStats.jungle_games_played > 0) &&
                                   (playerStats.ocean_games_played > 0)
            };

            let checked = 0;
            let unlocked = 0;
            let newRewards = 0;

            // Check each achievement that isn't already unlocked
            for (const [achievementId, achievement] of Object.entries(ACHIEVEMENTS)) {
                if (unlockedAchievements.includes(achievementId)) continue;

                checked++;
                const req = achievement.requirement;
                if (!req) continue;

                let shouldUnlock = false;

                // Special handling for all_lands_played
                if (req.type === 'all_lands_played') {
                    shouldUnlock = stats.all_lands_played;
                }
                // Standard numeric comparisons
                else if (stats[req.type] !== undefined) {
                    shouldUnlock = stats[req.type] >= req.value;
                }

                if (shouldUnlock) {
                    await unlockAchievement(achievementId);
                    unlocked++;
                    newRewards += achievement.reward || 0;
                }
            }

            // Also check skin unlocks
            checkSkinUnlocks(playerStats.high_score, 0);

            return { checked, unlocked, newRewards };
        }

        // Notification system
        let notifications = [];

        function showNotification(message) {
            notifications.push({
                message,
                time: Date.now(),
                opacity: 1
            });

            // Remove after 3 seconds
            setTimeout(() => {
                notifications.shift();
            }, 3000);
        }

        function drawNotifications() {
            const now = Date.now();
            notifications.forEach((notif, i) => {
                const age = now - notif.time;
                const opacity = Math.max(0, 1 - (age / 3000));

                ctx.globalAlpha = opacity;
                ctx.fillStyle = '#FFE135';
                ctx.font = 'bold 20px monospace';
                ctx.textAlign = 'center';
                ctx.fillText(notif.message, canvas.width / 2, 100 + i * 30);
                ctx.globalAlpha = 1;
            });
        }

        // ============================================
        // AUTH UI FUNCTIONS
        // ============================================
        function showAuthModal() {
            document.getElementById('authModal').classList.add('active');
            document.getElementById('authError').textContent = '';
            document.getElementById('authSuccess').style.display = 'none';
        }

        function closeAuthModal() {
            document.getElementById('authModal').classList.remove('active');
            document.getElementById('authError').textContent = '';
            document.getElementById('authSuccess').style.display = 'none';
            // Go to menu after login (only if logged in)
            if (currentUser) {
                gameState = 'menu';
            }
        }

        function toggleAuthMode() {
            isAuthMode = isAuthMode === 'login' ? 'signup' : 'login';

            const title = document.getElementById('authTitle');
            const submit = document.getElementById('authSubmit');
            const toggle = document.getElementById('authToggle');

            if (isAuthMode === 'signup') {
                title.textContent = 'Sign Up';
                submit.textContent = 'Create Account';
                toggle.innerHTML = 'Already have an account? <a onclick="toggleAuthMode()">Login</a>';
            } else {
                title.textContent = 'Login';
                submit.textContent = 'Login';
                toggle.innerHTML = 'Don\'t have an account? <a onclick="toggleAuthMode()">Sign Up</a>';
            }

            document.getElementById('authError').textContent = '';
            document.getElementById('authSuccess').style.display = 'none';
        }

        // Expose functions to global scope for HTML onclick handlers
        window.toggleAuthMode = toggleAuthMode;
        window.logout = logout;

        function showAuthError(message) {
            document.getElementById('authError').textContent = message;
            document.getElementById('authSuccess').style.display = 'none';
        }

        function showAuthSuccess(message) {
            document.getElementById('authSuccess').textContent = message;
            document.getElementById('authSuccess').style.display = 'block';
            document.getElementById('authError').textContent = '';
        }

        function updateUserDisplay() {
            const userInfo = document.getElementById('userInfo');
            const displayName = document.getElementById('displayUsername');

            if (currentUser && userProfile) {
                displayName.textContent = userProfile.username || 'Player';
                userInfo.style.display = 'block';
            } else {
                userInfo.style.display = 'none';
            }
        }

        // Auth form handler
        document.getElementById('authForm').addEventListener('submit', async (e) => {
            e.preventDefault();

            const username = document.getElementById('authUsername').value.trim();
            const password = document.getElementById('authPassword').value;

            if (!username) {
                showAuthError('Username is required');
                return;
            }

            if (isAuthMode === 'signup') {
                await signUp(username, password);
            } else {
                await signIn(username, password);
            }
        });

        // Click outside modal to close
        document.getElementById('authModal').addEventListener('click', (e) => {
            // Only close if clicking the overlay itself, not the modal content
            if (e.target.id === 'authModal') {
                closeAuthModal();
            }
        });

        // Initialize Supabase when DOM is ready
        document.addEventListener('DOMContentLoaded', initSupabase);

        // Resize canvas to fill screen
        let lastCanvasHeight = 0;

        function resizeCanvas() {
            const oldWidth = canvas.width;
            const oldHeight = canvas.height;
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            ctx.imageSmoothingEnabled = false;

            // Detect significant orientation/size change (more than 100px difference)
            const significantChange = (Math.abs(canvas.width - oldWidth) > 100 ||
                                       Math.abs(canvas.height - oldHeight) > 100);

            // Handle resize during active gameplay
            if (oldHeight > 0 && player !== null && typeof PLAYER_HEIGHT !== 'undefined') {
                const newGroundLevel = canvas.height - 70;

                // Always snap player to correct ground position
                if (!player.jumping) {
                    player.y = newGroundLevel - PLAYER_HEIGHT;
                } else {
                    // Adjust jump position proportionally
                    const oldGroundLevel = oldHeight - 70;
                    const groundDiff = newGroundLevel - oldGroundLevel;
                    player.y += groundDiff;

                    // Ensure player doesn't end up below ground
                    if (player.y > newGroundLevel - PLAYER_HEIGHT) {
                        player.y = newGroundLevel - PLAYER_HEIGHT;
                        player.jumping = false;
                        player.vy = 0;
                    }
                }

                // Reposition all entities on resize (including orientation change)
                // Entities keep their X position but Y adjusts to new ground level
                if (entities && entities.length > 0) {
                    const newGroundLevel = canvas.height - 70;
                    const widthRatio = canvas.width / oldWidth;

                    for (let i = entities.length - 1; i >= 0; i--) {
                        const ent = entities[i];
                        const entHeight = ent.pixels.length * ent.scale;

                        // Scale X position proportionally for width changes
                        if (significantChange && widthRatio !== 1) {
                            ent.x = ent.x * widthRatio;
                        }

                        // Snap to new ground level
                        if (ent.type === 'obstacle') {
                            ent.y = newGroundLevel - entHeight;
                        } else if (ent.type === 'banana') {
                            ent.y = newGroundLevel - entHeight - BANANA_HEIGHT_OFFSET;
                        }

                        // Remove entities now off-screen (but keep ones ahead)
                        if (ent.x < -100) {
                            entities.splice(i, 1);
                        }
                    }
                }
            }

            lastCanvasHeight = canvas.height;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // Dynamic constants based on screen size
        // Note: PLAYER_SCALE, ENTITY_SCALE, BANANA_HEIGHT_OFFSET imported from config.js
        function getGroundLevel() {
            return canvas.height - 70;
        }

        // High-definition pixel art sprites (32x48 runners, doubled detail)
        const sprites = {
            // Snow runner - winter hat with pom-pom, puffy jacket (32x48)
            runnerSnow: [
                [0,0,0,0,0,0,0,0,0,0,0,0,0,7,7,7,7,7,7,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,7,7,7,7,7,7,7,7,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,4,4,4,4,4,4,4,4,4,4,4,4,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,4,4,4,4,4,4,4,4,4,4,4,4,4,4,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,1,2,2,2,2,2,2,1,1,2,2,2,2,2,2,1,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,1,2,2,3,3,2,2,1,1,2,2,3,3,2,2,1,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,1,2,2,3,3,2,2,2,2,2,2,3,3,2,2,1,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,1,1,2,2,2,2,2,2,2,2,2,2,2,2,1,1,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,1,1,2,2,2,8,8,8,8,2,2,2,1,1,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,1,1,2,2,2,2,2,2,2,2,1,1,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,5,5,5,5,5,5,5,5,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,4,4,4,4,4,4,4,4,4,4,4,4,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,4,4,4,4,4,4,4,4,4,4,4,4,4,4,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,0,0,0,0,0,0],
                [0,0,0,0,0,2,2,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,2,2,0,0,0,0,0],
                [0,0,0,0,2,2,2,2,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,2,2,2,2,0,0,0,0],
                [0,0,0,0,2,2,2,0,0,4,4,4,4,4,4,4,4,4,4,4,4,4,4,0,0,2,2,2,0,0,0,0],
                [0,0,0,0,2,2,0,0,0,4,4,4,4,4,4,4,4,4,4,4,4,4,4,0,0,0,2,2,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,4,4,4,4,4,4,4,4,4,4,4,4,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,4,4,4,4,4,4,4,4,4,4,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,5,5,5,5,0,0,5,5,5,5,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,5,5,5,5,0,0,5,5,5,5,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,5,5,5,5,5,0,0,5,5,5,5,5,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,5,5,5,5,0,0,0,0,5,5,5,5,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,5,5,5,5,5,0,0,0,0,5,5,5,5,5,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,5,5,5,5,0,0,0,0,0,0,5,5,5,5,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,5,5,5,5,5,0,0,0,0,0,0,5,5,5,5,5,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,5,5,5,5,0,0,0,0,0,0,0,0,5,5,5,5,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,5,5,5,5,5,0,0,0,0,0,0,0,0,5,5,5,5,5,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,5,5,5,5,0,0,0,0,0,0,0,0,0,0,5,5,5,5,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,6,6,6,6,6,6,0,0,0,0,0,0,0,0,6,6,6,6,6,6,0,0,0,0,0,0],
                [0,0,0,0,0,0,6,6,6,6,6,6,0,0,0,0,0,0,0,0,6,6,6,6,6,6,0,0,0,0,0,0],
                [0,0,0,0,0,0,6,6,6,6,6,6,0,0,0,0,0,0,0,0,6,6,6,6,6,6,0,0,0,0,0,0],
                [0,0,0,0,0,0,6,6,6,6,6,6,0,0,0,0,0,0,0,0,6,6,6,6,6,6,0,0,0,0,0,0]
            ],
            // Desert runner - cowboy hat, vest (32x48)
            runnerDesert: [
                [0,0,0,0,0,0,0,0,0,0,0,0,4,4,4,4,4,4,4,4,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,4,4,4,4,4,4,4,4,4,4,4,4,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,4,4,4,4,4,4,4,4,4,4,4,4,4,4,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,0,0,0,0,0,0],
                [0,0,0,0,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,1,2,2,2,2,2,2,2,2,2,2,2,2,1,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,1,2,2,3,3,2,2,2,2,3,3,2,2,1,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,1,2,2,3,3,2,2,2,2,3,3,2,2,1,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,1,1,2,2,2,2,2,2,2,2,2,2,1,1,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,1,1,2,2,8,8,8,8,2,2,1,1,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,1,1,2,2,2,2,2,2,1,1,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,5,5,5,5,5,5,5,5,5,5,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,5,5,5,5,5,5,5,5,5,5,5,5,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,5,5,5,6,6,6,6,6,6,6,6,5,5,5,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,5,5,5,5,6,6,6,6,6,6,6,6,5,5,5,5,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,5,5,5,5,5,6,6,6,6,6,6,6,6,5,5,5,5,5,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,5,5,5,5,5,5,6,6,6,6,6,6,6,6,5,5,5,5,5,5,0,0,0,0,0,0],
                [0,0,0,0,0,2,2,5,5,5,5,5,6,6,6,6,6,6,6,6,5,5,5,5,5,2,2,0,0,0,0,0],
                [0,0,0,0,2,2,2,2,5,5,5,5,6,6,6,6,6,6,6,6,5,5,5,5,2,2,2,2,0,0,0,0],
                [0,0,0,0,2,2,2,0,0,5,5,5,5,5,5,5,5,5,5,5,5,5,5,0,0,2,2,2,0,0,0,0],
                [0,0,0,0,2,2,0,0,0,5,5,5,5,5,5,5,5,5,5,5,5,5,5,0,0,0,2,2,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,5,5,5,5,5,5,5,5,5,5,5,5,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,5,5,5,5,5,5,5,5,5,5,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,7,7,7,7,0,0,7,7,7,7,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,7,7,7,7,0,0,7,7,7,7,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,7,7,7,7,7,0,0,7,7,7,7,7,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,7,7,7,7,0,0,0,0,7,7,7,7,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,7,7,7,7,7,0,0,0,0,7,7,7,7,7,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,7,7,7,7,0,0,0,0,0,0,7,7,7,7,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,7,7,7,7,7,0,0,0,0,0,0,7,7,7,7,7,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,7,7,7,7,0,0,0,0,0,0,0,0,7,7,7,7,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,7,7,7,7,7,0,0,0,0,0,0,0,0,7,7,7,7,7,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,7,7,7,7,0,0,0,0,0,0,0,0,0,0,7,7,7,7,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,9,9,9,9,9,9,0,0,0,0,0,0,0,0,9,9,9,9,9,9,0,0,0,0,0,0],
                [0,0,0,0,0,0,9,9,9,9,9,9,0,0,0,0,0,0,0,0,9,9,9,9,9,9,0,0,0,0,0,0],
                [0,0,0,0,0,0,9,9,9,9,9,9,0,0,0,0,0,0,0,0,9,9,9,9,9,9,0,0,0,0,0,0],
                [0,0,0,0,0,0,9,9,9,9,9,9,0,0,0,0,0,0,0,0,9,9,9,9,9,9,0,0,0,0,0,0]
            ],
            // Jungle runner - Tarzan loincloth, bare chest (32x48)
            runnerJungle: [
                [0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,1,2,2,2,2,2,2,1,1,2,2,2,2,2,2,1,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,1,2,2,3,3,2,2,2,2,2,2,3,3,2,2,1,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,1,2,2,3,3,2,2,2,2,2,2,3,3,2,2,1,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,1,1,2,2,2,2,2,2,2,2,2,2,2,2,1,1,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,1,1,2,2,2,2,2,2,2,2,2,2,1,1,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,1,1,2,2,2,2,2,2,2,2,1,1,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,2,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,2,2,2,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,2,2,2,2,2,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,0,0,0,0,0,0],
                [0,0,0,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,0,0,0,0],
                [0,0,0,0,2,2,2,2,0,0,2,2,2,2,2,2,2,2,2,2,2,2,0,0,2,2,2,2,0,0,0,0],
                [0,0,0,0,2,2,2,0,0,0,2,2,2,2,2,2,2,2,2,2,2,2,0,0,0,2,2,2,0,0,0,0],
                [0,0,0,0,2,2,0,0,0,0,0,4,4,4,4,4,4,4,4,4,4,0,0,0,0,0,2,2,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,4,4,4,4,4,4,4,4,4,4,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,4,4,4,4,4,4,4,4,4,4,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,4,4,4,4,4,4,4,4,4,4,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,0,0,2,2,2,2,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,0,0,2,2,2,2,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,0,0,2,2,2,2,2,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,2,2,2,2,0,0,0,0,2,2,2,2,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,2,2,2,2,2,0,0,0,0,2,2,2,2,2,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,2,2,2,2,0,0,0,0,0,0,2,2,2,2,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,2,2,2,2,2,0,0,0,0,0,0,2,2,2,2,2,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,2,2,2,2,0,0,0,0,0,0,0,0,2,2,2,2,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,2,2,2,2,2,0,0,0,0,0,0,0,0,2,2,2,2,2,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,2,2,2,2,0,0,0,0,0,0,0,0,0,0,2,2,2,2,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,2,2,2,2,0,0,0,0,0,0,0,0,0,0,2,2,2,2,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,2,2,2,2,0,0,0,0,0,0,0,0,0,0,2,2,2,2,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,2,2,2,2,0,0,0,0,0,0,0,0,0,0,2,2,2,2,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,2,2,2,2,0,0,0,0,0,0,0,0,0,0,2,2,2,2,0,0,0,0,0,0,0]
            ],
            // Ocean runner - scuba helmet, wetsuit (32x48)
            runnerOcean: [
                [0,0,0,0,0,0,0,0,0,0,4,4,4,4,4,4,4,4,4,4,4,4,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,4,4,4,4,4,4,4,4,4,4,4,4,4,4,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,4,4,4,5,5,5,5,4,4,4,4,5,5,5,5,4,4,4,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,4,4,4,5,5,5,5,4,4,4,4,5,5,5,5,4,4,4,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,4,4,4,5,5,3,3,4,4,4,4,3,3,5,5,4,4,4,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,4,4,4,5,5,3,3,4,4,4,4,3,3,5,5,4,4,4,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,4,4,4,4,4,4,4,4,4,4,4,4,4,4,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,4,4,4,4,4,4,4,4,4,4,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,6,6,6,6,6,6,6,6,6,6,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,6,6,6,6,6,6,6,6,6,6,6,6,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,6,6,6,6,6,6,6,6,6,6,6,6,6,6,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,0,0,0,0,0,0],
                [0,0,0,0,0,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,0,0,0,0,0],
                [0,0,0,0,6,6,6,6,0,0,6,6,6,6,6,6,6,6,6,6,6,6,0,0,6,6,6,6,0,0,0,0],
                [0,0,0,0,6,6,6,0,0,0,6,6,6,6,6,6,6,6,6,6,6,6,0,0,0,6,6,6,0,0,0,0],
                [0,0,0,0,6,6,0,0,0,0,6,6,6,6,6,6,6,6,6,6,6,6,0,0,0,0,6,6,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,6,6,6,6,6,6,6,6,6,6,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,6,6,6,6,6,6,6,6,6,6,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,6,6,6,6,0,0,6,6,6,6,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,6,6,6,6,0,0,6,6,6,6,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,6,6,6,6,6,0,0,6,6,6,6,6,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,6,6,6,6,0,0,0,0,6,6,6,6,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,6,6,6,6,6,0,0,0,0,6,6,6,6,6,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,6,6,6,6,0,0,0,0,0,0,6,6,6,6,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,6,6,6,6,6,0,0,0,0,0,0,6,6,6,6,6,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,6,6,6,6,0,0,0,0,0,0,0,0,6,6,6,6,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,6,6,6,6,6,0,0,0,0,0,0,0,0,6,6,6,6,6,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,6,6,6,6,0,0,0,0,0,0,0,0,0,0,6,6,6,6,0,0,0,0,0,0,0],
                [0,0,0,0,0,7,7,7,7,7,7,7,7,0,0,0,0,0,0,7,7,7,7,7,7,7,7,0,0,0,0,0],
                [0,0,0,0,0,7,7,7,7,7,7,7,7,0,0,0,0,0,0,7,7,7,7,7,7,7,7,0,0,0,0,0],
                [0,0,0,0,0,7,7,7,7,7,7,7,7,0,0,0,0,0,0,7,7,7,7,7,7,7,7,0,0,0,0,0],
                [0,0,0,0,0,7,7,7,7,7,7,7,7,0,0,0,0,0,0,7,7,7,7,7,7,7,7,0,0,0,0,0]
            ],
            // Curved banana (20x36 pixels) - doubled detail
            banana: [
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,3,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,3,3,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,3,3,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,3,3,3,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,3,3,3,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,1,1,2,2,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,1,1,1,1,2,2,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,2,0,0,0,0],
                [0,0,0,0,0,0,0,0,1,1,1,1,1,1,2,2,0,0,0,0],
                [0,0,0,0,0,0,0,1,1,1,1,1,1,1,2,2,0,0,0,0],
                [0,0,0,0,0,0,1,1,1,1,1,1,1,2,2,0,0,0,0,0],
                [0,0,0,0,0,1,1,1,1,1,1,1,1,2,2,0,0,0,0,0],
                [0,0,0,0,1,1,1,1,1,1,1,1,2,2,0,0,0,0,0,0],
                [0,0,0,1,1,1,1,1,1,1,1,1,2,2,0,0,0,0,0,0],
                [0,0,1,1,1,1,1,1,1,1,1,2,2,0,0,0,0,0,0,0],
                [0,1,1,1,1,1,1,1,1,1,1,2,2,0,0,0,0,0,0,0],
                [0,1,1,1,1,1,1,1,1,1,2,2,0,0,0,0,0,0,0,0],
                [1,1,1,1,1,1,1,1,1,1,2,2,0,0,0,0,0,0,0,0],
                [1,1,1,1,1,1,1,1,1,2,2,0,0,0,0,0,0,0,0,0],
                [1,1,1,1,1,1,1,1,1,2,2,0,0,0,0,0,0,0,0,0],
                [1,1,1,1,1,1,1,1,2,2,0,0,0,0,0,0,0,0,0,0],
                [1,1,1,1,1,1,1,1,2,2,0,0,0,0,0,0,0,0,0,0],
                [1,1,1,1,1,1,1,2,2,0,0,0,0,0,0,0,0,0,0,0],
                [0,1,1,1,1,1,1,2,2,0,0,0,0,0,0,0,0,0,0,0],
                [0,1,1,1,1,1,2,2,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,1,1,1,1,2,2,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,1,1,1,1,2,2,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,1,1,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,1,1,2,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,4,4,4,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,4,4,4,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,4,4,0,0,0,0,0,0,0,0,0,0,0,0,0]
            ],
            // Banana Bundle (40x36 pixels) - 3 bananas clustered, worth 300 points
            bananaBundle: [
                [0,0,0,0,0,0,0,0,0,0,0,0,3,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,3,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,3,3,3,0,0,0,0,0,0,0,0,0,0,0,0,0,3,3,3,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,3,3,3,0,0,0,0,0,0,0,0,0,0,0,0,0,3,3,3,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,3,3,3,0,0,0,0,0,0,3,3,0,0,0,0,0,3,3,3,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,3,3,3,0,0,0,0,0,0,3,3,3,0,0,0,0,3,3,3,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,1,1,2,2,0,0,0,0,0,3,3,3,0,0,0,0,1,1,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,1,1,1,1,2,2,0,0,0,3,3,3,0,0,0,0,1,1,1,1,2,2,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,1,1,1,1,1,1,2,0,0,1,1,2,2,0,0,0,1,1,1,1,1,1,2,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,1,1,1,1,1,1,2,2,0,1,1,1,1,2,2,0,1,1,1,1,1,1,2,2,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,1,1,1,1,1,1,1,2,2,1,1,1,1,1,1,2,1,1,1,1,1,1,1,2,2,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,1,1,1,1,1,1,1,2,2,0,1,1,1,1,1,1,2,2,1,1,1,1,1,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,1,1,1,1,1,1,1,1,2,2,0,1,1,1,1,1,2,2,0,0,1,1,1,1,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,1,1,1,1,1,1,1,2,2,0,0,1,1,1,1,1,2,2,0,0,0,1,1,1,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [1,1,1,1,1,1,1,1,2,2,0,0,1,1,1,1,2,2,0,0,0,0,0,1,1,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [1,1,1,1,1,1,1,2,2,0,0,0,0,1,1,1,2,2,0,0,0,0,0,0,1,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [1,1,1,1,1,1,1,2,2,0,0,0,0,1,1,2,2,0,0,0,0,0,0,0,4,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [1,1,1,1,1,1,2,2,0,0,0,0,0,0,1,1,2,0,0,0,0,0,0,0,4,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,1,1,1,1,1,2,2,0,0,0,0,0,0,4,4,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,1,1,1,1,2,2,0,0,0,0,0,0,0,4,4,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,1,1,1,2,2,0,0,0,0,0,0,0,0,4,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,1,1,1,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,1,1,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,4,4,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,4,4,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,4,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
            ],
            // Jetpack Power-up (48x48 pixels) - Rocket in circular bubble with green outline
            // 7 = green outline (good collectible)
            jetpack: [
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,7,7,7,7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,7,7,7,7,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,7,7,7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,7,7,7,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,7,7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,7,7,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,7,7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,7,7,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,7,7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,7,7,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,7,7,5,5,5,5,5,5,5,5,5,5,5,5,1,1,1,1,1,1,5,5,5,5,5,5,5,5,5,5,7,7,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,7,7,5,5,5,5,5,5,5,5,5,5,5,5,1,1,1,1,1,1,1,1,5,5,5,5,5,5,5,5,5,5,7,7,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,7,5,5,5,5,5,5,5,5,5,5,5,5,1,1,1,1,1,1,1,1,1,1,5,5,5,5,5,5,5,5,5,5,7,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,7,7,5,5,5,5,5,5,5,5,5,5,5,1,1,1,1,1,1,1,1,1,1,1,1,5,5,5,5,5,5,5,5,5,7,7,0,0,0,0,0,0,0],
                [0,0,0,0,0,7,5,5,5,5,5,5,5,5,5,5,5,5,1,1,1,1,2,2,2,2,1,1,1,1,5,5,5,5,5,5,5,5,5,5,7,0,0,0,0,0,0,0],
                [0,0,0,0,7,7,5,5,5,5,5,5,5,5,5,5,5,5,1,1,1,2,2,2,2,2,2,1,1,1,5,5,5,5,5,5,5,5,5,5,7,7,0,0,0,0,0,0],
                [0,0,0,0,7,5,5,5,5,5,5,5,5,5,5,5,5,5,1,1,1,2,2,2,2,2,2,1,1,1,5,5,5,5,5,5,5,5,5,5,5,7,0,0,0,0,0,0],
                [0,0,0,7,7,5,5,5,5,5,5,5,5,5,5,5,5,5,1,1,1,2,2,2,2,2,2,1,1,1,5,5,5,5,5,5,5,5,5,5,5,7,7,0,0,0,0,0],
                [0,0,0,7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,1,1,1,1,1,1,1,1,1,1,1,1,5,5,5,5,5,5,5,5,5,5,5,5,7,0,0,0,0,0],
                [0,0,7,7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,1,1,1,1,1,1,1,1,1,1,1,1,5,5,5,5,5,5,5,5,5,5,5,5,7,7,0,0,0,0],
                [0,0,7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,1,1,1,1,1,1,1,1,1,1,1,1,5,5,5,5,5,5,5,5,5,5,5,5,5,7,0,0,0,0],
                [0,7,7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,1,1,1,1,1,1,1,1,1,1,1,1,5,5,5,5,5,5,5,5,5,5,5,5,5,7,7,0,0,0],
                [0,7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,1,1,1,1,1,1,1,1,1,1,1,1,5,5,5,5,5,5,5,5,5,5,5,5,5,5,7,0,0,0],
                [0,7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,3,3,1,1,1,1,1,1,1,1,1,1,3,3,5,5,5,5,5,5,5,5,5,5,5,5,5,7,0,0,0],
                [7,7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,3,3,1,1,1,1,1,1,1,1,1,1,3,3,5,5,5,5,5,5,5,5,5,5,5,5,5,7,7,0,0],
                [7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,3,3,1,1,1,1,1,1,1,1,1,1,3,3,5,5,5,5,5,5,5,5,5,5,5,5,5,5,7,0,0],
                [7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,3,3,1,1,1,1,1,1,1,1,1,1,3,3,5,5,5,5,5,5,5,5,5,5,5,5,5,5,7,0,0],
                [7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,4,4,4,4,4,4,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,7,0,0],
                [7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,4,4,4,4,4,4,4,4,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,7,0,0],
                [7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,4,4,4,6,6,6,6,4,4,4,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,7,0,0],
                [7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,4,4,6,6,6,6,6,6,4,4,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,7,0,0],
                [7,7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,4,6,6,6,6,6,6,6,6,4,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,7,7,0,0],
                [0,7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,6,6,6,6,6,6,6,6,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,7,0,0,0],
                [0,7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,6,6,6,6,6,6,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,7,0,0,0],
                [0,7,7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,6,6,6,6,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,7,7,0,0,0],
                [0,0,7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,6,6,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,7,0,0,0,0],
                [0,0,7,7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,7,7,0,0,0,0],
                [0,0,0,7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,7,0,0,0,0,0],
                [0,0,0,7,7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,7,7,0,0,0,0,0],
                [0,0,0,0,7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,7,0,0,0,0,0,0],
                [0,0,0,0,7,7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,7,7,0,0,0,0,0,0],
                [0,0,0,0,0,7,7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,7,7,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,7,7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,7,7,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,7,7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,7,7,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,7,7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,7,7,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,7,7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,7,7,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,7,7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,7,7,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,7,7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,7,7,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,7,7,7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,7,7,7,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,7,7,7,7,5,5,5,5,5,5,5,5,5,5,5,5,5,7,7,7,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
            ],
            // T-Rex Power-up (48x48 pixels) - Dino in circular bubble with green outline
            // 7 = green outline (good collectible)
            trexPowerUp: [
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,7,7,7,7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,7,7,7,7,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,7,7,7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,7,7,7,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,7,7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,7,7,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,7,7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,7,7,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,7,7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,7,7,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,7,7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,1,1,1,1,1,1,5,5,5,5,5,5,7,7,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,7,7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,1,1,1,1,1,1,1,1,5,5,5,5,5,5,7,7,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,1,1,1,1,1,1,1,1,1,1,5,5,5,5,5,5,7,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,7,7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,1,1,1,2,2,1,1,1,1,1,1,5,5,5,5,5,5,7,7,0,0,0,0,0,0,0],
                [0,0,0,0,0,7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,1,1,1,1,1,1,1,1,1,1,1,5,5,5,5,5,5,5,7,0,0,0,0,0,0,0],
                [0,0,0,0,7,7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,1,1,3,3,3,3,1,1,1,5,5,5,5,5,5,5,5,7,7,0,0,0,0,0,0],
                [0,0,0,0,7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,1,1,1,1,1,1,1,5,5,5,5,5,5,5,5,5,5,7,0,0,0,0,0,0],
                [0,0,0,7,7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,1,1,1,1,1,5,5,5,5,5,5,5,5,5,5,5,7,7,0,0,0,0,0],
                [0,0,0,7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,1,1,1,5,5,5,5,5,5,5,5,5,5,5,5,5,7,0,0,0,0,0],
                [0,0,7,7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,1,1,1,5,5,5,5,5,5,5,5,5,5,5,5,5,7,7,0,0,0,0],
                [0,0,7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,1,1,1,1,1,5,5,5,5,5,5,5,5,5,5,5,5,5,7,0,0,0,0],
                [0,7,7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,1,1,1,1,1,1,1,5,5,5,5,5,5,5,5,5,5,5,5,7,7,0,0,0],
                [0,7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,1,1,1,1,1,1,1,1,1,5,5,5,5,5,5,5,5,5,5,5,5,7,0,0,0],
                [0,7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,1,1,1,1,1,1,1,1,1,1,1,5,5,5,5,5,5,5,5,5,5,5,7,0,0,0],
                [7,7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,1,1,5,5,5,5,5,5,1,1,1,5,5,5,5,5,5,5,5,5,5,5,7,7,0,0],
                [7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,1,1,5,5,5,5,5,5,5,1,1,5,5,5,5,5,5,5,5,5,5,5,5,7,0,0],
                [7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,1,5,5,5,5,5,5,5,5,5,1,5,5,5,5,5,5,5,5,5,5,5,5,7,0,0],
                [7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,1,5,5,5,5,5,5,5,5,5,1,5,5,5,5,5,5,5,5,5,5,5,5,7,0,0],
                [7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,1,1,5,5,5,5,5,5,5,5,5,1,1,5,5,5,5,5,5,5,5,5,5,5,7,0,0],
                [7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,1,1,5,5,5,5,5,5,5,5,5,1,1,5,5,5,5,5,5,5,5,5,5,5,7,0,0],
                [7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,1,5,5,5,5,5,5,5,5,5,5,5,1,5,5,5,5,5,5,5,5,5,5,5,7,0,0],
                [7,7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,1,5,5,5,5,5,5,5,5,5,5,5,1,5,5,5,5,5,5,5,5,5,5,7,7,0,0],
                [0,7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,1,1,1,5,5,5,5,5,5,5,5,5,1,1,1,5,5,5,5,5,5,5,5,5,7,0,0,0],
                [0,7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,1,1,1,5,5,5,5,5,5,5,5,5,1,1,1,5,5,5,5,5,5,5,5,5,7,0,0,0],
                [0,7,7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,7,7,0,0,0],
                [0,0,7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,7,0,0,0,0],
                [0,0,7,7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,7,7,0,0,0,0],
                [0,0,0,7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,7,0,0,0,0,0],
                [0,0,0,7,7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,7,7,0,0,0,0,0],
                [0,0,0,0,7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,7,0,0,0,0,0,0],
                [0,0,0,0,7,7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,7,7,0,0,0,0,0,0],
                [0,0,0,0,0,7,7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,7,7,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,7,7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,7,7,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,7,7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,7,7,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,7,7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,7,7,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,7,7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,7,7,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,7,7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,7,7,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,7,7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,7,7,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,7,7,7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,7,7,7,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,7,7,7,7,5,5,5,5,5,5,5,5,5,5,5,5,5,7,7,7,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
            ],
            // T-Rex sprite (48x56 pixels) - Large Chrome dino style for player transformation
            trex: [
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,2,2,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,3,3,3,3,3,3,3,3,3,3,1,1,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0],
                [1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0],
                [1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0],
                [0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0],
                [0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0],
                [0,0,0,1,1,1,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0],
                [0,0,0,0,1,1,1,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,1,1,1,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
            ],
            // Snowman (20x36 pixels)
            snowman: [
                [0,0,0,0,0,0,0,0,5,5,5,5,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,5,5,5,5,5,5,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,5,5,5,5,5,5,5,5,0,0,0,0,0,0],
                [0,0,0,0,0,5,5,5,5,5,5,5,5,5,5,0,0,0,0,0],
                [0,0,0,0,5,5,5,5,5,5,5,5,5,5,5,5,0,0,0,0],
                [0,0,0,0,5,5,5,5,5,5,5,5,5,5,5,5,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,1,1,1,1,1,1,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,0,0],
                [0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0],
                [0,0,0,0,0,1,1,2,2,1,1,2,2,1,1,0,0,0,0,0],
                [0,0,0,0,1,1,1,2,2,1,1,2,2,1,1,1,0,0,0,0],
                [0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0],
                [0,0,0,0,1,1,1,1,3,1,1,3,1,1,1,1,0,0,0,0],
                [0,0,0,0,0,1,1,1,1,3,3,1,1,1,1,0,0,0,0,0],
                [0,0,0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,4,4,4,4,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,1,1,1,1,1,1,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,0,0],
                [0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0],
                [0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0],
                [0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0],
                [0,0,0,1,1,1,1,2,1,1,1,1,2,1,1,1,1,0,0,0],
                [0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0],
                [0,0,1,1,1,1,1,1,2,1,1,2,1,1,1,1,1,1,0,0],
                [0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0],
                [0,1,1,1,1,1,1,1,1,2,2,1,1,1,1,1,1,1,1,0],
                [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
                [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
                [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
                [0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0],
                [0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0],
                [0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0],
                [0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0],
                [0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0],
                [0,0,0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,0,0]
            ],
            // Cactus (20x36 pixels) - doubled detail
            cactus: [
                [0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,1,2,2,1,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,1,1,2,2,1,1,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,1,2,2,2,2,1,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,1,2,2,2,2,1,0,0,0,0,0,0,0],
                [0,0,1,1,0,0,0,1,2,2,2,2,1,0,0,0,1,1,0,0],
                [0,1,1,2,1,0,0,1,2,2,2,2,1,0,0,1,2,1,1,0],
                [0,1,2,2,1,0,1,1,2,2,2,2,1,1,0,1,2,2,1,0],
                [1,1,2,2,1,1,1,1,2,2,2,2,1,1,1,1,2,2,1,1],
                [1,2,2,2,2,1,1,1,2,2,2,2,1,1,1,2,2,2,2,1],
                [1,2,2,2,2,1,1,1,2,2,2,2,1,1,1,2,2,2,2,1],
                [1,2,2,2,2,1,1,1,2,2,2,2,1,1,1,2,2,2,2,1],
                [1,2,2,2,2,2,1,1,2,2,2,2,1,1,2,2,2,2,2,1],
                [0,1,2,2,2,2,1,1,2,2,2,2,1,1,2,2,2,2,1,0],
                [0,0,1,2,2,2,1,1,2,2,2,2,1,1,2,2,2,1,0,0],
                [0,0,0,1,1,1,1,1,2,2,2,2,1,1,1,1,1,0,0,0],
                [0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0],
                [0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0],
                [0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0],
                [0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0],
                [0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0],
                [0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0],
                [0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0],
                [0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0],
                [0,0,0,0,0,0,1,1,1,2,2,1,1,1,0,0,0,0,0,0],
                [0,0,0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,0,0],
                [0,0,0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,0,0]
            ],
            // Jungle palm tree (20x36 pixels) - compact version
            jungleTree: [
                [0,0,0,0,0,1,1,1,1,0,0,1,1,1,1,0,0,0,0,0],
                [0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0],
                [0,0,0,1,1,1,2,2,1,1,1,1,2,2,1,1,1,0,0,0],
                [0,0,1,1,2,2,2,2,2,1,1,2,2,2,2,2,1,1,0,0],
                [0,1,1,2,2,2,2,2,1,0,0,1,2,2,2,2,2,1,1,0],
                [1,1,2,2,2,2,2,1,0,0,0,0,1,2,2,2,2,2,1,1],
                [1,1,2,2,2,2,1,0,0,0,0,0,0,1,2,2,2,2,1,1],
                [0,1,1,1,1,1,0,0,0,0,0,0,0,0,1,1,1,1,1,0],
                [0,0,0,0,0,0,0,0,0,3,3,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,3,3,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,3,3,3,3,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,3,3,3,3,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,3,3,3,3,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,3,3,3,3,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,3,3,3,3,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,3,3,3,3,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,3,3,3,3,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,3,3,3,3,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,3,3,3,3,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,3,3,3,3,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,3,3,3,3,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,3,3,3,3,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,3,3,3,3,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,3,3,3,3,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,3,4,4,3,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,3,4,4,3,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,3,3,4,4,3,3,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,3,3,4,4,3,3,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,3,3,3,4,4,3,3,3,0,0,0,0,0,0],
                [0,0,0,0,0,0,3,3,3,4,4,3,3,3,0,0,0,0,0,0],
                [0,0,0,0,0,3,3,3,3,4,4,3,3,3,3,0,0,0,0,0],
                [0,0,0,0,0,3,3,3,3,4,4,3,3,3,3,0,0,0,0,0],
                [0,0,0,0,3,3,3,3,3,4,4,3,3,3,3,3,0,0,0,0],
                [0,0,0,0,3,3,3,3,3,4,4,3,3,3,3,3,0,0,0,0],
                [0,0,0,3,3,3,3,3,3,4,4,3,3,3,3,3,3,0,0,0],
                [0,0,0,3,3,3,3,3,3,3,3,3,3,3,3,3,3,0,0,0]
            ],
            // Ship anchor - classic nautical design (20x36 pixels)
            anchor: [
                [0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,1,1,3,3,1,1,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,1,3,0,0,3,1,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,1,1,3,3,1,1,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0],
                [0,0,0,1,1,1,1,1,1,2,2,1,1,1,1,1,1,0,0,0],
                [0,0,1,1,3,3,3,3,1,2,2,1,3,3,3,3,1,1,0,0],
                [0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,1,1,1,1,1,1,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,1,1,2,1,1,2,1,1,0,0,0,0,0,0],
                [0,0,0,0,0,1,1,2,2,1,1,2,2,1,1,0,0,0,0,0],
                [0,0,0,0,1,1,2,2,0,0,0,0,2,2,1,1,0,0,0,0],
                [0,0,0,1,1,2,2,0,0,0,0,0,0,2,2,1,1,0,0,0],
                [0,0,1,1,2,2,0,0,0,0,0,0,0,0,2,2,1,1,0,0],
                [0,1,1,2,2,0,0,0,0,0,0,0,0,0,0,2,2,1,1,0],
                [1,1,2,2,4,0,0,0,0,0,0,0,0,0,0,4,2,2,1,1],
                [1,2,2,4,4,0,0,0,0,0,0,0,0,0,0,4,4,2,2,1],
                [1,2,4,4,0,0,0,0,0,0,0,0,0,0,0,0,4,4,2,1],
                [1,2,4,4,0,0,0,0,0,0,0,0,0,0,0,0,4,4,2,1],
                [1,1,2,4,4,0,0,0,0,0,0,0,0,0,0,4,4,2,1,1],
                [0,1,2,2,4,4,0,0,0,0,0,0,0,0,4,4,2,2,1,0],
                [0,1,1,2,2,4,4,0,0,0,0,0,0,4,4,2,2,1,1,0],
                [0,0,1,1,2,2,4,4,4,0,0,4,4,4,2,2,1,1,0,0],
                [0,0,0,1,1,2,2,4,4,4,4,4,4,2,2,1,1,0,0,0],
                [0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0]
            ],
            // ====== ANIMAL OBSTACLES (5000+ points) ======
            // Crab - wide sideways crab with claws (40x36 pixels)
            crab: [
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0],
                [0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0],
                [0,0,1,1,2,2,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,2,2,1,1,0,0],
                [0,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,0],
                [0,1,2,2,2,2,2,2,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,2,2,2,2,2,2,1,0],
                [0,1,2,2,2,2,2,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,2,2,2,2,2,1,0],
                [0,0,1,2,2,2,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,2,2,2,1,0,0],
                [0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,2,2,2,2,2,2,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,2,2,2,2,2,2,2,2,2,2,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,1,1,2,2,2,3,3,2,2,3,3,2,2,2,1,1,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,1,1,2,2,2,2,3,3,2,2,3,3,2,2,2,2,1,1,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,4,4,0,0,0,0,4,4,0,0,0,0,4,4,0,0,0,0,4,4,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,4,4,0,0,0,0,4,4,0,0,0,0,0,0,4,4,0,0,0,0,4,4,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,4,4,0,0,0,0,4,4,0,0,0,0,0,0,0,0,4,4,0,0,0,0,4,4,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,4,4,0,0,0,0,4,4,0,0,0,0,0,0,0,0,0,0,4,4,0,0,0,0,4,4,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,4,4,0,0,0,0,4,4,0,0,0,0,0,0,0,0,0,0,0,0,4,4,0,0,0,0,4,4,0,0,0,0,0,0],
                [0,0,0,0,0,4,4,0,0,0,0,4,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,4,0,0,0,0,4,4,0,0,0,0,0],
                [0,0,0,0,4,4,0,0,0,0,4,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,4,0,0,0,0,4,4,0,0,0,0],
                [0,0,0,0,4,0,0,0,0,0,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,0,0,0,0,0,4,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
            ],
            // Monkey - swinging monkey with tail (40x36 pixels)
            monkey: [
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,2,2,2,2,2,2,2,2,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,2,2,2,2,2,2,2,2,2,2,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,1,1,2,2,3,3,2,2,2,2,3,3,2,2,1,1,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,1,2,2,2,4,4,2,2,2,2,4,4,2,2,2,1,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,1,1,2,3,3,3,3,3,3,3,3,3,3,3,3,2,1,1,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,1,2,2,3,3,3,3,3,3,3,3,3,3,3,3,2,2,1,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,1,2,2,2,3,3,3,5,5,5,5,3,3,3,2,2,2,1,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,1,2,2,2,3,3,3,3,3,3,3,3,2,2,2,1,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,2,2,2,2,2,2,2,2,2,2,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,0,0,1,1,1,1,1,1,0,0,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,1,2,2,2,2,1,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,1,1,2,2,2,2,2,2,1,0,1,2,2,2,2,1,0,1,2,2,2,2,2,2,1,1,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,1,2,2,2,2,2,2,2,1,0,1,2,2,2,2,1,0,1,2,2,2,2,2,2,2,1,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,1,2,2,2,2,2,2,2,1,0,1,2,2,2,2,1,0,1,2,2,2,2,2,2,2,1,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,1,2,2,2,2,2,2,1,0,0,1,2,2,2,2,1,0,0,1,2,2,2,2,2,2,1,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,1,2,2,2,2,1,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,1,1,2,2,1,1,0,0,0,1,2,2,2,2,1,0,0,0,1,1,2,2,1,1,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,1,2,2,2,2,1,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,2,2,1,1,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,2,2,1,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,2,2,1,0,0,0,0,0,0,0,0,0,0,1,1,2,1,1,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,2,2,1,0,0,0,0,0,0,0,0,0,1,1,2,2,2,1,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,2,1,1,0,0,0,0,0,0,0,0,1,1,2,2,2,1,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,2,2,2,1,1,0,0,0,0,0,0,1,1,2,2,2,1,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,2,2,2,2,2,1,1,0,0,0,0,1,1,2,2,1,1,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,2,2,6,6,2,2,2,1,0,0,0,1,1,2,1,1,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,2,6,6,6,6,2,2,1,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,6,6,6,6,1,1,1,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,6,6,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
            ],
            // Scorpion - desert scorpion with raised tail (40x36 pixels)
            scorpion: [
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,2,2,1,1,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,2,3,3,2,1,1,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,2,3,3,3,1,1,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,2,2,3,3,1,1,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0,0],
                [0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0,0,0],
                [0,0,1,1,2,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0,0,0,0],
                [0,1,1,2,2,2,1,1,0,0,0,0,0,0,0,0,1,1,1,1,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,1,2,2,2,2,2,1,0,0,0,0,0,0,1,1,1,2,2,2,2,2,2,2,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,1,2,2,2,2,1,0,0,0,0,0,1,1,2,2,2,2,2,2,2,2,2,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,1,2,2,1,0,0,0,0,1,1,2,2,2,2,4,4,2,2,4,4,2,2,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,1,1,0,0,0,0,1,1,2,2,2,2,2,4,4,2,2,4,4,2,2,2,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,5,5,0,0,5,5,0,0,0,0,0,0,0,0,5,5,0,0,5,5,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,5,5,0,0,5,5,0,0,0,0,0,0,0,0,0,0,5,5,0,0,5,5,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,5,5,0,0,5,5,0,0,0,0,0,0,0,0,0,0,0,0,5,5,0,0,5,5,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,5,5,0,0,5,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,5,0,0,5,5,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,5,5,0,0,5,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,5,0,0,5,5,0,0,0,0,0,0,0,0],
                [0,0,0,5,5,0,0,5,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,5,0,0,5,5,0,0,0,0,0,0,0],
                [0,0,5,5,0,0,5,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,5,0,0,5,5,0,0,0,0,0,0],
                [0,0,5,0,0,0,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,0,0,0,5,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
            ],
            // Penguin - arctic penguin (40x36 pixels)
            penguin: [
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,2,2,1,1,1,1,2,2,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,2,2,1,1,1,1,2,2,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,3,3,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,3,3,3,3,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,4,4,4,4,4,4,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,4,4,4,4,4,4,4,4,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,4,4,4,4,4,4,4,4,4,4,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,4,4,4,4,4,4,4,4,4,4,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,1,1,1,4,4,4,4,4,4,4,4,4,4,4,4,1,1,1,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,1,1,1,4,4,4,4,4,4,4,4,4,4,4,4,1,1,1,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,1,1,1,1,4,4,4,4,4,4,4,4,4,4,4,4,1,1,1,1,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,1,1,1,1,4,4,4,4,4,4,4,4,4,4,4,4,1,1,1,1,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,1,1,1,1,4,4,4,4,4,4,4,4,4,4,4,4,1,1,1,1,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,1,1,1,1,4,4,4,4,4,4,4,4,4,4,4,4,1,1,1,1,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,4,4,4,4,4,4,4,4,4,4,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,4,4,4,4,4,4,4,4,4,4,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,4,4,4,4,4,4,4,4,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,4,4,4,4,4,4,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,3,3,3,3,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,3,3,3,3,3,3,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,3,3,3,0,0,3,3,3,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,3,3,3,0,0,0,0,3,3,3,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,3,3,0,0,0,0,0,0,3,3,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,3,3,0,0,0,0,0,0,3,3,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,3,3,0,0,0,0,0,0,3,3,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
            ],
            // ====== TRANSFORMATIVE SKIN SPRITES ======
            // Banana Suit - full banana costume (32x48)
            bananaSuit: [
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,3,3,3,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,3,3,3,3,3,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,2,2,1,1,1,1,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,2,1,1,1,1,1,1,1,1,2,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,2,1,1,1,1,1,1,1,1,1,1,2,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,2,1,1,1,1,1,1,1,1,1,1,1,1,2,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,2,1,1,1,4,4,4,4,4,4,1,1,1,2,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,2,1,1,4,4,4,4,4,4,4,4,1,1,2,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,2,1,1,4,4,5,5,5,5,4,4,1,1,2,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,2,1,1,4,4,5,5,5,5,4,4,1,1,2,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,2,1,1,4,4,4,6,6,4,4,4,1,1,2,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,2,1,1,1,4,4,4,4,4,4,1,1,1,2,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,2,1,1,1,1,1,1,1,1,1,1,1,1,2,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,2,2,1,1,1,1,1,1,1,1,1,1,1,1,2,2,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,2,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,2,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,0,0,0,0,0,0,0],
                [0,0,0,0,0,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,0,0,0,0,0,0,0],
                [0,0,0,0,0,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,0,0,0,0,0,0,0],
                [0,0,0,0,0,2,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,2,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,2,2,1,1,1,1,1,1,1,1,1,1,1,1,2,2,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,2,1,1,1,1,1,1,1,1,1,1,1,1,2,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,2,2,1,1,1,1,1,1,1,1,1,1,2,2,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,2,1,1,1,1,1,1,1,1,1,1,2,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,2,2,1,1,1,1,1,1,1,1,2,2,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,2,1,1,1,1,1,1,1,1,2,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,2,2,1,1,0,0,1,1,2,2,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,2,1,1,0,0,1,1,2,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,7,7,7,0,0,7,7,7,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,7,7,7,0,0,7,7,7,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,7,7,7,7,0,0,7,7,7,7,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,7,7,7,7,0,0,7,7,7,7,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,7,7,7,7,0,0,7,7,7,7,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,7,7,7,0,0,0,0,7,7,7,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,7,7,7,0,0,0,0,7,7,7,0,0,0,0,0,0,0,0,0,0,0,0]
            ],
            // Ninja - black outfit with red headband (32x48)
            ninjaSprite: [
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,5,5,5,5,5,5,5,5,5,5,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,5,5,6,5,5,5,5,5,5,6,5,5,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,1,1,1,3,3,1,1,1,1,3,3,1,1,1,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,1,1,1,3,4,1,1,1,1,4,3,1,1,1,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,1,1,1,3,3,1,1,1,1,3,3,1,1,1,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,7,7,7,7,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0],
                [0,0,0,0,0,2,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,0,0,0,0,0,0,0],
                [0,0,0,0,2,2,2,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,0,0,0,0,0,0],
                [0,0,0,0,2,2,2,0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,2,2,2,0,0,0,0,0,0],
                [0,0,0,0,2,2,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,2,2,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,7,7,7,7,0,0,0,0,0,0,0,0,0,0,7,7,7,7,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,7,7,7,7,0,0,0,0,0,0,0,0,0,0,7,7,7,7,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,7,7,7,7,0,0,0,0,0,0,0,0,0,0,7,7,7,7,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,7,7,7,7,0,0,0,0,0,0,0,0,0,0,7,7,7,7,0,0,0,0,0,0,0]
            ],
            // Pirate - brown coat, red bandana, eyepatch (32x48)
            pirateSprite: [
                [0,0,0,0,0,0,0,0,0,0,0,5,5,5,5,5,5,5,5,5,5,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,5,5,5,5,5,5,5,5,5,5,5,5,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,5,5,5,5,5,5,5,5,5,5,5,5,5,5,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,5,6,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,3,3,3,3,3,3,3,3,3,3,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,3,3,3,3,3,3,3,3,3,3,3,3,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,3,3,4,4,3,3,3,3,3,3,3,3,3,3,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,3,3,4,4,3,3,3,3,4,4,4,4,3,3,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,3,3,3,3,3,3,3,3,3,3,3,3,3,3,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,3,3,3,3,8,8,8,8,3,3,3,3,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,3,3,3,3,3,3,3,3,3,3,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,3,3,3,3,3,3,3,3,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,8,8,8,8,8,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,1,1,2,2,2,2,2,1,1,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,1,1,1,2,2,2,2,2,1,1,1,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,2,1,1,1,1,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,1,1,1,1,1,2,2,2,2,2,1,1,1,1,1,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,1,1,1,1,1,1,2,2,2,2,2,1,1,1,1,1,1,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,1,1,1,1,1,1,1,2,2,2,2,2,1,1,1,1,1,1,1,0,0,0,0,0,0,0],
                [0,0,0,0,0,3,3,1,1,1,1,1,1,2,2,2,2,2,1,1,1,1,1,1,3,3,0,0,0,0,0,0],
                [0,0,0,0,3,3,3,3,1,1,1,1,8,8,8,8,8,8,1,1,1,1,3,3,3,3,0,0,0,0,0,0],
                [0,0,0,0,3,3,3,0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,3,3,3,0,0,0,0,0,0],
                [0,0,0,0,3,3,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,3,3,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,7,7,7,7,0,0,7,7,7,7,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,7,7,7,7,0,0,7,7,7,7,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,7,7,7,7,7,0,0,7,7,7,7,7,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,7,7,7,7,0,0,0,0,7,7,7,7,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,7,7,7,7,7,0,0,0,0,7,7,7,7,7,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,7,7,7,7,0,0,0,0,0,0,7,7,7,7,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,7,7,7,7,7,0,0,0,0,0,0,7,7,7,7,7,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,7,7,7,7,0,0,0,0,0,0,0,0,7,7,7,7,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,7,7,7,7,7,0,0,0,0,0,0,0,0,7,7,7,7,7,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,7,7,7,7,0,0,0,0,0,0,0,0,0,0,7,7,7,7,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,7,7,7,7,7,0,0,0,0,0,0,0,0,7,7,7,7,7,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,7,7,7,7,7,0,0,0,0,0,0,0,0,7,7,7,7,7,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,7,7,7,7,7,0,0,0,0,0,0,0,0,7,7,7,7,7,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,7,7,7,7,7,0,0,0,0,0,0,0,0,7,7,7,7,7,0,0,0,0,0,0,0]
            ],
            // Astronaut - white suit, blue visor (32x48)
            astronautSprite: [
                [0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,1,1,1,5,5,5,5,5,5,5,5,5,5,1,1,1,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,1,1,5,5,5,5,5,5,5,5,5,5,5,5,1,1,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,1,1,5,5,3,3,3,3,3,3,3,3,5,5,1,1,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,1,1,5,3,3,3,3,3,3,3,3,3,3,5,1,1,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,1,1,5,3,3,3,3,3,3,3,3,3,3,5,1,1,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,1,1,5,3,3,3,3,3,3,3,3,3,3,5,1,1,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,1,1,5,5,3,3,3,3,3,3,3,3,5,5,1,1,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,1,1,5,5,5,5,5,5,5,5,5,5,5,5,1,1,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,1,1,5,5,5,5,5,5,5,5,5,5,1,1,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,1,4,4,1,1,1,1,4,4,1,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0],
                [0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0],
                [0,0,0,0,0,2,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,0,0,0,0,0,0],
                [0,0,0,0,2,2,2,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,0,0,0,0,0,0],
                [0,0,0,0,2,2,2,0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,2,2,2,0,0,0,0,0,0],
                [0,0,0,0,2,2,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,2,2,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,7,7,7,7,0,0,0,0,0,0,0,0,0,0,7,7,7,7,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,7,7,7,7,0,0,0,0,0,0,0,0,0,0,7,7,7,7,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,7,7,7,7,0,0,0,0,0,0,0,0,0,0,7,7,7,7,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,7,7,7,7,0,0,0,0,0,0,0,0,0,0,7,7,7,7,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,7,7,7,7,0,0,0,0,0,0,0,0,0,0,7,7,7,7,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,7,7,7,7,0,0,0,0,0,0,0,0,0,0,7,7,7,7,0,0,0,0,0,0,0]
            ],
            // Robot - metallic body with antenna (32x48)
            robotSprite: [
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,7,7,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,6,6,6,6,6,6,6,6,6,6,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,6,1,1,1,1,1,1,1,1,1,1,6,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,6,1,1,1,1,1,1,1,1,1,1,1,1,6,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,6,1,4,4,4,4,1,1,4,4,4,4,1,6,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,6,1,4,4,4,4,1,1,4,4,4,4,1,6,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,6,1,1,1,1,1,1,1,1,1,1,1,1,6,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,6,1,1,1,3,3,3,3,3,3,1,1,1,6,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,6,1,1,1,1,1,1,1,1,1,1,6,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,6,6,6,6,6,6,6,6,6,6,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,7,7,7,7,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,6,6,1,1,1,1,1,6,6,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,6,1,1,1,1,1,1,1,1,1,6,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,6,1,1,1,1,1,1,1,1,1,1,1,6,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,6,1,1,1,4,4,4,4,4,4,1,1,1,1,6,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,6,1,1,1,1,4,4,4,4,4,4,1,1,1,1,1,6,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,6,1,1,1,1,1,4,4,4,4,4,4,1,1,1,1,1,1,6,0,0,0,0,0,0,0],
                [0,0,0,0,0,6,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,6,0,0,0,0,0,0],
                [0,0,0,0,0,3,3,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,3,3,0,0,0,0,0,0],
                [0,0,0,0,3,3,3,3,1,1,1,1,1,1,1,1,1,1,1,1,1,1,3,3,3,3,0,0,0,0,0,0],
                [0,0,0,0,3,3,3,0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,3,3,3,0,0,0,0,0,0],
                [0,0,0,0,3,3,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,3,3,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,6,6,6,6,6,0,0,0,0,0,0,0,0,6,6,6,6,6,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,6,6,6,6,6,0,0,0,0,0,0,0,0,6,6,6,6,6,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,6,6,6,6,6,0,0,0,0,0,0,0,0,6,6,6,6,6,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,6,6,6,6,6,0,0,0,0,0,0,0,0,6,6,6,6,6,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,6,6,6,6,6,0,0,0,0,0,0,0,0,6,6,6,6,6,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,6,6,6,6,6,0,0,0,0,0,0,0,0,6,6,6,6,6,0,0,0,0,0,0,0]
            ]
        };

        // Colors for each sprite
        const colors = {
            // Snow outfit - winter gear
            runnerSnow: {
                1: '#8B5A2B',  // Hair
                2: '#DEB887',  // Skin
                3: '#000000',  // Eyes
                4: '#E53935',  // Red winter jacket/hat
                5: '#1A237E',  // Navy pants
                6: '#5D4037',  // Brown snow boots
                7: '#FFFFFF',  // Pom-pom
                8: '#CD5C5C'   // Mouth/smile
            },
            // Desert outfit - cowboy
            runnerDesert: {
                1: '#8B5A2B',  // Hair
                2: '#DEB887',  // Skin
                3: '#000000',  // Eyes
                4: '#8D6E63',  // Brown cowboy hat
                5: '#F5DEB3',  // Tan shirt
                6: '#5D4037',  // Brown vest
                7: '#1565C0',  // Blue jeans
                8: '#CD5C5C',  // Mouth/smile
                9: '#4E342E'   // Cowboy boots
            },
            // Jungle outfit - Tarzan
            runnerJungle: {
                1: '#5D4037',  // Dark hair
                2: '#C8A27A',  // Tanned skin
                3: '#000000',  // Eyes
                4: '#6D4C41'   // Brown loincloth
            },
            // Ocean outfit - scuba
            runnerOcean: {
                1: '#8B5A2B',  // Hair (hidden)
                2: '#DEB887',  // Skin (hidden)
                3: '#000000',  // Eyes
                4: '#FFB300',  // Yellow helmet
                5: '#81D4FA',  // Light blue visor
                6: '#212121',  // Black wetsuit
                7: '#000000'   // Black flippers
            },
            banana: {
                1: '#FFE135',  // Bright yellow
                2: '#FFC107',  // Darker yellow edge
                3: '#4E3524',  // Brown stem
                4: '#3E2723'   // Dark brown tip
            },
            // Power-up colors
            jetpack: {
                1: '#E0E0E0',  // Silver rocket body
                2: '#42A5F5',  // Blue window/cockpit
                3: '#B71C1C',  // Red fins
                4: '#FF5722',  // Orange flame
                5: '#B3E5FC',  // Light blue bubble
                6: '#FFEB3B',  // Yellow flame core
                7: '#2E7D32'   // Green outline (good collectible)
            },
            trexPowerUp: {
                1: '#546E7A',  // Gray dino body
                2: '#37474F',  // Dark gray shadow/eye
                3: '#FFFFFF',  // White teeth
                5: '#B3E5FC',  // Light blue bubble
                7: '#2E7D32'   // Green outline (good collectible)
            },
            trex: {
                1: '#546E7A',  // Gray dino body
                2: '#37474F',  // Dark gray eye
                3: '#FFFFFF'   // White teeth
            },
            // Transformative skin sprites and colors
            bananaSuit: {
                1: '#FFD700',  // Bright yellow peel
                2: '#DAA520',  // Dark yellow edge
                3: '#8B4513',  // Brown stem
                4: '#DEB887',  // Skin tone (face)
                5: '#000000',  // Eyes
                6: '#CD5C5C',  // Mouth
                7: '#5D4037',  // Shoes
                8: '#FFC107'   // Mid yellow
            },
            ninjaSprite: {
                1: '#1a1a1a',  // Black ninja outfit
                2: '#2d2d2d',  // Dark gray details
                3: '#DEB887',  // Skin (eyes only)
                4: '#000000',  // Eyes
                5: '#C62828',  // Red headband
                6: '#8B0000',  // Dark red
                7: '#4a4a4a'   // Belt/shoes
            },
            pirateSprite: {
                1: '#5D4037',  // Brown coat
                2: '#F5F5F5',  // White shirt
                3: '#DEB887',  // Skin
                4: '#000000',  // Eyes/eyepatch
                5: '#C62828',  // Red bandana
                6: '#FFD700',  // Gold details
                7: '#1a1a1a',  // Black boots
                8: '#8B4513'   // Brown belt
            },
            astronautSprite: {
                1: '#ECEFF1',  // White suit
                2: '#B0BEC5',  // Gray details
                3: '#1E88E5',  // Blue visor
                4: '#FF5722',  // Orange NASA logo
                5: '#37474F',  // Dark helmet frame
                6: '#DEB887',  // Skin (behind visor)
                7: '#455A64'   // Gray boots
            },
            robotSprite: {
                1: '#607D8B',  // Blue-gray metal body
                2: '#455A64',  // Dark metal
                3: '#B0BEC5',  // Light metal
                4: '#00BCD4',  // Cyan lights/visor
                5: '#FF5252',  // Red antenna light
                6: '#37474F',  // Dark details
                7: '#78909C'   // Mid gray
            },
            snowman: {
                1: '#FFFFFF',  // White snow body
                2: '#212121',  // Black eyes/buttons
                3: '#FF5722',  // Orange carrot nose
                4: '#E53935',  // Red scarf
                5: '#212121'   // Black top hat
            },
            cactus: {
                1: '#2E7D32',  // Dark green
                2: '#4CAF50'   // Light green
            },
            jungleTree: {
                1: '#2E7D32',  // Dark green leaves
                2: '#4CAF50',  // Light green leaves
                3: '#5D4037',  // Brown trunk
                4: '#8D6E63'   // Light brown trunk detail
            },
            anchor: {
                1: '#546E7A',  // Gunmetal gray body
                2: '#37474F',  // Dark gray shadow
                3: '#78909C',  // Light gray highlight
                4: '#8D6E63'   // Rust accent on flukes
            },
            // Animal obstacle colors (5000+ points)
            crab: {
                1: '#B71C1C',  // Dark red shell edge
                2: '#E53935',  // Red shell body
                3: '#000000',  // Black eyes
                4: '#FF8A65'   // Orange legs
            },
            monkey: {
                1: '#5D4037',  // Dark brown outline
                2: '#8D6E63',  // Brown fur
                3: '#FFCCBC',  // Light skin/face
                4: '#000000',  // Black eyes
                5: '#E91E63',  // Pink mouth/tongue
                6: '#6D4C41'   // Darker brown feet
            },
            scorpion: {
                1: '#1B5E20',  // Dark green outline
                2: '#388E3C',  // Green body
                3: '#FF5722',  // Orange stinger
                4: '#000000',  // Black eyes
                5: '#2E7D32'   // Dark green legs
            },
            penguin: {
                1: '#212121',  // Black feathers
                2: '#FFFFFF',  // White eyes
                3: '#FF9800',  // Orange beak/feet
                4: '#FAFAFA'   // White belly
            }
        };

        // Land configurations with muted backgrounds for better sprite visibility
        const lands = {
            snow: {
                name: 'Snow',
                skyTop: '#A8C5D9',     // Muted steel blue
                skyBottom: '#C9D9E5',  // Muted light gray-blue
                ground: '#ECEFF1',
                groundAccent: '#FFFFFF',
                obstacle: sprites.snowman,
                obstacleColors: colors.snowman,
                animalObstacle: sprites.penguin,      // Animal at 5000+ points
                animalObstacleColors: colors.penguin,
                runner: sprites.runnerSnow,
                runnerColors: colors.runnerSnow,
                floatingTextColor: '#1A237E'  // Dark indigo - contrasts with light blue sky
            },
            desert: {
                name: 'Desert',
                skyTop: '#D4C4A0',     // Muted tan
                skyBottom: '#E8DCC8',  // Muted cream
                ground: '#E6C47A',
                groundAccent: '#F5DEB3',
                obstacle: sprites.cactus,
                obstacleColors: colors.cactus,
                animalObstacle: sprites.scorpion,     // Animal at 5000+ points
                animalObstacleColors: colors.scorpion,
                runner: sprites.runnerDesert,
                runnerColors: colors.runnerDesert,
                floatingTextColor: '#4A148C'  // Deep purple - contrasts with tan/cream sky
            },
            jungle: {
                name: 'Jungle',
                skyTop: '#5A8A5F',     // Muted forest green
                skyBottom: '#7BA67F',  // Muted sage green
                ground: '#6D4C41',
                groundAccent: '#4CAF50',
                obstacle: sprites.jungleTree,
                obstacleColors: colors.jungleTree,
                animalObstacle: sprites.monkey,       // Animal at 5000+ points
                animalObstacleColors: colors.monkey,
                runner: sprites.runnerJungle,
                runnerColors: colors.runnerJungle,
                floatingTextColor: '#FFD600'  // Bright yellow - contrasts with green sky
            },
            ocean: {
                name: 'Ocean',
                skyTop: '#2A6A8A',     // Muted deep teal
                skyBottom: '#5A9AB0',  // Muted ocean blue
                ground: '#1565C0',
                groundAccent: '#42A5F5',
                obstacle: sprites.anchor,
                obstacleColors: colors.anchor,
                animalObstacle: sprites.crab,         // Animal at 5000+ points
                animalObstacleColors: colors.crab,
                runner: sprites.runnerOcean,
                runnerColors: colors.runnerOcean,
                floatingTextColor: '#FFAB00'  // Bright amber - contrasts with dark blue sky
            }
        };

        let selectedLand = 'snow';

        // Calculate dimensions from sprites
        const PLAYER_WIDTH = sprites.runnerSnow[0].length * PLAYER_SCALE;
        const PLAYER_HEIGHT = sprites.runnerSnow.length * PLAYER_SCALE;

        // Draw sprite function
        function drawSprite(ctx, x, y, pixels, scale, colorMap) {
            for (let row = 0; row < pixels.length; row++) {
                for (let col = 0; col < pixels[row].length; col++) {
                    const colorId = pixels[row][col];
                    if (colorId) {
                        ctx.fillStyle = colorMap[colorId];
                        ctx.fillRect(
                            x + col * scale,
                            y + row * scale,
                            scale,
                            scale
                        );
                    }
                }
            }
        }

        // Draw sprite with colored outline for accessibility
        function drawSpriteWithOutline(ctx, x, y, pixels, scale, colorMap, outlineColor, outlineWidth = 1) {
            const ow = outlineWidth * scale;

            // Draw outline by rendering slightly larger rects first
            ctx.fillStyle = outlineColor;
            for (let row = 0; row < pixels.length; row++) {
                for (let col = 0; col < pixels[row].length; col++) {
                    if (pixels[row][col]) {
                        ctx.fillRect(
                            x + col * scale - ow,
                            y + row * scale - ow,
                            scale + ow * 2,
                            scale + ow * 2
                        );
                    }
                }
            }

            // Draw sprite on top
            drawSprite(ctx, x, y, pixels, scale, colorMap);
        }

        // Draw player sprite with outline - handles transformative skins
        function drawSpriteWithOutlinePlayer(ctx, x, y, pixels, scale, colorMap, outlineColor, outlineWidth, skin) {
            // Check for transformative skin with custom sprite
            if (skin?.transformative && skin?.customSprite) {
                const customPixels = sprites[skin.customSprite];
                const customColors = colors[skin.customSprite];
                if (customPixels && customColors) {
                    drawSpriteWithOutline(ctx, x, y, customPixels, scale, customColors, outlineColor, outlineWidth);
                    return;
                }
            }
            // Recolor skin: draw with land sprite and skin colors
            drawSpriteWithOutline(ctx, x, y, pixels, scale, colorMap, outlineColor, outlineWidth);
        }

        // Draw sprite - handles transformative skins (use custom sprite) vs recolor skins (use land sprite)
        function drawSpriteWithOverlay(ctx, x, y, pixels, scale, colorMap, skin) {
            // Check if this is a transformative skin with its own sprite
            if (skin?.transformative && skin?.customSprite) {
                const customPixels = sprites[skin.customSprite];
                const customColors = colors[skin.customSprite];
                if (customPixels && customColors) {
                    // Use the custom sprite and colors instead of land-based sprite
                    drawSprite(ctx, x, y, customPixels, scale, customColors);
                    return;
                }
            }

            // Recolor skin: Draw base sprite with skin colors
            drawSprite(ctx, x, y, pixels, scale, colorMap);
        }

        // Merge skin color overrides with land colors for visual customization
        function getSkinColors(landColors, skinId) {
            const skin = SKINS[skinId];
            if (!skin?.colorOverrides || Object.keys(skin.colorOverrides).length === 0) {
                return landColors; // No overrides, use land defaults
            }
            // Create merged color map
            let merged = { ...landColors, ...skin.colorOverrides };

            // Rainbow animation - cycle through hues
            if (skin.animated && skinId === 'rainbow') {
                const hue = (gameTime * 3) % 360;
                merged[4] = `hsl(${hue}, 100%, 50%)`;
                merged[5] = `hsl(${(hue + 120) % 360}, 100%, 50%)`;
                merged[6] = `hsl(${(hue + 240) % 360}, 100%, 50%)`;
            }

            return merged;
        }

        // ============================================
        // PARTICLE SYSTEM
        // ============================================
        let particles = [];

        function spawnParticle(config) {
            particles.push({
                x: config.x,
                y: config.y,
                vx: config.vx || 0,
                vy: config.vy || 0,
                color: config.color,
                size: config.size || 3,
                life: 0,
                maxLife: config.maxLife || 30,
                gravity: config.gravity || 0
            });
        }

        function updateParticles() {
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.x += p.vx;
                p.y += p.vy;
                p.vy += p.gravity;
                p.life++;
                if (p.life >= p.maxLife) {
                    particles.splice(i, 1);
                }
            }
        }

        function drawParticles() {
            particles.forEach(p => {
                const alpha = 1 - (p.life / p.maxLife);
                ctx.globalAlpha = alpha;
                ctx.fillStyle = p.color;
                ctx.fillRect(p.x, p.y, p.size, p.size);
            });
            ctx.globalAlpha = 1;
        }

        function updateSkinEffects() {
            if (gameState !== 'playing' || !player) return;

            const skin = SKINS[selectedSkin];
            if (!skin?.effect) return;

            // Only spawn every few frames to avoid too many particles
            if (gameTime % 3 !== 0) return;

            switch (skin.effect) {
                case 'fire':
                    spawnParticle({
                        x: player.x + Math.random() * 20,
                        y: player.y + PLAYER_HEIGHT - 10,
                        vx: -2 - Math.random() * 2,
                        vy: -Math.random() * 2,
                        color: ['#FF4500', '#FF6347', '#FFA500'][Math.floor(Math.random() * 3)],
                        size: 4 + Math.random() * 4,
                        maxLife: 20 + Math.random() * 15
                    });
                    break;
                case 'ice':
                    spawnParticle({
                        x: player.x + Math.random() * 20,
                        y: player.y + PLAYER_HEIGHT - 5,
                        vx: -1 - Math.random(),
                        vy: -0.5 + Math.random(),
                        color: ['#87CEEB', '#ADD8E6', '#E0FFFF'][Math.floor(Math.random() * 3)],
                        size: 2 + Math.random() * 3,
                        maxLife: 25
                    });
                    break;
                case 'shadow':
                    spawnParticle({
                        x: player.x + Math.random() * 20,
                        y: player.y + Math.random() * PLAYER_HEIGHT,
                        vx: -1,
                        vy: 0,
                        color: 'rgba(0,0,0,0.5)',
                        size: 5 + Math.random() * 5,
                        maxLife: 15
                    });
                    break;
                case 'sparkle':
                    if (Math.random() < 0.3) { // Less frequent
                        spawnParticle({
                            x: player.x + Math.random() * 30,
                            y: player.y + Math.random() * 40,
                            vx: -1,
                            vy: -0.5,
                            color: ['#FFFFFF', '#B9F2FF', '#E0FFFF'][Math.floor(Math.random() * 3)],
                            size: 2 + Math.random() * 2,
                            maxLife: 20
                        });
                    }
                    break;
            }
        }

        function clearParticles() {
            particles = [];
        }

        // Jetpack thrust particles
        function spawnJetpackParticles(x, y) {
            // Fire core particles (bright, fast, inner)
            for (let i = 0; i < 4; i++) {
                particles.push({
                    x: x + (Math.random() - 0.5) * 8,
                    y: y,
                    vx: (Math.random() - 0.5) * 1.5,
                    vy: 4 + Math.random() * 3,
                    life: 0,
                    color: ['#FFEB3B', '#FFF176', '#FFFFFF'][Math.floor(Math.random() * 3)], // Yellow/white core
                    size: 4 + Math.random() * 4,
                    maxLife: 12
                });
            }
            // Fire outer particles (orange/red, medium)
            for (let i = 0; i < 3; i++) {
                particles.push({
                    x: x + (Math.random() - 0.5) * 14,
                    y: y + Math.random() * 4,
                    vx: (Math.random() - 0.5) * 2.5,
                    vy: 3 + Math.random() * 2,
                    life: 0,
                    color: ['#FF5722', '#FF9800', '#F44336'][Math.floor(Math.random() * 3)], // Orange/red flames
                    size: 5 + Math.random() * 5,
                    maxLife: 18
                });
            }
            // Smoke particles (gray, slow, dispersing)
            for (let i = 0; i < 2; i++) {
                particles.push({
                    x: x + (Math.random() - 0.5) * 20,
                    y: y + Math.random() * 8,
                    vx: (Math.random() - 0.5) * 3,
                    vy: 2 + Math.random() * 1.5,
                    life: 0,
                    color: ['#757575', '#9E9E9E', '#BDBDBD'][Math.floor(Math.random() * 3)], // Gray smoke
                    size: 6 + Math.random() * 6,
                    maxLife: 25
                });
            }
        }

        // ============================================
        // FLOATING TEXT SYSTEM (score popups)
        // ============================================
        let floatingTexts = [];

        function spawnFloatingText(x, y, text) {
            floatingTexts.push({
                x: x,
                y: y,
                text: text,
                life: 0,
                maxLife: 45, // ~0.75 seconds at 60fps
                vy: -2 // Float upward
            });
        }

        function updateFloatingTexts() {
            for (let i = floatingTexts.length - 1; i >= 0; i--) {
                const ft = floatingTexts[i];
                ft.y += ft.vy;
                ft.life++;
                if (ft.life >= ft.maxLife) {
                    floatingTexts.splice(i, 1);
                }
            }
        }

        function drawFloatingTexts() {
            // Get contrasting color based on current land
            const land = lands[selectedLand];
            const textColor = land?.floatingTextColor || '#FFFFFF';

            floatingTexts.forEach(ft => {
                const alpha = 1 - (ft.life / ft.maxLife);
                ctx.globalAlpha = alpha;
                ctx.fillStyle = textColor;
                ctx.font = 'bold 24px monospace';  // Larger text (score display is 28px)
                ctx.textAlign = 'center';
                ctx.fillText(ft.text, ft.x, ft.y);
            });
            ctx.globalAlpha = 1;
        }

        function clearFloatingTexts() {
            floatingTexts = [];
        }

        // ============================================
        // BACKGROUND ANNOUNCEMENT SYSTEM
        // ============================================
        let announcement = {
            text: '',
            life: 0,
            maxLife: 120, // 2 seconds at 60fps
            phase: 'none' // 'fadein', 'hold', 'fadeout', 'none'
        };
        let announcementQueue = []; // Queue for back-to-back announcements
        let lastAnnouncedLevel = -1; // Track which level we announced (-1 = none yet)
        let highestLevelReached = 0; // Track highest level for stats

        /**
         * Get the current level based on score (every 1000 points = 1 level)
         * @param {number} currentScore - The player's current score
         * @returns {number} The current level (0, 1, 2, ... infinite)
         */
        function getCurrentLevel(currentScore) {
            return Math.floor(currentScore / 1000);
        }

        /**
         * Queue an announcement to be shown
         * If no announcement is playing, starts immediately
         * @param {string} text - The text to display
         */
        function triggerAnnouncement(text) {
            if (announcement.phase === 'none') {
                // Start immediately if nothing playing
                announcement = {
                    text: text,
                    life: 0,
                    maxLife: 120, // 2 seconds total
                    phase: 'fadein'
                };
            } else {
                // Queue for later
                announcementQueue.push(text);
            }
        }

        /**
         * Queue multiple announcements to play in sequence
         * @param {string[]} texts - Array of announcement texts
         */
        function queueAnnouncements(texts) {
            texts.forEach(text => triggerAnnouncement(text));
        }

        function updateAnnouncement() {
            if (announcement.phase === 'none') {
                // Check if there's a queued announcement
                if (announcementQueue.length > 0) {
                    const nextText = announcementQueue.shift();
                    announcement = {
                        text: nextText,
                        life: 0,
                        maxLife: 120,
                        phase: 'fadein'
                    };
                }
                return;
            }

            announcement.life++;

            // Fade in for first 20 frames
            if (announcement.phase === 'fadein' && announcement.life >= 20) {
                announcement.phase = 'hold';
            }
            // Hold for middle section
            else if (announcement.phase === 'hold' && announcement.life >= announcement.maxLife - 30) {
                announcement.phase = 'fadeout';
            }
            // Fade out for last 30 frames
            else if (announcement.phase === 'fadeout' && announcement.life >= announcement.maxLife) {
                announcement.phase = 'none';
                announcement.text = '';
                // Queue processing happens at start of next call
            }
        }

        function drawAnnouncement() {
            if (announcement.phase === 'none' || !announcement.text) return;

            const land = lands[selectedLand];
            const textColor = land?.floatingTextColor || '#FFFFFF';

            // Calculate alpha based on phase
            let alpha = 0.4; // Base transparency
            if (announcement.phase === 'fadein') {
                alpha = 0.4 * (announcement.life / 20);
            } else if (announcement.phase === 'fadeout') {
                const fadeoutProgress = (announcement.life - (announcement.maxLife - 30)) / 30;
                alpha = 0.4 * (1 - fadeoutProgress);
            }

            ctx.save();
            ctx.globalAlpha = alpha;

            // Calculate font size to fit ~70% of screen width
            const targetWidth = canvas.width * 0.7;
            let fontSize = 100;
            ctx.font = `bold ${fontSize}px monospace`;
            let textWidth = ctx.measureText(announcement.text).width;

            // Adjust font size to fit
            while (textWidth > targetWidth && fontSize > 20) {
                fontSize -= 5;
                ctx.font = `bold ${fontSize}px monospace`;
                textWidth = ctx.measureText(announcement.text).width;
            }

            // Position in center of screen, slightly above middle
            const x = canvas.width / 2;
            const y = canvas.height * 0.45;

            ctx.fillStyle = textColor;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(announcement.text, x, y);

            ctx.restore();
        }

        function clearAnnouncement() {
            announcement = { text: '', life: 0, maxLife: 120, phase: 'none' };
            announcementQueue = [];
            lastAnnouncedLevel = -1;
        }

        /**
         * Check if we've reached a new level and trigger announcement
         * Levels are infinite (no cap)
         */
        function checkLevelAnnouncement() {
            const currentLevel = getCurrentLevel(score);

            // Track highest level reached for stats
            if (currentLevel > highestLevelReached) {
                highestLevelReached = currentLevel;
            }

            // Check if we've reached a new level (1 or higher)
            if (currentLevel > lastAnnouncedLevel && currentLevel >= 1) {
                triggerAnnouncement(`LEVEL ${currentLevel}`);
                lastAnnouncedLevel = currentLevel;
            }
        }

        // ============================================
        // JUMP OVER OBSTACLE TRACKING
        // ============================================
        let obstaclesJumpedOver = new Set(); // Track which obstacle groups we've cleared
        let spawnIdCounter = 0; // Unique ID for each spawn group
        let jumpBonusScore = 0; // Accumulated jump bonus points

        // ============================================
        // JETPACK POWER-UP STATE
        // ============================================
        let jetpackActive = false;
        let jetpackTimer = 0; // Frames remaining (5 sec = 300 frames at 60fps)
        let jetpackPhase = 'none'; // 'rising', 'peak', 'descending', 'none'
        let jetpackTargetY = 0; // Target Y position when flying
        let jetpackOriginalY = 0; // Original ground Y to return to
        let jetpackSpawnCounter = 0; // Track spawns to guarantee ~1 per run
        let powerUpBonusScore = 0; // Accumulated power-up bonus points
        const JETPACK_DURATION = 360; // 6 seconds at 60fps
        const JETPACK_FLY_HEIGHT = 120; // How high above ground to fly
        const JETPACK_RISE_SPEED = 8; // Speed of initial rise
        const JETPACK_DESCEND_SPEED = 1; // Slow descent speed

        // ============================================
        // T-REX POWER-UP STATE
        // ============================================
        let trexActive = false;
        let trexTimer = 0; // Frames remaining (6 sec = 360 frames at 60fps)
        const TREX_DURATION = 360; // 6 seconds at 60fps
        const TREX_WIDTH = 48 * PLAYER_SCALE; // T-Rex sprite is 48px wide
        const TREX_HEIGHT = 48 * PLAYER_SCALE; // T-Rex sprite height (just body, not tail)
        let lastPowerUpType = 'trex'; // Alternate between 'jetpack' and 'trex'

        // Game state: 'welcome', 'menu', 'playing', 'gameover', 'leaderboard', 'lobby'
        // (gameState declared early to avoid temporal dead zone)
        let gameMode = 'solo'; // 'solo' or 'multiplayer'
        let score = 0;
        let bananasCollected = 0;
        let gameTime = 0;
        let speed = 6;
        // (spawnCounter declared early to avoid temporal dead zone)
        let scrollOffset = 0;
        // (entities declared early to avoid temporal dead zone)
        let scoreSaved = false; // Track if score was saved for current game

        // Leaderboard data
        let leaderboardData = [];
        let loadingLeaderboard = false;

        // Game Over stats
        let gameOverStats = {
            globalTopScore: null,
            globalTopPlayer: null,
            biomeTopScore: null,
            biomeTopPlayer: null,
            personalBiomeBest: null,
            isNewBiomeBest: false,
            isNewGlobalBest: false,
            loading: true
        };

        // Multiplayer lobby state
        let currentLobby = null;
        let lobbyPlayers = [];
        let lobbySubscription = null;
        let isLobbyHost = false;
        let lobbyCodeInput = '';
        let lobbyJoinError = '';
        const MAX_LOBBY_PLAYERS = 7;

        // Multiplayer game state
        let multiplayerPlayers = [];  // All players' states for rendering
        let localPlayerIndex = 0;     // My position in the player order
        let localPlayerAlive = true;  // Am I still alive?
        let allPlayersStates = {};    // Track all player states by ID
        let gameChannel = null;       // Supabase realtime channel for game state

        // Legacy (will be replaced by multiplayerPlayers)
        let opponentScore = 0;
        let opponentBananas = 0;
        let gameResult = null; // 'win', 'lose', 'tie'

        // Skins system - Achievement skins (free when unlocked) and Purchasable skins
        const SKINS = {
            // =====================================
            // TIER 0: DEFAULT (Always Unlocked)
            // =====================================
            default: {
                name: 'Classic Runner',
                description: 'The original banana chaser',
                type: 'default',
                tier: 0,
                colorOverrides: {}
            },

            // =====================================
            // TIER 1: ACHIEVEMENT SKINS (Free)
            // =====================================
            golden: {
                name: 'Golden Runner',
                description: 'Collect 100 bananas total',
                type: 'achievement',
                tier: 1,
                unlockReq: { type: 'bananas', value: 100 },
                colorOverrides: { 4: '#FFD700', 5: '#FFC107', 6: '#B8860B' }
            },
            speedster: {
                name: 'Speed Demon',
                description: 'Score 5000 in one game',
                type: 'achievement',
                tier: 1,
                unlockReq: { type: 'score', value: 5000 },
                colorOverrides: { 4: '#E91E63', 5: '#FF4081', 6: '#AD1457' },
                effect: 'fire'  // FREE fire trail for achievement!
            },
            veteran: {
                name: 'Veteran',
                description: 'Play 50 games',
                type: 'achievement',
                tier: 1,
                unlockReq: { type: 'games', value: 50 },
                colorOverrides: { 4: '#4CAF50', 5: '#2E7D32', 6: '#1B5E20' }  // Green camo
            },
            champion: {
                name: 'Champion',
                description: 'Win 10 multiplayer games',
                type: 'achievement',
                tier: 1,
                unlockReq: { type: 'mp_wins', value: 10 },
                colorOverrides: { 4: '#9C27B0', 5: '#7B1FA2', 6: '#4A148C' }
            },

            // =====================================
            // TIER 2: BUDGET SHOP (25-75 bananas)
            // =====================================
            ninja: {
                name: 'Ninja',
                description: 'Silent but deadly',
                type: 'purchasable',
                tier: 2,
                price: 25,
                transformative: true,
                customSprite: 'ninjaSprite'
            },
            pirate: {
                name: 'Pirate',
                description: 'Arr, bananas ahead!',
                type: 'purchasable',
                tier: 2,
                price: 50,
                transformative: true,
                customSprite: 'pirateSprite'
            },
            astronaut: {
                name: 'Astronaut',
                description: 'One small step...',
                type: 'purchasable',
                tier: 2,
                price: 75,
                transformative: true,
                customSprite: 'astronautSprite'
            },

            // =====================================
            // TIER 3: PREMIUM SHOP (100-200 bananas)
            // =====================================
            flame: {
                name: 'Flame Runner',
                description: 'Leave fire in your wake',
                type: 'purchasable',
                tier: 3,
                price: 100,
                colorOverrides: { 4: '#FF5722', 5: '#FF8A65', 6: '#BF360C' },
                effect: 'fire'
            },
            ice: {
                name: 'Ice Runner',
                description: 'Cool as a cucumber',
                type: 'purchasable',
                tier: 3,
                price: 125,
                colorOverrides: { 4: '#4FC3F7', 5: '#81D4FA', 6: '#0288D1' },
                effect: 'ice'
            },
            neon: {
                name: 'Neon Glow',
                description: 'Light up the night',
                type: 'purchasable',
                tier: 3,
                price: 150,
                colorOverrides: { 4: '#00FF00', 5: '#39FF14', 6: '#76FF03' }
            },
            shadow: {
                name: 'Shadow',
                description: 'Embrace the darkness',
                type: 'purchasable',
                tier: 3,
                price: 175,
                colorOverrides: { 4: '#212121', 5: '#424242', 6: '#0d0d0d' },
                effect: 'shadow'
            },
            rainbow: {
                name: 'Rainbow Runner',
                description: 'All the colors!',
                type: 'purchasable',
                tier: 3,
                price: 200,
                colorOverrides: { 4: '#FF0000', 5: '#00FF00', 6: '#0000FF' },
                animated: true
            },
            banana: {
                name: 'Banana Suit',
                description: 'Become the banana!',
                type: 'purchasable',
                tier: 3,
                price: 150,
                transformative: true,
                customSprite: 'bananaSuit'
            },

            // =====================================
            // TIER 4: LEGENDARY (300-500 bananas)
            // =====================================
            robot: {
                name: 'Robot',
                description: 'Beep boop banana',
                type: 'purchasable',
                tier: 4,
                price: 300,
                transformative: true,
                customSprite: 'robotSprite'
            },
            ghost: {
                name: 'Ghost',
                description: 'Spooky runner',
                type: 'purchasable',
                tier: 4,
                price: 350,
                colorOverrides: {
                    1: '#E0E0E0', 2: '#EEEEEE',  // Pale ghost
                    4: '#F5F5F5', 5: '#FAFAFA', 6: '#E0E0E0'
                },
                transparency: 0.7  // Semi-transparent!
            },
            diamond: {
                name: 'Diamond',
                description: 'Shine bright',
                type: 'purchasable',
                tier: 4,
                price: 500,
                colorOverrides: { 4: '#B9F2FF', 5: '#E0FFFF', 6: '#AFEEEE' },
                effect: 'sparkle'
            }
        };

        // ============================================
        // COMPREHENSIVE ACHIEVEMENTS SYSTEM
        // ============================================
        // Each achievement has:
        // - name: Display name
        // - description: Kid-friendly description
        // - reward: Banana reward for unlocking
        // - requirement: { type, value } for unlock logic
        // - category: For organizing in achievements page
        const ACHIEVEMENTS = {
            // =====================================
            // GETTING STARTED (Games Played)
            // =====================================
            first_game: {
                name: 'First Steps',
                description: 'Play your very first game!',
                reward: 5,
                requirement: { type: 'total_games', value: 1 },
                category: 'games'
            },
            getting_started: {
                name: 'Getting Started',
                description: 'Play 5 games total',
                reward: 10,
                requirement: { type: 'total_games', value: 5 },
                category: 'games'
            },
            regular_player: {
                name: 'Regular Player',
                description: 'Play 10 games total',
                reward: 15,
                requirement: { type: 'total_games', value: 10 },
                category: 'games'
            },
            dedicated_runner: {
                name: 'Dedicated Runner',
                description: 'Play 25 games total',
                reward: 25,
                requirement: { type: 'total_games', value: 25 },
                category: 'games'
            },
            banana_master: {
                name: 'Banana Master',
                description: 'Play 50 games total',
                reward: 50,
                requirement: { type: 'total_games', value: 50 },
                category: 'games'
            },
            true_champion: {
                name: 'True Champion',
                description: 'Play 100 games total!',
                reward: 100,
                requirement: { type: 'total_games', value: 100 },
                category: 'games'
            },

            // =====================================
            // SCORE ACHIEVEMENTS
            // =====================================
            first_hundred: {
                name: 'First Hundred',
                description: 'Score 100 points in one game',
                reward: 5,
                requirement: { type: 'high_score', value: 100 },
                category: 'score'
            },
            making_progress: {
                name: 'Making Progress',
                description: 'Score 500 points in one game',
                reward: 10,
                requirement: { type: 'high_score', value: 500 },
                category: 'score'
            },
            breaking_through: {
                name: 'Breaking Through',
                description: 'Score 1000 points in one game',
                reward: 15,
                requirement: { type: 'high_score', value: 1000 },
                category: 'score'
            },
            skilled_runner: {
                name: 'Skilled Runner',
                description: 'Score 2500 points in one game',
                reward: 25,
                requirement: { type: 'high_score', value: 2500 },
                category: 'score'
            },
            expert_runner: {
                name: 'Expert Runner',
                description: 'Score 5000 points in one game',
                reward: 50,
                requirement: { type: 'high_score', value: 5000 },
                category: 'score'
            },
            master_runner: {
                name: 'Master Runner',
                description: 'Score 10000 points in one game!',
                reward: 100,
                requirement: { type: 'high_score', value: 10000 },
                category: 'score'
            },
            legendary_runner: {
                name: 'Legendary Runner',
                description: 'Score 25000 points in one game!',
                reward: 250,
                requirement: { type: 'high_score', value: 25000 },
                category: 'score'
            },

            // =====================================
            // BANANA COLLECTION
            // =====================================
            first_banana: {
                name: 'First Banana',
                description: 'Collect your first banana!',
                reward: 1,
                requirement: { type: 'total_bananas', value: 1 },
                category: 'bananas'
            },
            banana_bunch: {
                name: 'Banana Bunch',
                description: 'Collect 10 bananas total',
                reward: 5,
                requirement: { type: 'total_bananas', value: 10 },
                category: 'bananas'
            },
            banana_collector: {
                name: 'Banana Collector',
                description: 'Collect 50 bananas total',
                reward: 15,
                requirement: { type: 'total_bananas', value: 50 },
                category: 'bananas'
            },
            banana_hoarder: {
                name: 'Banana Hoarder',
                description: 'Collect 100 bananas total',
                reward: 25,
                requirement: { type: 'total_bananas', value: 100 },
                category: 'bananas'
            },
            banana_baron: {
                name: 'Banana Baron',
                description: 'Collect 500 bananas total',
                reward: 75,
                requirement: { type: 'total_bananas', value: 500 },
                category: 'bananas'
            },
            banana_billionaire: {
                name: 'Banana Billionaire',
                description: 'Collect 1000 bananas total!',
                reward: 150,
                requirement: { type: 'total_bananas', value: 1000 },
                category: 'bananas'
            },

            // =====================================
            // POWER-UP ACHIEVEMENTS (Jetpack)
            // =====================================
            first_flight: {
                name: 'First Flight',
                description: 'Use a jetpack for the first time!',
                reward: 10,
                requirement: { type: 'jetpacks_collected', value: 1 },
                category: 'powerups'
            },
            sky_high: {
                name: 'Sky High',
                description: 'Use 10 jetpacks total',
                reward: 25,
                requirement: { type: 'jetpacks_collected', value: 10 },
                category: 'powerups'
            },
            rocket_man: {
                name: 'Rocket Man',
                description: 'Use 25 jetpacks total',
                reward: 50,
                requirement: { type: 'jetpacks_collected', value: 25 },
                category: 'powerups'
            },

            // =====================================
            // POWER-UP ACHIEVEMENTS (T-Rex)
            // =====================================
            first_stomp: {
                name: 'First Stomp',
                description: 'Use a Dino Stomp for the first time!',
                reward: 10,
                requirement: { type: 'dino_stomps_collected', value: 1 },
                category: 'powerups'
            },
            dino_power: {
                name: 'Dino Power',
                description: 'Use 10 Dino Stomps total',
                reward: 25,
                requirement: { type: 'dino_stomps_collected', value: 10 },
                category: 'powerups'
            },
            trex_king: {
                name: 'T-Rex King',
                description: 'Use 25 Dino Stomps total!',
                reward: 50,
                requirement: { type: 'dino_stomps_collected', value: 25 },
                category: 'powerups'
            },

            // =====================================
            // LEVEL ACHIEVEMENTS
            // =====================================
            level_one: {
                name: 'Level One',
                description: 'Reach Level 1 (score 1000)',
                reward: 10,
                requirement: { type: 'highest_level_reached', value: 1 },
                category: 'levels'
            },
            level_five: {
                name: 'Level Five',
                description: 'Reach Level 5 (score 5000)',
                reward: 35,
                requirement: { type: 'highest_level_reached', value: 5 },
                category: 'levels'
            },
            level_ten: {
                name: 'Level Ten',
                description: 'Reach Level 10 (score 10000)!',
                reward: 75,
                requirement: { type: 'highest_level_reached', value: 10 },
                category: 'levels'
            },
            level_master: {
                name: 'Level Master',
                description: 'Reach Level 25 (score 25000)!',
                reward: 200,
                requirement: { type: 'highest_level_reached', value: 25 },
                category: 'levels'
            },

            // =====================================
            // LAND/BIOME EXPLORATION
            // =====================================
            snow_explorer: {
                name: 'Snow Explorer',
                description: 'Play a game in Snow Land',
                reward: 5,
                requirement: { type: 'snow_games_played', value: 1 },
                category: 'lands'
            },
            desert_explorer: {
                name: 'Desert Explorer',
                description: 'Play a game in Desert Land',
                reward: 5,
                requirement: { type: 'desert_games_played', value: 1 },
                category: 'lands'
            },
            jungle_explorer: {
                name: 'Jungle Explorer',
                description: 'Play a game in Jungle Land',
                reward: 5,
                requirement: { type: 'jungle_games_played', value: 1 },
                category: 'lands'
            },
            ocean_explorer: {
                name: 'Ocean Explorer',
                description: 'Play a game in Ocean Land',
                reward: 5,
                requirement: { type: 'ocean_games_played', value: 1 },
                category: 'lands'
            },
            world_traveler: {
                name: 'World Traveler',
                description: 'Play on all 4 different lands!',
                reward: 25,
                requirement: { type: 'all_lands_played', value: true },
                category: 'lands'
            },
            snow_master: {
                name: 'Snow Master',
                description: 'Play 10 games in Snow Land',
                reward: 20,
                requirement: { type: 'snow_games_played', value: 10 },
                category: 'lands'
            },
            desert_master: {
                name: 'Desert Master',
                description: 'Play 10 games in Desert Land',
                reward: 20,
                requirement: { type: 'desert_games_played', value: 10 },
                category: 'lands'
            },
            jungle_master: {
                name: 'Jungle Master',
                description: 'Play 10 games in Jungle Land',
                reward: 20,
                requirement: { type: 'jungle_games_played', value: 10 },
                category: 'lands'
            },
            ocean_master: {
                name: 'Ocean Master',
                description: 'Play 10 games in Ocean Land',
                reward: 20,
                requirement: { type: 'ocean_games_played', value: 10 },
                category: 'lands'
            },

            // =====================================
            // TIME PLAYED
            // =====================================
            warming_up: {
                name: 'Warming Up',
                description: 'Play for 5 minutes total',
                reward: 10,
                requirement: { type: 'total_time_played', value: 300 },
                category: 'time'
            },
            getting_comfortable: {
                name: 'Getting Comfortable',
                description: 'Play for 15 minutes total',
                reward: 25,
                requirement: { type: 'total_time_played', value: 900 },
                category: 'time'
            },
            time_flies: {
                name: 'Time Flies',
                description: 'Play for 30 minutes total',
                reward: 50,
                requirement: { type: 'total_time_played', value: 1800 },
                category: 'time'
            },
            dedicated_player: {
                name: 'Dedicated Player',
                description: 'Play for 1 hour total!',
                reward: 100,
                requirement: { type: 'total_time_played', value: 3600 },
                category: 'time'
            },
            hardcore_gamer: {
                name: 'Hardcore Gamer',
                description: 'Play for 2 hours total!',
                reward: 200,
                requirement: { type: 'total_time_played', value: 7200 },
                category: 'time'
            },

            // =====================================
            // LEADERBOARD
            // =====================================
            top_banana: {
                name: 'Top Banana',
                description: 'Reach #1 on the leaderboard!',
                reward: 100,
                requirement: { type: 'times_reached_rank_one', value: 1 },
                category: 'leaderboard'
            },

            // =====================================
            // SHOP/PURCHASES
            // =====================================
            first_purchase: {
                name: 'First Purchase',
                description: 'Buy your first item from the shop!',
                reward: 10,
                requirement: { type: 'total_purchases', value: 1 },
                category: 'shop'
            },
            collector: {
                name: 'Collector',
                description: 'Buy 5 items from the shop',
                reward: 25,
                requirement: { type: 'total_purchases', value: 5 },
                category: 'shop'
            },
            shopaholic: {
                name: 'Shopaholic',
                description: 'Buy 10 items from the shop!',
                reward: 75,
                requirement: { type: 'total_purchases', value: 10 },
                category: 'shop'
            },

            // =====================================
            // MULTIPLAYER
            // =====================================
            social_butterfly: {
                name: 'Social Butterfly',
                description: 'Play your first multiplayer game!',
                reward: 15,
                requirement: { type: 'multiplayer_games', value: 1 },
                category: 'multiplayer'
            },
            first_win: {
                name: 'Victory!',
                description: 'Win your first multiplayer game!',
                reward: 25,
                requirement: { type: 'multiplayer_wins', value: 1 },
                category: 'multiplayer'
            },
            champion: {
                name: 'Champion',
                description: 'Win 10 multiplayer games!',
                reward: 100,
                requirement: { type: 'multiplayer_wins', value: 10 },
                category: 'multiplayer'
            }
        };

        // Achievement categories for organizing the achievements page
        const ACHIEVEMENT_CATEGORIES = {
            games: { name: 'Games Played', order: 1 },
            score: { name: 'Score', order: 2 },
            bananas: { name: 'Bananas', order: 3 },
            levels: { name: 'Levels', order: 4 },
            powerups: { name: 'Power-Ups', order: 5 },
            lands: { name: 'Lands', order: 6 },
            time: { name: 'Time Played', order: 7 },
            leaderboard: { name: 'Leaderboard', order: 8 },
            shop: { name: 'Shop', order: 9 },
            multiplayer: { name: 'Multiplayer', order: 10 }
        };

        let unlockedSkins = ['default'];
        let unlockedAchievements = [];
        let selectedSkin = 'default';
        let spendableBananas = 0;  // Currency for shop purchases
        let landsPlayed = new Set();

        // ============================================
        // SESSION STATS TRACKING
        // ============================================
        // These track stats for the current game session
        let sessionJetpacksCollected = 0;
        let sessionDinoStompsCollected = 0;
        let sessionGameDuration = 0; // in seconds

        // ============================================
        // LIFETIME PLAYER STATS (synced with database)
        // ============================================
        // These aggregate stats are loaded from and saved to the database
        let playerStats = {
            // Core stats
            total_games: 0,
            high_score: 0,
            total_score: 0,
            total_bananas: 0,
            spendable_bananas: 0,
            total_time_played: 0, // in seconds

            // Power-up stats
            jetpacks_collected: 0,
            dino_stomps_collected: 0,

            // Land-specific stats
            snow_games_played: 0,
            desert_games_played: 0,
            jungle_games_played: 0,
            ocean_games_played: 0,
            snow_best_score: 0,
            desert_best_score: 0,
            jungle_best_score: 0,
            ocean_best_score: 0,

            // Milestones
            first_game_at: null,
            last_game_at: null,
            highest_level_reached: 0,
            times_reached_rank_one: 0,

            // Purchase stats
            total_purchases: 0,
            total_spent: 0,

            // Multiplayer stats (for achievements)
            multiplayer_games: 0,
            multiplayer_wins: 0
        };

        // Shop scroll state
        let shopScrollY = 0;          // Current scroll offset
        let shopScrollMax = 0;        // Maximum scroll value (content - viewport)
        let shopScrollVel = 0;        // Momentum velocity
        let shopDragging = false;     // Is user currently dragging
        let shopDragStartY = 0;       // Y position where drag started
        let shopLastY = 0;            // Last Y for velocity calculation
        let shopLastTime = 0;         // Last time for velocity calculation
        let shopDragDistance = 0;     // Total distance moved (for tap vs scroll detection)

        // Achievements scroll state
        let achievementsScrollY = 0;
        let achievementsScrollMax = 0;
        let achievementsScrollVel = 0;
        let achievementsDragging = false;
        let achievementsDragStartY = 0;
        let achievementsLastY = 0;
        let achievementsLastTime = 0;
        let achievementsDragDistance = 0;

        // Achievement check state
        let isCheckingAchievements = false;
        let lastAchievementCheckResult = null; // { checked, unlocked, newRewards }

        // Jump buffering - stores timestamp of last jump attempt
        // JUMP_BUFFER_MS imported from config.js
        let jumpBufferTime = 0;

        // Variable jump height - track if jump button is held
        let jumpHeld = false;
        const JUMP_RELEASE_MULTIPLIER = 0.4;  // Velocity multiplier when releasing early
        const FALL_GRAVITY_MULTIPLIER = 1.5;  // Extra gravity when falling or released

        // Dynamic jump velocity based on screen height
        // Ensures player doesn't bonk head on ceiling in landscape mobile
        const BASE_JUMP_VELOCITY = -18;
        const MIN_CEILING_MARGIN = 30;  // Minimum space from top of screen

        function getJumpVelocity() {
            // Calculate available jump space (from ground to ceiling margin)
            const groundLevel = getGroundLevel();
            const availableHeight = groundLevel - MIN_CEILING_MARGIN - PLAYER_HEIGHT;

            // For a standard 600px height, available is about 500px
            // Scale jump velocity if screen is shorter
            const standardHeight = 500;
            const heightRatio = Math.min(1, availableHeight / standardHeight);

            // Scale velocity (sqrt for more natural feel - half height = ~70% velocity)
            return BASE_JUMP_VELOCITY * Math.sqrt(heightRatio);
        }

        // Land selection buttons (will be calculated in draw)
        let landButtons = [];
        // Menu action buttons (Solo, Multiplayer, Leaderboard, Login)
        let menuButtons = [];

        // Player (declared early to avoid temporal dead zone, assigned here)
        player = {
            x: 100,
            y: getGroundLevel() - PLAYER_HEIGHT,
            vy: 0,
            jumping: false,
            get groundY() { return getGroundLevel() - PLAYER_HEIGHT; },
            scale: PLAYER_SCALE
        };

        // Check if a point is inside a button
        function pointInButton(x, y, btn) {
            return x >= btn.x && x <= btn.x + btn.w && y >= btn.y && y <= btn.y + btn.h;
        }

        // Handle click/tap for land selection and menu buttons
        function handleClick(clientX, clientY) {
            const rect = canvas.getBoundingClientRect();
            const x = (clientX - rect.left) * (canvas.width / rect.width);
            const y = (clientY - rect.top) * (canvas.height / rect.height);

            // Check back button first (top right)
            if (backButton && pointInButton(x, y, backButton)) {
                backButton.action();
                backButton = null; // Clear after use
                return true;
            }

            // Check design system clickable areas first
            for (const area of clickableAreas) {
                if (pointInBounds(x, y, area)) {
                    handleMenuAction(area.action);
                    return true;
                }
            }

            // Check legacy menu action buttons
            for (const btn of menuButtons) {
                if (pointInButton(x, y, btn)) {
                    handleMenuAction(btn.action);
                    return true;
                }
            }

            // Check land buttons
            for (const btn of landButtons) {
                if (pointInButton(x, y, btn)) {
                    selectedLand = btn.land;
                    if (gameState === 'gameover') {
                        startGame();
                    }
                    return true;
                }
            }
            return false;
        }

        // Handle menu button actions
        function handleMenuAction(action) {
            switch (action) {
                case 'solo':
                    gameMode = 'solo';
                    startGame();
                    break;
                case 'multiplayer':
                    if (!currentUser) {
                        showAuthModal();
                    } else {
                        gameState = 'multiplayer-menu';
                    }
                    break;
                case 'create_lobby':
                    createNewLobby();
                    break;
                case 'show_join':
                    lobbyCodeInput = '';
                    lobbyJoinError = '';
                    gameState = 'join-lobby';
                    break;
                case 'join_with_code':
                    joinLobbyWithCode();
                    break;
                case 'start_game':
                    hostStartGame();
                    break;
                case 'leaderboard':
                    showLeaderboard();
                    break;
                case 'shop':
                    gameState = 'shop';
                    shopScrollY = 0;  // Reset scroll when entering shop
                    shopScrollVel = 0;
                    break;
                case 'achievements':
                    gameState = 'achievements';
                    achievementsScrollY = 0;  // Reset scroll when entering achievements
                    achievementsScrollVel = 0;
                    lastAchievementCheckResult = null; // Clear previous check result
                    break;
                case 'check_achievements':
                    if (!isCheckingAchievements && currentUser) {
                        isCheckingAchievements = true;
                        lastAchievementCheckResult = null;
                        checkAllAchievementsRetroactive().then(result => {
                            lastAchievementCheckResult = result;
                            isCheckingAchievements = false;
                        }).catch(err => {
                            console.error('Error checking achievements:', err);
                            isCheckingAchievements = false;
                        });
                    }
                    break;
                case 'login':
                    showAuthModal();
                    break;
                case 'back':
                    if (gameState === 'join-lobby' || gameState === 'multiplayer-menu' || gameState === 'shop' || gameState === 'achievements' || gameState === 'leaderboard') {
                        gameState = 'menu';
                    } else {
                        gameState = 'menu';
                    }
                    break;
                case 'back_to_mp_menu':
                    gameState = 'multiplayer-menu';
                    break;
                case 'leave_lobby':
                    leaveLobby();
                    break;
                case 'play_again':
                    hostPlayAgain();
                    break;
                case 'leave_results':
                    leaveMultiplayerResults();
                    break;
                case 'focus_code_input':
                    // Focus the hidden input to trigger native keyboard
                    const hiddenInput = document.getElementById('lobbyCodeInput');
                    if (hiddenInput) {
                        hiddenInput.value = lobbyCodeInput;
                        hiddenInput.focus();
                        hiddenInput.select();
                    }
                    break;
                default:
                    // Handle shop skin actions
                    if (action.startsWith('equip_')) {
                        const skinId = action.replace('equip_', '');
                        equipSkin(skinId);
                    } else if (action.startsWith('buy_')) {
                        const skinId = action.replace('buy_', '');
                        purchaseSkin(skinId);
                    }
                    // Handle virtual keyboard keys for lobby code input
                    else if (action.startsWith('key_')) {
                        const key = action.substring(4);
                        if (key === 'backspace') {
                            lobbyCodeInput = lobbyCodeInput.slice(0, -1);
                            lobbyJoinError = '';
                        } else if (lobbyCodeInput.length < 6) {
                            lobbyCodeInput += key.toUpperCase();
                            lobbyJoinError = '';
                        }
                    }
                    break;
            }
        }

        // Show leaderboard
        async function showLeaderboard() {
            gameState = 'leaderboard';
            loadingLeaderboard = true;
            leaderboardData = await getLeaderboard(null, 10);
            loadingLeaderboard = false;
        }

        // Input handling
        function jump() {
            if (gameState === 'playing') {
                // Ghosts can't jump in multiplayer
                if (gameMode === 'multiplayer' && !localPlayerAlive) {
                    return;
                }

                // If jetpack is active and past the rising phase, allow early drop
                if (jetpackActive && (jetpackPhase === 'peak' || jetpackPhase === 'descending')) {
                    // Early drop from jetpack
                    jetpackActive = false;
                    jetpackPhase = 'none';
                    jetpackTimer = 0;
                    player.jumping = true;
                    player.vy = 2; // Start falling
                    return;
                }

                // If T-Rex is active, exit T-Rex mode and jump
                if (trexActive) {
                    // Exit T-Rex and jump out
                    trexActive = false;
                    trexTimer = 0;
                    player.vy = getJumpVelocity();
                    player.jumping = true;
                    jumpHeld = true;
                    jumpBufferTime = 0;
                    return;
                }

                // Normal jump when not using power-ups
                if (!jetpackActive && !trexActive && !player.jumping) {
                    // On ground - jump immediately with screen-scaled velocity
                    player.vy = getJumpVelocity();
                    player.jumping = true;
                    jumpHeld = true;
                    jumpBufferTime = 0;
                } else if (!jetpackActive && !trexActive) {
                    // In air - buffer the jump request
                    jumpBufferTime = Date.now();
                }
            }
        }

        // Release jump - called when button/touch is released
        function releaseJump() {
            if (jumpHeld && player.jumping && player.vy < 0) {
                // Still rising - cut the velocity for a short hop
                player.vy *= JUMP_RELEASE_MULTIPLIER;
            }
            jumpHeld = false;
        }

        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space') {
                e.preventDefault();
                if (gameState === 'playing') {
                    jump();
                } else if (gameState === 'gameover') {
                    startGame();
                } else if (gameState === 'leaderboard' || gameState === 'shop') {
                    gameState = 'menu';
                }
            }
            if (e.code === 'Escape') {
                if (gameState === 'leaderboard' || gameState === 'shop' || gameState === 'achievements') {
                    gameState = 'menu';
                }
            }
        });

        // Release jump on keyup for variable jump height
        document.addEventListener('keyup', (e) => {
            if (e.code === 'Space') {
                releaseJump();
            }
        });

        // Menu states where clicks are handled as buttons
        const MENU_STATES = ['welcome', 'menu', 'gameover', 'leaderboard', 'lobby', 'multiplayer-menu', 'join-lobby', 'multiplayer-results', 'shop', 'achievements'];

        function isMenuState() {
            return MENU_STATES.includes(gameState);
        }

        // Touch support for mobile
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const touch = e.touches[0];

            // Shop/Achievements scroll handling
            if (gameState === 'shop') {
                const rect = canvas.getBoundingClientRect();
                const y = (touch.clientY - rect.top) * (canvas.height / rect.height);
                shopDragging = true;
                shopDragStartY = y;
                shopLastY = y;
                shopLastTime = Date.now();
                shopScrollVel = 0;
                shopDragDistance = 0;
                return;
            }
            if (gameState === 'achievements') {
                const rect = canvas.getBoundingClientRect();
                const y = (touch.clientY - rect.top) * (canvas.height / rect.height);
                achievementsDragging = true;
                achievementsDragStartY = y;
                achievementsLastY = y;
                achievementsLastTime = Date.now();
                achievementsScrollVel = 0;
                achievementsDragDistance = 0;
                return;
            }

            if (isMenuState()) {
                handleClick(touch.clientX, touch.clientY);
            } else {
                jump();
            }
        });

        // Touch move for shop/achievements scrolling
        canvas.addEventListener('touchmove', (e) => {
            if (gameState === 'shop' && shopDragging) {
                e.preventDefault();
                const touch = e.touches[0];
                const rect = canvas.getBoundingClientRect();
                const y = (touch.clientY - rect.top) * (canvas.height / rect.height);

                const delta = shopLastY - y;
                shopScrollY = Math.max(0, Math.min(shopScrollMax, shopScrollY + delta));
                shopDragDistance += Math.abs(delta);

                const now = Date.now();
                const dt = now - shopLastTime;
                if (dt > 0) {
                    shopScrollVel = delta / dt * 16;
                }
                shopLastY = y;
                shopLastTime = now;
            }
            if (gameState === 'achievements' && achievementsDragging) {
                e.preventDefault();
                const touch = e.touches[0];
                const rect = canvas.getBoundingClientRect();
                const y = (touch.clientY - rect.top) * (canvas.height / rect.height);

                const delta = achievementsLastY - y;
                achievementsScrollY = Math.max(0, Math.min(achievementsScrollMax, achievementsScrollY + delta));
                achievementsDragDistance += Math.abs(delta);

                const now = Date.now();
                const dt = now - achievementsLastTime;
                if (dt > 0) {
                    achievementsScrollVel = delta / dt * 16;
                }
                achievementsLastY = y;
                achievementsLastTime = now;
            }
        }, { passive: false });

        // Release jump on touch end for variable jump height
        canvas.addEventListener('touchend', (e) => {
            e.preventDefault();

            // Shop: end drag, check for tap (click)
            if (gameState === 'shop') {
                const wasDragging = shopDragging;
                shopDragging = false;

                if (wasDragging && shopDragDistance < 10 && e.changedTouches.length > 0) {
                    const touch = e.changedTouches[0];
                    handleClick(touch.clientX, touch.clientY);
                }
                return;
            }

            // Achievements: end drag, check for tap (click)
            if (gameState === 'achievements') {
                const wasDragging = achievementsDragging;
                achievementsDragging = false;

                if (wasDragging && achievementsDragDistance < 10 && e.changedTouches.length > 0) {
                    const touch = e.changedTouches[0];
                    handleClick(touch.clientX, touch.clientY);
                }
                return;
            }

            releaseJump();
        });

        canvas.addEventListener('click', (e) => {
            if (isMenuState()) {
                if (!handleClick(e.clientX, e.clientY)) {
                    if (gameState === 'gameover') {
                        startGame();
                    }
                }
            } else {
                jump();
            }
        });

        // Mouse up for variable jump height (when using click instead of touch)
        canvas.addEventListener('mouseup', (e) => {
            releaseJump();
        });

        // Mouse wheel for shop/achievements scrolling
        canvas.addEventListener('wheel', (e) => {
            if (gameState === 'shop') {
                e.preventDefault();
                shopScrollY = Math.max(0, Math.min(shopScrollMax, shopScrollY + e.deltaY * 0.5));
            }
            if (gameState === 'achievements') {
                e.preventDefault();
                achievementsScrollY = Math.max(0, Math.min(achievementsScrollMax, achievementsScrollY + e.deltaY * 0.5));
            }
        }, { passive: false });

        // Hidden input for native keyboard support on join-lobby screen
        const hiddenCodeInput = document.getElementById('lobbyCodeInput');
        if (hiddenCodeInput) {
            hiddenCodeInput.addEventListener('input', (e) => {
                // Filter to only letters and uppercase
                const filtered = e.target.value.replace(/[^A-Za-z]/g, '').toUpperCase().slice(0, 6);
                lobbyCodeInput = filtered;
                e.target.value = filtered;
                lobbyJoinError = '';
            });

            hiddenCodeInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' && lobbyCodeInput.length === 6) {
                    joinLobbyWithCode();
                }
            });
        }

        // Global keyboard support for typing lobby codes
        document.addEventListener('keydown', (e) => {
            if (gameState === 'join-lobby') {
                const key = e.key.toUpperCase();
                if (key === 'BACKSPACE') {
                    lobbyCodeInput = lobbyCodeInput.slice(0, -1);
                    lobbyJoinError = '';
                    e.preventDefault();
                } else if (key === 'ENTER' && lobbyCodeInput.length === 6) {
                    joinLobbyWithCode();
                    e.preventDefault();
                } else if (/^[A-Z]$/.test(key) && lobbyCodeInput.length < 6) {
                    lobbyCodeInput += key;
                    lobbyJoinError = '';
                    e.preventDefault();
                }
            }
        });

        // Spawn entity - uses seeded random for multiplayer synchronization
        // Progressive difficulty based on score thresholds:
        // 0-1999: Single obstacles only, single banana
        // 2000-2999: Single or double obstacles, single banana
        // 3000-3999: 1-3 obstacles, single banana
        // 4000-4999: Animals appear (50% chance), single banana
        // 5000+: Banana bundles (50% chance, worth 300), animals continue
        // Power-ups: Jetpack appears rarely (~once per 3000 point run)
        function spawn() {
            const land = lands[selectedLand];
            jetpackSpawnCounter++;

            // Check for power-up spawn (rare, but guaranteed eventually)
            // Starts having a chance after 25 spawns, increases each spawn
            // By spawn 50, it's almost guaranteed if not already spawned
            const powerUpChance = Math.max(0, (jetpackSpawnCounter - 25) * 0.02); // 0% at 25, 2% at 26, 50% at 50
            const noPowerUpActive = !jetpackActive && !trexActive;
            const shouldSpawnPowerUp = noPowerUpActive && getRandom() < powerUpChance;

            if (shouldSpawnPowerUp) {
                // Alternate between jetpack and T-Rex
                const powerUpType = lastPowerUpType === 'jetpack' ? 'trex' : 'jetpack';
                lastPowerUpType = powerUpType;

                if (powerUpType === 'jetpack') {
                    // Spawn jetpack power-up
                    const pixels = sprites.jetpack;
                    const scale = ENTITY_SCALE;
                    const h = pixels.length * scale;
                    entities.push({
                        x: canvas.width + 20,
                        y: getGroundLevel() - h - BANANA_HEIGHT_OFFSET - 20, // Float a bit higher
                        pixels: pixels,
                        scale: scale,
                        colors: colors.jetpack,
                        type: 'powerup',
                        powerupType: 'jetpack',
                        vx: 0
                    });
                } else {
                    // Spawn T-Rex power-up
                    const pixels = sprites.trexPowerUp;
                    const scale = ENTITY_SCALE;
                    const h = pixels.length * scale;
                    entities.push({
                        x: canvas.width + 20,
                        y: getGroundLevel() - h - BANANA_HEIGHT_OFFSET - 20, // Float a bit higher
                        pixels: pixels,
                        scale: scale,
                        colors: colors.trexPowerUp,
                        type: 'powerup',
                        powerupType: 'trex',
                        vx: 0
                    });
                }
                jetpackSpawnCounter = 0; // Reset counter after spawning
                return; // Don't spawn anything else this cycle
            }

            const isBanana = getRandom() < 0.35;

            if (isBanana) {
                // At 5000+, 50% chance of banana bundle (worth 300)
                const useBundle = score >= 5000 && getRandom() < 0.5;

                if (useBundle) {
                    // Spawn banana bundle (double value)
                    const pixels = sprites.bananaBundle;
                    const scale = ENTITY_SCALE;
                    const h = pixels.length * scale;
                    entities.push({
                        x: canvas.width + 20,
                        y: getGroundLevel() - h - BANANA_HEIGHT_OFFSET,
                        pixels: pixels,
                        scale: scale,
                        colors: colors.banana, // Same colors as single banana
                        type: 'banana',
                        isBundle: true,
                        bananaValue: 2, // Worth 2 bananas (300 points)
                        vx: 0
                    });
                } else {
                    // Spawn single banana
                    const pixels = sprites.banana;
                    const scale = ENTITY_SCALE;
                    const h = pixels.length * scale;
                    entities.push({
                        x: canvas.width + 20,
                        y: getGroundLevel() - h - BANANA_HEIGHT_OFFSET,
                        pixels: pixels,
                        scale: scale,
                        colors: colors.banana,
                        type: 'banana',
                        isBundle: false,
                        bananaValue: 1, // Worth 1 banana (150 points)
                        vx: 0
                    });
                }
            } else {
                // Obstacle spawning with progressive difficulty
                // At 4000+ points, mix in animal obstacles (50% chance)
                const useAnimal = score >= 4000 && getRandom() < 0.5 && land.animalObstacle;

                if (useAnimal) {
                    // Animal obstacles are double-wide, spawn as single unit
                    const pixels = land.animalObstacle;
                    const scale = ENTITY_SCALE;
                    const h = pixels.length * scale;
                    const currentSpawnId = spawnIdCounter++;

                    entities.push({
                        x: canvas.width + 20,
                        y: getGroundLevel() - h,
                        pixels: pixels,
                        scale: scale,
                        colors: land.animalObstacleColors,
                        type: 'obstacle',
                        isAnimal: true,
                        obstacleCount: 2, // Worth 2 obstacles for jump bonus
                        spawnId: currentSpawnId,
                        vx: 0
                    });
                } else {
                    // Determine max obstacles based on score (progressive difficulty)
                    let maxObstacles;
                    if (score < 2000) {
                        maxObstacles = 1; // Only single obstacles
                    } else if (score < 3000) {
                        maxObstacles = 2; // Single or double (50/50)
                    } else {
                        maxObstacles = 3; // Full range 1-3
                    }

                    // Random obstacle count up to max
                    const obstacleCount = Math.floor(getRandom() * maxObstacles) + 1;
                    const pixels = land.obstacle;
                    const scale = ENTITY_SCALE;
                    const w = pixels[0].length * scale;
                    const h = pixels.length * scale;
                    const gap = 4; // Small gap between obstacles
                    const currentSpawnId = spawnIdCounter++;

                    for (let i = 0; i < obstacleCount; i++) {
                        entities.push({
                            x: canvas.width + 20 + (i * (w + gap)),
                            y: getGroundLevel() - h,
                            pixels: pixels,
                            scale: scale,
                            colors: land.obstacleColors,
                            type: 'obstacle',
                            isAnimal: false,
                            obstacleCount: obstacleCount, // Track how many in this group
                            groupIndex: i, // Which one in the group
                            spawnId: currentSpawnId, // Same ID for all in group
                            vx: 0
                        });
                    }
                }
            }
        }

        // Next spawn threshold (calculated deterministically for multiplayer sync)
        let nextSpawnThreshold = 400;

        // Start/restart game
        function startGame() {
            gameState = 'playing';
            score = 0;
            bananasCollected = 0;
            gameTime = 0;
            speed = 6;
            spawnCounter = 0;
            scrollOffset = 0;
            entities = [];
            clearParticles(); // Clear any leftover particles
            clearFloatingTexts(); // Clear floating score texts
            obstaclesJumpedOver = new Set(); // Reset jump tracking
            spawnIdCounter = 0; // Reset spawn ID counter
            jumpBonusScore = 0; // Reset jump bonus
            // Reset jetpack state
            jetpackActive = false;
            jetpackTimer = 0;
            jetpackPhase = 'none';
            jetpackSpawnCounter = 0;
            powerUpBonusScore = 0;
            // Reset T-Rex state
            trexActive = false;
            trexTimer = 0;
            // Reset session stats
            sessionJetpacksCollected = 0;
            sessionDinoStompsCollected = 0;
            sessionGameDuration = 0;
            player.y = player.groundY;
            player.vy = 0;
            player.jumping = false;
            jumpBufferTime = 0;
            jumpHeld = false;
            scoreSaved = false;
            // Reset announcement state
            clearAnnouncement();
            highestLevelReached = 0; // Reset highest level for this game
            // Show "[LAND] STAGE" then "LEVEL ZERO" at game start
            const land = lands[selectedLand];
            if (land && land.name) {
                queueAnnouncements([
                    `${land.name.toUpperCase()} STAGE`,
                    'LEVEL ZERO'
                ]);
                lastAnnouncedLevel = 0; // Mark level 0 as announced
            }
            // Calculate first spawn threshold deterministically
            nextSpawnThreshold = 280 + getRandom() * 220;
        }

        // Update game logic
        function update() {
            if (gameState !== 'playing') return;

            gameTime++;
            speed += 0.0007; // Gradually increase speed (reduced from 0.001)
            spawnCounter += speed;

            // Update announcements
            updateAnnouncement();
            checkLevelAnnouncement();

            // Spawn logic (deterministic spacing for multiplayer sync)
            if (spawnCounter > nextSpawnThreshold) {
                spawn();
                spawnCounter = 0;
                // Calculate next threshold using seeded random
                nextSpawnThreshold = 280 + getRandom() * 220;
            }

            // Jetpack flight mechanics (overrides normal physics when active)
            if (jetpackActive) {
                jetpackTimer--;

                if (jetpackPhase === 'rising') {
                    // Rocket up quickly
                    player.y -= JETPACK_RISE_SPEED;
                    // Spawn thrust particles
                    if (gameTime % 2 === 0) {
                        spawnJetpackParticles(player.x + PLAYER_WIDTH / 2, player.y + PLAYER_HEIGHT);
                    }
                    // Check if reached target height
                    if (player.y <= jetpackTargetY) {
                        player.y = jetpackTargetY;
                        jetpackPhase = 'peak';
                    }
                } else if (jetpackPhase === 'peak') {
                    // Hover at peak for a moment, then start descending
                    // Spawn occasional thrust particles
                    if (gameTime % 4 === 0) {
                        spawnJetpackParticles(player.x + PLAYER_WIDTH / 2, player.y + PLAYER_HEIGHT);
                    }
                    // After 1/3 of time, start descending slowly
                    if (jetpackTimer < JETPACK_DURATION * 0.6) {
                        jetpackPhase = 'descending';
                    }
                } else if (jetpackPhase === 'descending') {
                    // Slowly descend but stay above obstacles
                    player.y += JETPACK_DESCEND_SPEED;
                    // Spawn occasional thrust particles
                    if (gameTime % 6 === 0) {
                        spawnJetpackParticles(player.x + PLAYER_WIDTH / 2, player.y + PLAYER_HEIGHT);
                    }
                    // Don't go below a safe height above obstacles
                    const safeHeight = player.groundY - 60; // Stay 60px above ground
                    if (player.y > safeHeight) {
                        player.y = safeHeight;
                    }
                }

                // Check if jetpack time is up or player initiated drop
                if (jetpackTimer <= 0) {
                    // End jetpack - drop back to ground
                    jetpackActive = false;
                    jetpackPhase = 'none';
                    player.jumping = true;
                    player.vy = 2; // Start falling
                }
            } else if (trexActive) {
                // T-Rex mechanics - stay on ground and stomp through obstacles
                trexTimer--;

                // Keep player locked to ground
                player.y = player.groundY;
                player.vy = 0;
                player.jumping = false;

                // Spawn dust particles occasionally (stomp effect)
                if (gameTime % 8 === 0) {
                    for (let i = 0; i < 2; i++) {
                        particles.push({
                            x: player.x + PLAYER_WIDTH / 2 + (Math.random() - 0.5) * 40,
                            y: player.groundY + PLAYER_HEIGHT - 5,
                            vx: (Math.random() - 0.5) * 3,
                            vy: -1 - Math.random() * 2,
                            life: 0,
                            color: ['#8D6E63', '#A1887F', '#BCAAA4'][Math.floor(Math.random() * 3)], // Brown dust
                            size: 4 + Math.random() * 4,
                            maxLife: 20
                        });
                    }
                }

                // Check if T-Rex time is up
                if (trexTimer <= 0) {
                    // End T-Rex mode - transform back to normal
                    trexActive = false;
                }
            } else if (player.jumping) {
                // Normal player physics with variable jump height
                // Base gravity
                let gravity = 0.8;

                // Apply extra gravity when:
                // - Falling (vy > 0), OR
                // - Rising but button released (for snappy short hops)
                if (player.vy > 0 || !jumpHeld) {
                    gravity *= FALL_GRAVITY_MULTIPLIER;
                }

                player.vy += gravity;
                player.y += player.vy;

                // Ceiling collision - prevent going above minimum margin
                if (player.y < MIN_CEILING_MARGIN) {
                    player.y = MIN_CEILING_MARGIN;
                    player.vy = 0;  // Stop upward momentum, start falling
                }

                // Ground collision
                if (player.y >= player.groundY) {
                    player.y = player.groundY;
                    player.jumping = false;
                    player.vy = 0;
                    jumpHeld = false;  // Reset held state on landing

                    // Check for buffered jump - if player pressed jump recently, jump again
                    if (jumpBufferTime > 0 && (Date.now() - jumpBufferTime) < JUMP_BUFFER_MS) {
                        player.vy = getJumpVelocity();
                        player.jumping = true;
                        jumpHeld = true;  // Assume held for buffered jump
                        jumpBufferTime = 0;
                    }
                }
            }

            // Update entities
            for (let i = entities.length - 1; i >= 0; i--) {
                const ent = entities[i];
                ent.x -= speed;

                // Remove off-screen entities
                const entW = ent.pixels[0].length * ent.scale;
                if (ent.x + entW < -50) {
                    entities.splice(i, 1);
                    continue;
                }

                // Collision detection - skip if player is a ghost in multiplayer
                if (gameMode === 'multiplayer' && !localPlayerAlive) {
                    continue;  // Ghost mode - no collisions
                }

                const pRight = player.x + PLAYER_WIDTH;
                const pBottom = player.y + PLAYER_HEIGHT;
                const eRight = ent.x + (ent.pixels[0].length * ent.scale);
                const eBottom = ent.y + (ent.pixels.length * ent.scale);

                if (player.x < eRight &&
                    pRight > ent.x &&
                    player.y < eBottom &&
                    pBottom > ent.y) {

                    if (ent.type === 'obstacle') {
                        // Skip obstacle collision when jetpack is active (player is flying high)
                        // or when T-Rex is active (stomp through obstacles)
                        if (jetpackActive || trexActive) {
                            continue;
                        }
                        if (gameMode === 'multiplayer') {
                            // In multiplayer: become a ghost, don't end game
                            localPlayerAlive = false;

                            // Update local player state
                            if (allPlayersStates[currentUser?.id]) {
                                allPlayersStates[currentUser.id].isAlive = false;
                                allPlayersStates[currentUser.id].score = score;
                                allPlayersStates[currentUser.id].bananas = bananasCollected;
                            }

                            // Broadcast death immediately
                            broadcastPlayerState();

                            // Check if all players dead
                            checkRoundOver();
                        } else {
                            // Solo mode: game over as before
                            gameState = 'gameover';

                            // Fetch game over stats (before saving so we compare against previous bests)
                            fetchGameOverStats(score, selectedLand);

                            // Save score if logged in and not already saved
                            if (!scoreSaved && currentUser) {
                                scoreSaved = true;
                                const gameTimeSeconds = Math.floor(gameTime / 60);

                                // Wait for score to save, then check achievements
                                saveScore(score, bananasCollected, selectedLand).then(() => {
                                    checkAchievements(score, bananasCollected, gameTimeSeconds, false, false);
                                });
                            }
                        }
                    } else if (ent.type === 'banana') {
                        // Banana collection - only if alive
                        if (gameMode !== 'multiplayer' || localPlayerAlive) {
                            // Get banana value (1 for single, 2 for bundle)
                            const bananaValue = ent.bananaValue || 1;
                            bananasCollected += bananaValue;
                            // Show floating text (+150 for single, +300 for bundle)
                            const pointsGained = bananaValue * 150;
                            spawnFloatingText(player.x + PLAYER_WIDTH / 2, player.y - 10, `+${pointsGained}`);
                            entities.splice(i, 1);
                            // Debug log for multiplayer
                            if (gameMode === 'multiplayer') {
                                console.log(`[Banana] Collected! Value: ${bananaValue}, Total: ${bananasCollected}, Score: ${score}`);
                            }
                        }
                    } else if (ent.type === 'powerup') {
                        // Power-up collection
                        if (gameMode !== 'multiplayer' || localPlayerAlive) {
                            if (ent.powerupType === 'jetpack' && !jetpackActive && !trexActive) {
                                // Activate jetpack!
                                jetpackActive = true;
                                jetpackTimer = JETPACK_DURATION;
                                jetpackPhase = 'rising';
                                jetpackOriginalY = player.groundY;
                                jetpackTargetY = player.groundY - JETPACK_FLY_HEIGHT;
                                player.jumping = false; // Cancel any current jump
                                player.vy = 0;

                                // Track jetpack collection
                                sessionJetpacksCollected++;

                                // Award bonus points
                                powerUpBonusScore += 100;
                                spawnFloatingText(player.x + PLAYER_WIDTH / 2, player.y - 10, '+100');

                                // Announce power-up
                                triggerAnnouncement('JETPACK');

                                entities.splice(i, 1);
                            } else if (ent.powerupType === 'trex' && !trexActive && !jetpackActive) {
                                // Activate T-Rex!
                                trexActive = true;
                                trexTimer = TREX_DURATION;
                                player.jumping = false; // Cancel any current jump
                                player.y = player.groundY; // Lock to ground
                                player.vy = 0;

                                // Track dino stomp collection
                                sessionDinoStompsCollected++;

                                // Award bonus points
                                powerUpBonusScore += 100;
                                spawnFloatingText(player.x + PLAYER_WIDTH / 2, player.y - 10, '+100');

                                // Announce power-up
                                triggerAnnouncement('DINO-STOMP');

                                entities.splice(i, 1);
                            }
                        }
                    }
                }
            }

            // Jump bonus detection - award points for successfully jumping over obstacles
            if (gameMode !== 'multiplayer' || localPlayerAlive) {
                for (let i = 0; i < entities.length; i++) {
                    const ent = entities[i];
                    if (ent.type !== 'obstacle') continue;
                    if (ent.spawnId === undefined) continue;

                    // Calculate obstacle dimensions
                    const eRight = ent.x + (ent.pixels[0].length * ent.scale);

                    // Check if player has passed this obstacle (player left > obstacle right)
                    if (player.x > eRight && !obstaclesJumpedOver.has(ent.spawnId)) {
                        // Award bonus based on obstacle count (+10 per obstacle unit)
                        const bonus = ent.obstacleCount * 10;
                        jumpBonusScore += bonus;
                        obstaclesJumpedOver.add(ent.spawnId);

                        // Show floating text above player
                        const bonusText = `+${bonus}`;
                        spawnFloatingText(player.x + PLAYER_WIDTH / 2, player.y - 30, bonusText);
                    }
                }
            }

            // Update score (time survived + banana bonuses + jump bonuses) - but freeze on death in multiplayer
            if (gameMode !== 'multiplayer' || localPlayerAlive) {
                score = Math.floor(gameTime / 6) + (bananasCollected * 150) + jumpBonusScore + powerUpBonusScore;
            }

            scrollOffset = (scrollOffset + speed) % 40;

            // Update and broadcast game state in multiplayer (every 5 frames = ~12 updates/sec for smoother sync)
            if (gameMode === 'multiplayer' && gameTime % 5 === 0) {
                // Update local player state in shared state before broadcasting
                if (currentUser?.id && allPlayersStates[currentUser.id]) {
                    // Store yOffset for consistency (though local rendering uses player.y directly)
                    allPlayersStates[currentUser.id].yOffset = player ? (player.y - player.groundY) : 0;
                    allPlayersStates[currentUser.id].score = score;
                    allPlayersStates[currentUser.id].bananas = bananasCollected;
                    allPlayersStates[currentUser.id].isAlive = localPlayerAlive;
                }
                broadcastPlayerState();
            }

            // Update particle effects
            updateParticles();
            updateSkinEffects();
            updateFloatingTexts();
        }

        // Draw menu action buttons
        function drawMenuButtons(buttons, startY) {
            const btnWidth = 200;
            const btnHeight = 50;
            const gap = 15;

            menuButtons = [];

            buttons.forEach((btn, i) => {
                const x = (canvas.width - btnWidth) / 2;
                const y = startY + i * (btnHeight + gap);

                menuButtons.push({ x, y, w: btnWidth, h: btnHeight, action: btn.action });

                // Draw button background
                ctx.fillStyle = btn.primary ? '#FFE135' : '#333';
                ctx.fillRect(x, y, btnWidth, btnHeight);

                // Draw border
                ctx.strokeStyle = btn.primary ? '#FFC107' : '#555';
                ctx.lineWidth = 2;
                ctx.strokeRect(x, y, btnWidth, btnHeight);

                // Draw text
                ctx.fillStyle = btn.primary ? '#000' : '#FFF';
                ctx.font = 'bold 18px monospace';
                ctx.textAlign = 'center';
                ctx.fillText(btn.label, x + btnWidth / 2, y + btnHeight / 2 + 6);
            });
        }

        // Draw back button (top right corner) - unified across screens
        let backButton = null;
        function drawBackButton(targetState = 'menu') {
            const btnWidth = 80;
            const btnHeight = 40;
            const x = canvas.width - btnWidth - 20;
            const y = 20;

            // Store for click detection
            backButton = { x, y, w: btnWidth, h: btnHeight, action: () => { gameState = targetState; } };

            // Draw button with rounded corners
            ctx.fillStyle = '#333';
            ctx.beginPath();
            ctx.roundRect(x, y, btnWidth, btnHeight, 8);
            ctx.fill();

            // Border
            ctx.strokeStyle = '#555';
            ctx.lineWidth = 2;
            ctx.stroke();

            // Arrow and text
            ctx.fillStyle = '#FFF';
            ctx.font = 'bold 16px monospace';
            ctx.textAlign = 'center';
            ctx.fillText('â† Back', x + btnWidth / 2, y + btnHeight / 2 + 5);

            return backButton;
        }

        // Draw land selection buttons
        function drawLandButtons(startY, showChangeText) {
            const landKeys = Object.keys(lands);
            // Responsive button sizes
            const btnWidth = Math.min(120, Math.round((canvas.width - DS.spacing.xl * 2) / landKeys.length - DS.spacing.sm));
            const btnHeight = Math.max(44, Math.round(canvas.width * 0.055));
            const gap = DS.spacing.sm;
            const totalWidth = landKeys.length * btnWidth + (landKeys.length - 1) * gap;
            const startX = (canvas.width - totalWidth) / 2;

            landButtons = [];

            landKeys.forEach((key, i) => {
                const land = lands[key];
                const x = startX + i * (btnWidth + gap);
                const y = startY;
                const isSelected = key === selectedLand;

                // Store button for click detection
                landButtons.push({ x, y, w: btnWidth, h: btnHeight, land: key });

                // Draw button with rounded corners
                ctx.fillStyle = isSelected ? land.ground : DS.colors.locked;
                ctx.beginPath();
                ctx.roundRect(x, y, btnWidth, btnHeight, DS.button.radius);
                ctx.fill();

                // Draw border
                ctx.strokeStyle = isSelected ? DS.colors.white : DS.colors.textMuted;
                ctx.lineWidth = isSelected ? 3 : 2;
                ctx.stroke();

                // Draw text
                ctx.fillStyle = DS.colors.white;
                ctx.font = DS.font('small', 'bold');
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(land.name, x + btnWidth / 2, y + btnHeight / 2);
            });

            if (showChangeText) {
                ctx.fillStyle = DS.colors.textSecondary;
                ctx.font = DS.font('tiny');
                ctx.textAlign = 'center';
                ctx.fillText('Tap a land to change, or tap anywhere to play', canvas.width / 2, startY + btnHeight + DS.spacing.lg);
            }
        }

        // Draw everything
        function draw() {
            const land = lands[selectedLand];
            const groundY = getGroundLevel();

            // Clear canvas
            ctx.fillStyle = '#FAFAFA';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw sky gradient with land colors
            const grad = ctx.createLinearGradient(0, 0, 0, groundY);
            grad.addColorStop(0, land.skyTop);
            grad.addColorStop(1, land.skyBottom);
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, canvas.width, groundY);

            // Draw scrolling ground with land colors
            ctx.fillStyle = land.ground;
            ctx.fillRect(0, groundY, canvas.width, canvas.height - groundY);

            // Draw ground bumps/dots (scrolling)
            ctx.fillStyle = land.groundAccent;
            let bumpX = (-scrollOffset) % 40;
            for (let i = 0; i < canvas.width / 20 + 3; i++) {
                const x = bumpX + (i * 40);
                ctx.fillRect(x, groundY - 4, 20, 8);
                ctx.fillRect(x + 22, groundY, 8, 8);
            }

            if (gameState === 'welcome') {
                // Welcome/Landing screen - shown before login
                resetClickables();
                ctx.fillStyle = DS.colors.bgOverlay;
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                const centerX = canvas.width / 2;

                // Compact mode for small screens
                const isCompact = canvas.height < 600;

                let y = isCompact ? DS.spacing.lg : DS.spacing.xxl;

                // Title with banana logo on left - smaller on compact
                const titleSize = isCompact ? 'h2' : 'h1';
                const bananaScale = isCompact ? Math.max(1, Math.round(canvas.width / 500)) : Math.max(2, Math.round(canvas.width / 400));
                const bananaWidth = sprites.banana[0].length * bananaScale;
                const bananaHeight = sprites.banana.length * bananaScale;

                ctx.font = DS.font(titleSize, 'bold');
                const titleWidth = ctx.measureText('BANANA RUNNER').width;
                const logoGap = isCompact ? DS.spacing.sm : DS.spacing.md;
                const totalWidth = bananaWidth + logoGap + titleWidth;
                const startX = centerX - totalWidth / 2;

                // Draw banana logo
                const logoY = y + (DS.fontSize(titleSize) - bananaHeight) / 2;
                drawSprite(ctx, startX, logoY, sprites.banana, bananaScale, colors.banana);

                // Draw title text
                ctx.textAlign = 'left';
                ctx.fillStyle = DS.colors.primary;
                ctx.fillText('BANANA RUNNER', startX + bananaWidth + logoGap, y + DS.fontSize(titleSize));
                ctx.textAlign = 'center'; // Reset for other elements
                y += DS.fontSize(titleSize) + (isCompact ? DS.spacing.md : DS.spacing.lg);

                // Tagline
                ctx.fillStyle = DS.colors.textPrimary;
                ctx.font = DS.font(isCompact ? 'body' : 'h3');
                ctx.fillText('An endless runner adventure!', centerX, y);
                y += DS.fontSize(isCompact ? 'body' : 'h3') + (isCompact ? DS.spacing.md : DS.spacing.xl);

                // Features panel - condensed on compact
                if (!isCompact) {
                    const panelWidth = Math.min(500, canvas.width - DS.spacing.xl * 2);
                    const panelHeight = DS.fontSize('body') * 4 + DS.spacing.lg * 2;
                    drawPanel(centerX, y, panelWidth, panelHeight, { centered: true });

                    ctx.fillStyle = DS.colors.textSecondary;
                    ctx.font = DS.font('body');
                    const featureY = y + DS.spacing.lg + DS.fontSize('body');
                    ctx.fillText('Jump over obstacles & collect bananas', centerX, featureY);
                    ctx.fillText('Compete in multiplayer battles', centerX, featureY + DS.fontSize('body') + DS.spacing.sm);
                    ctx.fillText('Unlock achievements & climb ranks', centerX, featureY + (DS.fontSize('body') + DS.spacing.sm) * 2);
                    y += panelHeight + DS.spacing.xl;
                }

                // Feature highlights
                ctx.fillStyle = DS.colors.primary;
                ctx.font = DS.font('small', 'bold');
                ctx.fillText('4 LANDS  â€¢  MULTIPLAYER  â€¢  LEADERBOARDS', centerX, y);
                y += DS.fontSize('small') + (isCompact ? DS.spacing.lg : DS.spacing.xxl);

                // Login button - smaller on compact
                const btnWidth = Math.min(isCompact ? 220 : 280, canvas.width - DS.spacing.lg * 2);
                const btnHeight = isCompact ? Math.max(44, DS.button.height() * 0.85) : DS.button.height();
                const btnBounds = drawStyledButton(centerX, y, btnWidth, btnHeight, 'GET STARTED', { action: 'login', primary: true });
                addClickable(btnBounds);

                // Footer - only if room
                if (canvas.height - y - btnHeight > 50) {
                    ctx.fillStyle = DS.colors.textMuted;
                    ctx.font = DS.font('small');
                    ctx.fillText('Create an account to save progress', centerX, canvas.height - DS.spacing.md);
                }

            } else if (gameState === 'menu') {
                // Menu screen - shown after login
                resetClickables();
                ctx.fillStyle = DS.colors.bgOverlayLight;
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                const centerX = canvas.width / 2;

                // Compact mode for small screens
                const isCompact = canvas.height < 600;
                const compactSpacing = isCompact ? DS.spacing.sm : DS.spacing.md;
                const compactLgSpacing = isCompact ? DS.spacing.md : DS.spacing.lg;

                let y = isCompact ? DS.spacing.md : DS.spacing.xl;

                // Title with banana logo on left - smaller on compact screens
                const titleSize = isCompact ? 'h2' : 'h1';
                const bananaScale = isCompact ? Math.max(1, Math.round(canvas.width / 500)) : Math.max(2, Math.round(canvas.width / 400));
                const bananaWidth = sprites.banana[0].length * bananaScale;
                const bananaHeight = sprites.banana.length * bananaScale;

                ctx.font = DS.font(titleSize, 'bold');
                const titleWidth = ctx.measureText('BANANA RUNNER').width;
                const logoGap = isCompact ? DS.spacing.sm : DS.spacing.md;
                const logoTotalWidth = bananaWidth + logoGap + titleWidth;
                const startX = centerX - logoTotalWidth / 2;

                // Draw banana logo
                const logoY = y + (DS.fontSize(titleSize) - bananaHeight) / 2;
                drawSprite(ctx, startX, logoY, sprites.banana, bananaScale, colors.banana);

                // Draw title text
                ctx.textAlign = 'left';
                ctx.fillStyle = DS.colors.white;
                ctx.fillText('BANANA RUNNER', startX + bananaWidth + logoGap, y + DS.fontSize(titleSize));
                ctx.textAlign = 'center'; // Reset for other elements
                y += DS.fontSize(titleSize) + compactLgSpacing;

                // User stats panel - condensed on compact
                if (userProfile) {
                    const statsPanelWidth = Math.min(isCompact ? 320 : 420, canvas.width - DS.spacing.lg * 2);
                    const statsFont = isCompact ? 'small' : 'body';
                    const statsPanelHeight = isCompact
                        ? DS.fontSize('small') * 2.5 + DS.spacing.md * 2
                        : DS.fontSize('body') * 3 + DS.spacing.lg * 2;
                    drawPanel(centerX, y, statsPanelWidth, statsPanelHeight, { centered: true });

                    const statsY = y + (isCompact ? DS.spacing.md : DS.spacing.lg) + DS.fontSize(statsFont) / 2;
                    ctx.fillStyle = DS.colors.primary;
                    ctx.font = DS.font(statsFont, 'bold');
                    ctx.fillText(`${userProfile.username || 'Player'}  â€¢  High: ${userProfile.high_score || 0}`, centerX, statsY);

                    if (!isCompact) {
                        ctx.fillStyle = DS.colors.white;
                        ctx.font = DS.font('body');
                        ctx.fillText(`High Score: ${userProfile.high_score || 0}`, centerX, statsY + DS.fontSize('body') + DS.spacing.xs);
                    }

                    ctx.fillStyle = DS.colors.textSecondary;
                    ctx.font = DS.font('small');
                    const statsLine2Y = isCompact ? statsY + DS.fontSize('small') + DS.spacing.xs : statsY + (DS.fontSize('body') + DS.spacing.xs) * 2;
                    ctx.fillText(`${spendableBananas} ðŸŒ to spend  |  ${userProfile.total_games || 0} games`, centerX, statsLine2Y);
                    y += statsPanelHeight + compactLgSpacing;
                }

                // Land selection
                y = drawSectionTitle('SELECT LAND', y);
                const landBtnHeight = isCompact ? 40 : 50;
                drawLandButtons(y, false);
                y += landBtnHeight + compactLgSpacing;

                // Two-column menu layout
                // Left: Solo Play, Multiplayer | Right: Shop, Achievements, Leaderboard
                const totalWidth = Math.min(isCompact ? 400 : 500, canvas.width - DS.spacing.lg * 2);
                const columnGap = isCompact ? DS.spacing.sm : DS.spacing.md;
                const columnWidth = (totalWidth - columnGap) / 2;
                const btnHeight = isCompact ? Math.max(40, DS.button.height() * 0.8) : DS.button.height();
                const gap = isCompact ? DS.spacing.sm : DS.spacing.md;
                const leftX = centerX - totalWidth / 2 + columnWidth / 2;
                const rightX = centerX + columnGap / 2 + columnWidth / 2;

                // Section labels
                ctx.fillStyle = DS.colors.textMuted;
                ctx.font = DS.font('tiny', 'bold');
                ctx.textAlign = 'center';
                ctx.fillText('PLAY', leftX, y);
                ctx.fillText('EXPLORE', rightX, y);
                y += DS.fontSize('tiny') + DS.spacing.xs;

                // Left column - Play modes
                const leftColumnY = y;
                const soloBounds = drawStyledButton(leftX, leftColumnY, columnWidth, btnHeight, 'SOLO', { action: 'solo', primary: true });
                addClickable(soloBounds);

                const multiBounds = drawStyledButton(leftX, leftColumnY + btnHeight + gap, columnWidth, btnHeight, 'MULTI', { action: 'multiplayer', primary: false });
                addClickable(multiBounds);

                // Right column - Explore options
                const rightColumnY = y;
                const shopBounds = drawStyledButton(rightX, rightColumnY, columnWidth, btnHeight, 'SHOP', { action: 'shop', primary: false });
                addClickable(shopBounds);

                const achieveBounds = drawStyledButton(rightX, rightColumnY + btnHeight + gap, columnWidth, btnHeight, 'ACHIEVE', { action: 'achievements', primary: false });
                addClickable(achieveBounds);

                const leaderBounds = drawStyledButton(rightX, rightColumnY + (btnHeight + gap) * 2, columnWidth, btnHeight, 'RANK', { action: 'leaderboard', primary: false });
                addClickable(leaderBounds);

                // Advance y to bottom of taller column
                y += Math.max((btnHeight + gap) * 2, (btnHeight + gap) * 3);

                // Instructions - only show if there's room
                if (canvas.height - y > 60) {
                    ctx.fillStyle = DS.colors.textMuted;
                    ctx.font = DS.font('small');
                    ctx.fillText('Press SPACE or tap to jump!', centerX, canvas.height - DS.spacing.md);
                }

            } else if (gameState === 'leaderboard') {
                // Leaderboard screen
                resetClickables();
                ctx.fillStyle = DS.colors.bgOverlay;
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // Header with back button
                const header = drawHeader('LEADERBOARD', true);
                addClickable(header.backBounds);

                const centerX = canvas.width / 2;
                let contentY = header.height + DS.spacing.lg;

                if (loadingLeaderboard) {
                    ctx.fillStyle = DS.colors.textSecondary;
                    ctx.font = DS.font('h3');
                    ctx.textAlign = 'center';
                    ctx.fillText('Loading...', centerX, canvas.height / 2);
                } else if (leaderboardData.length === 0) {
                    ctx.fillStyle = DS.colors.textSecondary;
                    ctx.font = DS.font('body');
                    ctx.textAlign = 'center';
                    ctx.fillText('No scores yet!', centerX, canvas.height / 2 - DS.spacing.md);
                    ctx.fillText('Be the first to play!', centerX, canvas.height / 2 + DS.spacing.md);
                } else {
                    // Draw leaderboard panel
                    const panelWidth = Math.min(500, canvas.width - DS.spacing.lg * 2);
                    const rowHeight = Math.max(36, DS.fontSize('body') + DS.spacing.md);
                    const panelHeight = rowHeight * (leaderboardData.length + 1) + DS.spacing.lg * 2;
                    const panelX = centerX - panelWidth / 2;

                    drawPanel(panelX, contentY, panelWidth, panelHeight);

                    // Table header
                    const tableY = contentY + DS.spacing.lg;
                    const colRank = panelX + DS.spacing.lg;
                    const colPlayer = panelX + DS.spacing.xl * 2;
                    const colScore = panelX + panelWidth - DS.spacing.lg;

                    ctx.fillStyle = DS.colors.textMuted;
                    ctx.font = DS.font('small', 'bold');
                    ctx.textAlign = 'left';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('RANK', colRank, tableY + rowHeight / 2);
                    ctx.fillText('PLAYER', colPlayer, tableY + rowHeight / 2);
                    ctx.textAlign = 'right';
                    ctx.fillText('SCORE', colScore, tableY + rowHeight / 2);

                    // Draw entries
                    leaderboardData.forEach((entry, i) => {
                        const y = tableY + (i + 1) * rowHeight + rowHeight / 2;
                        const isCurrentUser = currentUser && entry.player_id === currentUser.id;

                        ctx.fillStyle = isCurrentUser ? DS.colors.primary : DS.colors.white;
                        ctx.font = DS.font('body', isCurrentUser ? 'bold' : 'normal');

                        ctx.textAlign = 'left';
                        ctx.fillText(`#${i + 1}`, colRank, y);
                        ctx.fillText(entry.username || 'Anonymous', colPlayer, y);
                        ctx.textAlign = 'right';
                        ctx.fillText(entry.high_score?.toString() || '0', colScore, y);
                    });
                }

            } else if (gameState === 'shop') {
                // Shop screen - Browse and purchase skins
                resetClickables();
                ctx.fillStyle = DS.colors.bgOverlay;
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // Header with back button
                const header = drawHeader('BANANA SHOP', true);
                addClickable(header.backBounds);

                const centerX = canvas.width / 2;
                let contentY = header.height + DS.spacing.md;

                // Balance panel
                const balancePanelWidth = Math.min(280, canvas.width - DS.spacing.lg * 2);
                const balancePanelHeight = DS.fontSize('h3') + DS.spacing.lg;
                drawPanel(centerX - balancePanelWidth / 2, contentY, balancePanelWidth, balancePanelHeight);

                ctx.textAlign = 'center';
                ctx.fillStyle = DS.colors.primary;
                ctx.font = DS.font('h3', 'bold');
                ctx.fillText(`${spendableBananas} ðŸŒ to spend`, centerX, contentY + balancePanelHeight / 2 + DS.fontSize('h3') / 3);
                contentY += balancePanelHeight + DS.spacing.md;

                // Equipped skin indicator
                const equippedSkin = SKINS[selectedSkin];
                ctx.fillStyle = DS.colors.textSecondary;
                ctx.font = DS.font('small');
                ctx.fillText(`Equipped: ${equippedSkin?.name || 'Default'}`, centerX, contentY);
                contentY += DS.fontSize('small') + DS.spacing.md;

                // Skin cards - organized by tier with responsive grid
                const shopPadding = DS.spacing.sm;
                const cardGap = DS.spacing.xs;
                const availableWidth = canvas.width - shopPadding * 2;

                // Responsive: 2 columns if wide enough, otherwise 1
                const numCols = availableWidth >= 400 ? 2 : 1;
                const cardWidth = (availableWidth - (numCols - 1) * cardGap) / numCols;
                const cardHeight = 56;  // Compact height for better density

                // Group skins by tier
                const tierNames = {
                    0: 'DEFAULT',
                    1: 'ACHIEVEMENT SKINS (Free)',
                    2: 'BUDGET SKINS',
                    3: 'PREMIUM SKINS',
                    4: 'LEGENDARY SKINS'
                };
                const tierColors = {
                    0: DS.colors.textMuted,
                    1: DS.colors.success,
                    2: '#42A5F5',
                    3: DS.colors.primary,
                    4: '#FFD700'
                };

                // Build tier groups
                const tierGroups = {};
                Object.entries(SKINS).forEach(([skinId, skin]) => {
                    const tier = skin.tier ?? 0;
                    if (!tierGroups[tier]) tierGroups[tier] = [];
                    tierGroups[tier].push({ id: skinId, ...skin });
                });

                // Calculate scroll area
                const scrollAreaTop = contentY;
                const scrollAreaHeight = canvas.height - contentY - DS.spacing.md;
                const tierHeaderHeight = DS.fontSize('small') + DS.spacing.md;

                // First pass: calculate total content height (accounting for grid layout)
                let totalHeight = 0;
                [0, 1, 2, 3, 4].forEach(tier => {
                    const skins = tierGroups[tier];
                    if (!skins || skins.length === 0) return;
                    totalHeight += tierHeaderHeight;  // Tier header
                    const numRows = Math.ceil(skins.length / numCols);
                    totalHeight += numRows * (cardHeight + cardGap);  // Cards in grid rows
                    totalHeight += DS.spacing.sm;  // Tier spacing
                });

                // Set max scroll
                shopScrollMax = Math.max(0, totalHeight - scrollAreaHeight);

                // Clip to scroll area
                ctx.save();
                ctx.beginPath();
                ctx.rect(0, scrollAreaTop, canvas.width, scrollAreaHeight);
                ctx.clip();

                // Render skins by tier with scroll offset
                let currentY = scrollAreaTop - shopScrollY;

                [0, 1, 2, 3, 4].forEach(tier => {
                    const skins = tierGroups[tier];
                    if (!skins || skins.length === 0) return;

                    const headerY = currentY;
                    // Draw tier header (only if visible)
                    if (headerY + tierHeaderHeight > scrollAreaTop && headerY < scrollAreaTop + scrollAreaHeight) {
                        ctx.fillStyle = tierColors[tier] || DS.colors.textMuted;
                        ctx.font = DS.font('small', 'bold');
                        ctx.textAlign = 'left';
                        ctx.fillText(tierNames[tier] || `TIER ${tier}`, shopPadding, headerY + DS.fontSize('small'));
                    }
                    currentY += tierHeaderHeight;

                    // Draw skins in this tier using grid layout
                    skins.forEach((skin, idx) => {
                        const skinId = skin.id;
                        const row = Math.floor(idx / numCols);
                        const col = idx % numCols;
                        const cardX = shopPadding + col * (cardWidth + cardGap);
                        const cardY = currentY + row * (cardHeight + cardGap);

                        // Skip if off screen (with scroll)
                        if (cardY + cardHeight < scrollAreaTop || cardY > scrollAreaTop + scrollAreaHeight) return;

                        const isOwned = unlockedSkins.includes(skinId);
                        const isEquipped = selectedSkin === skinId;
                        const canAfford = skin.price ? spendableBananas >= skin.price : true;

                        // Draw card background
                        ctx.fillStyle = isEquipped ? DS.colors.bgPanel : DS.colors.bgDark;
                        ctx.beginPath();
                        ctx.roundRect(cardX, cardY, cardWidth, cardHeight, 6);
                        ctx.fill();

                        // Border with tier color
                        ctx.strokeStyle = isEquipped ? DS.colors.primary : (isOwned ? DS.colors.success : tierColors[tier] || DS.colors.textMuted);
                        ctx.lineWidth = isEquipped ? 2 : 1;
                        ctx.stroke();

                        // Compact layout: Color preview on left (square)
                        const previewSize = cardHeight - 8;
                        const previewX = cardX + 4;
                        const previewY = cardY + 4;
                        const swatchSize = previewSize / 3;

                        if (skin.transparency) {
                            ctx.globalAlpha = skin.transparency;
                        }
                        const overrides = skin.colorOverrides || {};
                        const previewColors = [overrides[4] || '#888', overrides[5] || '#666', overrides[6] || '#444'];
                        previewColors.forEach((color, ci) => {
                            ctx.fillStyle = color;
                            ctx.fillRect(previewX, previewY + ci * swatchSize, previewSize, swatchSize);
                        });
                        ctx.globalAlpha = 1;

                        // Compact: Name + badges on one line
                        const textX = previewX + previewSize + 6;
                        const textMaxWidth = cardWidth - previewSize - 70;  // Leave room for button
                        ctx.fillStyle = DS.colors.white;
                        ctx.font = DS.font('small', 'bold');
                        ctx.textAlign = 'left';

                        // Name with effect badge inline
                        let displayName = skin.name;
                        if (skin.effect) {
                            const effectIcons = { fire: 'ðŸ”¥', ice: 'â„ï¸', shadow: 'ðŸ‘¤', sparkle: 'âœ¨' };
                            displayName += ' ' + (effectIcons[skin.effect] || '');
                        }
                        if (skin.animated) displayName += ' ðŸŒˆ';
                        if (skin.transparency) displayName += ' ðŸ‘»';

                        ctx.fillText(displayName, textX, cardY + cardHeight / 2 + 4, textMaxWidth);

                        // Right side: Compact action button
                        const btnW = 50;
                        const btnH = 24;
                        const btnX = cardX + cardWidth - btnW - 4;
                        const btnY = cardY + (cardHeight - btnH) / 2;

                        if (isEquipped) {
                            ctx.fillStyle = DS.colors.primary;
                            ctx.font = DS.font('tiny', 'bold');
                            ctx.textAlign = 'center';
                            ctx.fillText('âœ“', btnX + btnW / 2, cardY + cardHeight / 2 + 4);
                        } else if (isOwned) {
                            ctx.fillStyle = DS.colors.success;
                            ctx.beginPath();
                            ctx.roundRect(btnX, btnY, btnW, btnH, 3);
                            ctx.fill();
                            ctx.fillStyle = DS.colors.white;
                            ctx.font = DS.font('tiny', 'bold');
                            ctx.textAlign = 'center';
                            ctx.fillText('USE', btnX + btnW / 2, btnY + btnH / 2 + 3);
                            addClickable({ x: btnX, y: btnY, w: btnW, h: btnH, action: `equip_${skinId}` });
                        } else if (skin.type === 'purchasable') {
                            ctx.fillStyle = canAfford ? DS.colors.primary : DS.colors.locked;
                            ctx.beginPath();
                            ctx.roundRect(btnX, btnY, btnW, btnH, 3);
                            ctx.fill();
                            ctx.fillStyle = canAfford ? DS.colors.bgDark : DS.colors.textMuted;
                            ctx.font = DS.font('tiny', 'bold');
                            ctx.textAlign = 'center';
                            ctx.fillText(`${skin.price}ðŸŒ`, btnX + btnW / 2, btnY + btnH / 2 + 3);
                            if (canAfford) {
                                addClickable({ x: btnX, y: btnY, w: btnW, h: btnH, action: `buy_${skinId}` });
                            }
                        } else if (skin.type === 'achievement') {
                            ctx.fillStyle = DS.colors.textMuted;
                            ctx.font = DS.font('tiny');
                            ctx.textAlign = 'center';
                            ctx.fillText('ðŸ”’', btnX + btnW / 2, cardY + cardHeight / 2 + 4);
                        }
                    });

                    // Advance Y by the number of rows in this tier
                    const numRows = Math.ceil(skins.length / numCols);
                    currentY += numRows * (cardHeight + cardGap);

                    // Add spacing between tiers
                    currentY += DS.spacing.sm;
                });

                // Restore clipping
                ctx.restore();

                // Draw scroll indicator if content is scrollable
                if (shopScrollMax > 0) {
                    const scrollTrackHeight = scrollAreaHeight - 20;
                    const scrollThumbHeight = Math.max(30, scrollTrackHeight * (scrollAreaHeight / totalHeight));
                    const scrollThumbY = scrollAreaTop + 10 + (shopScrollY / shopScrollMax) * (scrollTrackHeight - scrollThumbHeight);

                    // Track
                    ctx.fillStyle = 'rgba(255, 225, 53, 0.2)';
                    ctx.fillRect(canvas.width - 8, scrollAreaTop + 10, 4, scrollTrackHeight);

                    // Thumb
                    ctx.fillStyle = DS.colors.primary;
                    ctx.beginPath();
                    ctx.roundRect(canvas.width - 8, scrollThumbY, 4, scrollThumbHeight, 2);
                    ctx.fill();
                }

            } else if (gameState === 'achievements') {
                // ============================================
                // ACHIEVEMENTS PAGE
                // ============================================
                resetClickables();
                ctx.fillStyle = DS.colors.bgOverlay;
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // Header with back button
                const header = drawHeader('ACHIEVEMENTS', true);
                addClickable(header.backBounds);

                const centerX = canvas.width / 2;
                let contentY = header.height + DS.spacing.md;

                // Achievement stats summary
                const unlockedCount = unlockedAchievements.length;
                const totalCount = Object.keys(ACHIEVEMENTS).length;
                const totalBananasEarned = unlockedAchievements.reduce((sum, id) => {
                    return sum + (ACHIEVEMENTS[id]?.reward || 0);
                }, 0);

                const summaryWidth = Math.min(320, canvas.width - DS.spacing.lg * 2);
                const summaryHeight = DS.fontSize('body') * 2 + DS.spacing.lg;
                drawPanel(centerX - summaryWidth / 2, contentY, summaryWidth, summaryHeight);

                ctx.textAlign = 'center';
                ctx.fillStyle = DS.colors.primary;
                ctx.font = DS.font('body', 'bold');
                ctx.fillText(`${unlockedCount} / ${totalCount} Unlocked`, centerX, contentY + DS.spacing.md + DS.fontSize('body') / 2);

                ctx.fillStyle = DS.colors.success;
                ctx.font = DS.font('small');
                ctx.fillText(`+${totalBananasEarned} bananas earned from achievements`, centerX, contentY + DS.spacing.md + DS.fontSize('body') + DS.spacing.sm);
                contentY += summaryHeight + DS.spacing.md;

                // Check Achievements button
                const checkBtnWidth = Math.min(200, canvas.width - DS.spacing.lg * 2);
                const checkBtnHeight = 40;
                const checkBtnText = isCheckingAchievements ? 'CHECKING...' : 'CHECK ACHIEVEMENTS';
                const checkBtnBounds = drawStyledButton(
                    centerX, contentY + checkBtnHeight / 2,
                    checkBtnWidth, checkBtnHeight,
                    checkBtnText,
                    { action: 'check_achievements', primary: false, disabled: isCheckingAchievements }
                );
                if (!isCheckingAchievements) {
                    addClickable(checkBtnBounds);
                }
                contentY += checkBtnHeight + DS.spacing.sm;

                // Show result of last check
                if (lastAchievementCheckResult) {
                    ctx.textAlign = 'center';
                    if (lastAchievementCheckResult.unlocked > 0) {
                        ctx.fillStyle = DS.colors.success;
                        ctx.font = DS.font('small', 'bold');
                        ctx.fillText(
                            `Unlocked ${lastAchievementCheckResult.unlocked} achievement${lastAchievementCheckResult.unlocked > 1 ? 's' : ''}! +${lastAchievementCheckResult.newRewards} bananas`,
                            centerX, contentY
                        );
                    } else {
                        ctx.fillStyle = DS.colors.textMuted;
                        ctx.font = DS.font('small');
                        ctx.fillText('All achievements up to date', centerX, contentY);
                    }
                    contentY += DS.fontSize('small') + DS.spacing.sm;
                }

                // Scrollable achievements list
                const scrollAreaTop = contentY;
                const scrollAreaBottom = canvas.height - DS.spacing.md;
                const scrollAreaHeight = scrollAreaBottom - scrollAreaTop;

                // Calculate total content height
                const rowHeight = 60;
                const sectionHeaderHeight = 30;
                let totalContentHeight = 0;

                // Count content height by category
                const sortedCategories = Object.entries(ACHIEVEMENT_CATEGORIES)
                    .sort((a, b) => a[1].order - b[1].order);

                for (const [categoryId, category] of sortedCategories) {
                    const categoryAchievements = Object.entries(ACHIEVEMENTS)
                        .filter(([id, ach]) => ach.category === categoryId);
                    if (categoryAchievements.length > 0) {
                        totalContentHeight += sectionHeaderHeight + categoryAchievements.length * rowHeight;
                    }
                }

                achievementsScrollMax = Math.max(0, totalContentHeight - scrollAreaHeight + DS.spacing.lg);

                // Clamp scroll
                achievementsScrollY = Math.max(0, Math.min(achievementsScrollMax, achievementsScrollY));

                // Create clipping region for scroll area
                ctx.save();
                ctx.beginPath();
                ctx.rect(0, scrollAreaTop, canvas.width, scrollAreaHeight);
                ctx.clip();

                // Draw achievements by category
                let drawY = scrollAreaTop - achievementsScrollY;
                const cardPadding = DS.spacing.sm;
                const cardWidth = Math.min(450, canvas.width - DS.spacing.lg * 2);

                for (const [categoryId, category] of sortedCategories) {
                    const categoryAchievements = Object.entries(ACHIEVEMENTS)
                        .filter(([id, ach]) => ach.category === categoryId);

                    if (categoryAchievements.length === 0) continue;

                    // Category header
                    if (drawY + sectionHeaderHeight > scrollAreaTop - 50 && drawY < scrollAreaBottom + 50) {
                        ctx.fillStyle = DS.colors.textMuted;
                        ctx.font = DS.font('small', 'bold');
                        ctx.textAlign = 'left';
                        ctx.fillText(category.name.toUpperCase(), centerX - cardWidth / 2, drawY + sectionHeaderHeight / 2 + DS.fontSize('small') / 3);
                    }
                    drawY += sectionHeaderHeight;

                    // Draw each achievement
                    for (const [achId, achievement] of categoryAchievements) {
                        if (drawY + rowHeight > scrollAreaTop - 50 && drawY < scrollAreaBottom + 50) {
                            const isUnlocked = unlockedAchievements.includes(achId);
                            const cardX = centerX - cardWidth / 2;
                            const cardY = drawY;

                            // Card background
                            ctx.fillStyle = isUnlocked ? 'rgba(76, 175, 80, 0.15)' : DS.colors.bgPanel;
                            ctx.beginPath();
                            ctx.roundRect(cardX, cardY, cardWidth, rowHeight - 4, 6);
                            ctx.fill();

                            // Left side - status indicator
                            const indicatorX = cardX + 20;
                            const indicatorY = cardY + (rowHeight - 4) / 2;

                            if (isUnlocked) {
                                ctx.fillStyle = DS.colors.success;
                                ctx.font = 'bold 18px monospace';
                                ctx.textAlign = 'center';
                                ctx.fillText('âœ“', indicatorX, indicatorY + 6);
                            } else {
                                ctx.strokeStyle = DS.colors.textMuted;
                                ctx.lineWidth = 2;
                                ctx.beginPath();
                                ctx.arc(indicatorX, indicatorY, 10, 0, Math.PI * 2);
                                ctx.stroke();
                            }

                            // Achievement name
                            ctx.fillStyle = isUnlocked ? DS.colors.white : DS.colors.textSecondary;
                            ctx.font = DS.font('body', 'bold');
                            ctx.textAlign = 'left';
                            ctx.fillText(achievement.name, cardX + 45, cardY + 22);

                            // Achievement description
                            ctx.fillStyle = isUnlocked ? DS.colors.textSecondary : DS.colors.textMuted;
                            ctx.font = DS.font('small');
                            ctx.fillText(achievement.description, cardX + 45, cardY + 42);

                            // Reward on right side
                            ctx.fillStyle = isUnlocked ? DS.colors.primary : DS.colors.textMuted;
                            ctx.font = DS.font('body', 'bold');
                            ctx.textAlign = 'right';
                            ctx.fillText(`+${achievement.reward}`, cardX + cardWidth - 15, cardY + (rowHeight - 4) / 2 + 6);
                        }
                        drawY += rowHeight;
                    }
                }

                ctx.restore();

                // Draw scroll indicator if needed
                if (achievementsScrollMax > 0) {
                    const scrollTrackHeight = scrollAreaHeight - 20;
                    const scrollThumbHeight = Math.max(30, scrollTrackHeight * (scrollAreaHeight / (totalContentHeight + scrollAreaHeight)));
                    const scrollThumbY = scrollAreaTop + 10 + (scrollTrackHeight - scrollThumbHeight) * (achievementsScrollY / achievementsScrollMax);

                    // Track
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
                    ctx.fillRect(canvas.width - 8, scrollAreaTop + 10, 4, scrollTrackHeight);

                    // Thumb
                    ctx.fillStyle = DS.colors.primary;
                    ctx.beginPath();
                    ctx.roundRect(canvas.width - 8, scrollThumbY, 4, scrollThumbHeight, 2);
                    ctx.fill();
                }

            } else if (gameState === 'multiplayer-menu') {
                // Multiplayer menu - Create or Join options
                resetClickables();
                ctx.fillStyle = DS.colors.bgOverlay;
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                const header = drawHeader('MULTIPLAYER', true);
                addClickable(header.backBounds);

                const centerX = canvas.width / 2;
                let y = header.height + DS.spacing.xl * 2;

                // Title
                ctx.textAlign = 'center';
                ctx.fillStyle = DS.colors.white;
                ctx.font = DS.font('h2', 'bold');
                ctx.fillText('Choose an option', centerX, y);
                y += DS.fontSize('h2') + DS.spacing.xl;

                const btnWidth = Math.min(280, canvas.width - DS.spacing.lg * 2);
                const btnHeight = DS.button.height();

                // Create Lobby button
                const createBounds = drawStyledButton(centerX, y, btnWidth, btnHeight, 'CREATE LOBBY', { action: 'create_lobby', primary: true });
                addClickable(createBounds);
                y += btnHeight + DS.spacing.sm;

                ctx.fillStyle = DS.colors.textMuted;
                ctx.font = DS.font('small');
                ctx.fillText('Start a new game and invite friends', centerX, y);
                y += DS.fontSize('small') + DS.spacing.xl;

                // Join Lobby button
                const joinBounds = drawStyledButton(centerX, y, btnWidth, btnHeight, 'JOIN LOBBY', { action: 'show_join', primary: false });
                addClickable(joinBounds);
                y += btnHeight + DS.spacing.sm;

                ctx.fillStyle = DS.colors.textMuted;
                ctx.font = DS.font('small');
                ctx.fillText('Enter a code to join a friend\'s game', centerX, y);

            } else if (gameState === 'join-lobby') {
                // Join lobby screen with code input
                resetClickables();
                ctx.fillStyle = DS.colors.bgOverlay;
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                const header = drawHeader('JOIN LOBBY', true);
                addClickable({ ...header.backBounds, action: 'back_to_mp_menu' });

                const centerX = canvas.width / 2;
                let y = header.height + DS.spacing.xl * 2;

                // Instructions
                ctx.textAlign = 'center';
                ctx.fillStyle = DS.colors.white;
                ctx.font = DS.font('body');
                ctx.fillText('Enter the lobby word (tap to type)', centerX, y);
                y += DS.fontSize('body') + DS.spacing.lg;

                // Code input display (styled as a panel) - clickable to focus hidden input
                const inputWidth = 200;
                const inputHeight = 60;
                drawPanel(centerX, y, inputWidth, inputHeight, { centered: true });

                ctx.fillStyle = lobbyCodeInput ? DS.colors.primary : DS.colors.textMuted;
                ctx.font = DS.font('h2', 'bold');
                ctx.fillText(lobbyCodeInput || '______', centerX, y + inputHeight / 2 + DS.fontSize('h2') / 3);

                // Add clickable area for the input panel to focus native keyboard
                addClickable({
                    x: centerX - inputWidth / 2,
                    y: y,
                    w: inputWidth,
                    h: inputHeight,
                    action: 'focus_code_input'
                });
                y += inputHeight + DS.spacing.md;

                // Error message
                if (lobbyJoinError) {
                    ctx.fillStyle = DS.colors.error || '#E53935';
                    ctx.font = DS.font('small');
                    ctx.fillText(lobbyJoinError, centerX, y);
                    y += DS.fontSize('small') + DS.spacing.md;
                } else {
                    y += DS.spacing.md;
                }

                // Virtual keyboard for code input (letters only - no numbers needed for word codes)
                const keySize = Math.min(40, (canvas.width - DS.spacing.lg * 2) / 10);
                const keyGap = 4;
                const keys = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'; // Letters only
                const keysPerRow = 9;

                y += DS.spacing.md;
                for (let i = 0; i < keys.length; i++) {
                    const row = Math.floor(i / keysPerRow);
                    const col = i % keysPerRow;
                    const rowWidth = Math.min(keysPerRow, keys.length - row * keysPerRow) * (keySize + keyGap) - keyGap;
                    const startX = centerX - rowWidth / 2;
                    const keyX = startX + col * (keySize + keyGap);
                    const keyY = y + row * (keySize + keyGap);

                    // Draw key
                    ctx.fillStyle = DS.colors.bgPanel;
                    ctx.fillRect(keyX, keyY, keySize, keySize);
                    ctx.strokeStyle = DS.colors.border;
                    ctx.lineWidth = 1;
                    ctx.strokeRect(keyX, keyY, keySize, keySize);

                    ctx.fillStyle = DS.colors.white;
                    ctx.font = DS.font('body', 'bold');
                    ctx.fillText(keys[i], keyX + keySize / 2, keyY + keySize / 2 + DS.fontSize('body') / 3);

                    // Add clickable for key
                    addClickable({ x: keyX, y: keyY, w: keySize, h: keySize, action: `key_${keys[i]}` });
                }

                const numRows = Math.ceil(keys.length / keysPerRow);
                y += numRows * (keySize + keyGap) + DS.spacing.lg;

                // Backspace and Join buttons
                const btnWidth = Math.min(120, canvas.width / 3);
                const btnHeight = DS.button.height();

                const backspaceBounds = drawStyledButton(centerX - btnWidth / 2 - DS.spacing.sm, y, btnWidth, btnHeight, 'â† DELETE', { action: 'key_backspace', primary: false });
                addClickable(backspaceBounds);

                const joinBounds = drawStyledButton(centerX + btnWidth / 2 + DS.spacing.sm, y, btnWidth, btnHeight, 'JOIN', { action: 'join_with_code', primary: true });
                addClickable(joinBounds);

            } else if (gameState === 'lobby') {
                // Lobby screen
                resetClickables();
                ctx.fillStyle = DS.colors.bgOverlay;
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // Header with back button
                const header = drawHeader('MULTIPLAYER LOBBY', true);
                addClickable({ ...header.backBounds, action: 'leave_lobby' });

                const centerX = canvas.width / 2;
                let contentY = header.height + DS.spacing.lg;

                if (currentLobby) {
                    // Lobby code panel
                    const codePanelWidth = Math.min(300, canvas.width - DS.spacing.xl * 2);
                    const codePanelHeight = DS.fontSize('body') + DS.fontSize('h2') + DS.spacing.lg * 2;
                    drawPanel(centerX, contentY, codePanelWidth, codePanelHeight, { centered: true });

                    ctx.textAlign = 'center';
                    ctx.fillStyle = DS.colors.textSecondary;
                    ctx.font = DS.font('small');
                    ctx.fillText('Lobby Code', centerX, contentY + DS.spacing.md + DS.fontSize('small') / 2);
                    ctx.fillStyle = DS.colors.primary;
                    ctx.font = DS.font('h2', 'bold');
                    ctx.fillText(currentLobby.code, centerX, contentY + DS.spacing.md + DS.fontSize('small') + DS.spacing.sm + DS.fontSize('h2') / 2);
                    contentY += codePanelHeight + DS.spacing.md;

                    // Land info
                    ctx.fillStyle = DS.colors.textMuted;
                    ctx.font = DS.font('small');
                    ctx.fillText(`Land: ${lands[selectedLand].name}`, centerX, contentY);
                    contentY += DS.fontSize('small') + DS.spacing.lg;

                    // Players section with count
                    contentY = drawSectionTitle(`PLAYERS (${lobbyPlayers.length}/${MAX_LOBBY_PLAYERS})`, contentY);

                    const playerRowHeight = Math.max(40, DS.fontSize('body') + DS.spacing.md);
                    // Sort players by join order (host first)
                    const sortedPlayers = [...lobbyPlayers].sort((a, b) => {
                        // Host always first
                        if (a.player_id === currentLobby.host_id) return -1;
                        if (b.player_id === currentLobby.host_id) return 1;
                        // Then by joined_at
                        return new Date(a.joined_at) - new Date(b.joined_at);
                    });

                    sortedPlayers.forEach((p, i) => {
                        const y = contentY + i * playerRowHeight;
                        const isMe = currentUser && p.player_id === currentUser.id;
                        const isHost = p.player_id === currentLobby.host_id;
                        const username = p.profiles?.username || 'Player';

                        // Player number and name
                        ctx.fillStyle = isMe ? DS.colors.primary : DS.colors.white;
                        ctx.font = DS.font('body', isMe ? 'bold' : 'normal');
                        ctx.textAlign = 'left';
                        const displayName = `${i + 1}. ${username}${isMe ? ' (You)' : ''}`;
                        ctx.fillText(displayName, centerX - 100, y + playerRowHeight / 2);

                        // Show host badge
                        if (isHost) {
                            ctx.fillStyle = DS.colors.primary;
                            ctx.font = DS.font('small', 'bold');
                            ctx.textAlign = 'right';
                            ctx.fillText('HOST', centerX + 100, y + playerRowHeight / 2);
                        }
                    });
                    contentY += sortedPlayers.length * playerRowHeight + DS.spacing.md;

                    // Status message
                    ctx.textAlign = 'center';
                    if (lobbyPlayers.length < 2) {
                        ctx.fillStyle = DS.colors.textMuted;
                        ctx.font = DS.font('body');
                        ctx.fillText('Waiting for players to join...', centerX, contentY);
                        ctx.font = DS.font('small');
                        ctx.fillText('Share the lobby code above!', centerX, contentY + DS.fontSize('body') + DS.spacing.xs);
                    } else if (!isLobbyHost) {
                        ctx.fillStyle = DS.colors.textSecondary;
                        ctx.font = DS.font('body');
                        ctx.fillText('Waiting for host to start...', centerX, contentY);
                    }

                    // Buttons
                    const btnWidth = Math.min(220, canvas.width - DS.spacing.xl * 2);
                    const btnHeight = DS.button.height();
                    const btnY = canvas.height - DS.spacing.xl - btnHeight * 2 - DS.spacing.md;

                    // Host sees START GAME, others see nothing (just waiting)
                    if (isLobbyHost) {
                        const canStart = lobbyPlayers.length >= 2;
                        const startBounds = drawStyledButton(centerX, btnY, btnWidth, btnHeight, 'START GAME', {
                            action: canStart ? 'start_game' : null,
                            primary: canStart,
                            disabled: !canStart
                        });
                        if (canStart) {
                            addClickable(startBounds);
                        }
                    }

                    const leaveBounds = drawStyledButton(centerX, btnY + btnHeight + DS.spacing.md, btnWidth, btnHeight, 'LEAVE LOBBY', { action: 'leave_lobby', primary: false });
                    addClickable(leaveBounds);

                    // Instructions at bottom
                    ctx.fillStyle = DS.colors.textMuted;
                    ctx.font = DS.font('small');
                    ctx.textAlign = 'center';
                    if (isLobbyHost && lobbyPlayers.length >= 2) {
                        ctx.fillStyle = DS.colors.success;
                        ctx.fillText('Ready to start! Click START GAME', centerX, canvas.height - DS.spacing.md);
                    }
                } else {
                    ctx.fillStyle = DS.colors.textSecondary;
                    ctx.font = DS.font('body');
                    ctx.textAlign = 'center';
                    ctx.fillText('Creating lobby...', centerX, canvas.height / 2);
                }

            } else if (gameState === 'playing') {
                // Draw background announcement (behind everything)
                drawAnnouncement();

                // Draw entities first (behind players) - with accessibility outlines
                entities.forEach(ent => {
                    if (ent.type === 'obstacle') {
                        drawSpriteWithOutline(ctx, ent.x, ent.y, ent.pixels, ent.scale, ent.colors, DS.colors.outlineObstacle, 1);
                    } else if (ent.type === 'banana') {
                        drawSpriteWithOutline(ctx, ent.x, ent.y, ent.pixels, ent.scale, ent.colors, DS.colors.outlineCollectible, 1);
                    } else {
                        drawSprite(ctx, ent.x, ent.y, ent.pixels, ent.scale, ent.colors);
                    }
                });

                // In multiplayer, draw all players
                if (gameMode === 'multiplayer') {
                    // Update local player state for rendering
                    if (allPlayersStates[currentUser?.id]) {
                        allPlayersStates[currentUser.id].yOffset = player.y - player.groundY;
                        allPlayersStates[currentUser.id].score = score;
                        allPlayersStates[currentUser.id].bananas = bananasCollected;
                    }

                    // Draw all players (sorted by x position so front players overlap back)
                    const playersToDraw = Object.values(allPlayersStates)
                        .sort((a, b) => a.x - b.x);

                    // Get local ground position for rendering
                    const localGroundY = player.groundY;

                    playersToDraw.forEach(p => {
                        const isLocal = p.id === currentUser?.id;
                        // For local player, use actual position
                        // For remote players, calculate from local ground + their offset
                        const yPos = isLocal ? player.y : (localGroundY + (p.yOffset || 0));

                        // Get the player's skin
                        const playerSkinId = isLocal ? selectedSkin : (p.skin || 'default');
                        const playerSkin = SKINS[playerSkinId];

                        // Ghost players are semi-transparent, skin transparency also applies
                        let alpha = 1;
                        if (!p.isAlive) alpha = 0.4;
                        else if (playerSkin?.transparency) alpha = playerSkin.transparency;
                        ctx.globalAlpha = alpha;

                        // Draw player sprite with skin colors, costume overlay, and accessibility outline
                        const playerSkinColors = getSkinColors(land.runnerColors, playerSkinId);
                        drawSpriteWithOutlinePlayer(ctx, p.x, yPos, land.runner, player.scale, playerSkinColors, DS.colors.outlinePlayer, 1, playerSkin);

                        // Draw username above player
                        ctx.globalAlpha = p.isAlive ? 1 : 0.5;
                        ctx.fillStyle = isLocal ? DS.colors.primary : DS.colors.white;
                        ctx.font = 'bold 12px monospace';
                        ctx.textAlign = 'center';
                        ctx.fillText(p.username, p.x + PLAYER_WIDTH / 2, yPos - 5);

                        // Ghost label
                        if (!p.isAlive) {
                            ctx.fillStyle = '#888';
                            ctx.font = '10px monospace';
                            ctx.fillText('GHOST', p.x + PLAYER_WIDTH / 2, yPos - 18);
                        }

                        ctx.globalAlpha = 1;
                    });

                    // Show ghost spectating message if dead
                    if (!localPlayerAlive) {
                        ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                        ctx.fillRect(0, 0, canvas.width, 40);
                        ctx.fillStyle = DS.colors.primary;
                        ctx.font = 'bold 16px monospace';
                        ctx.textAlign = 'center';
                        ctx.fillText('ðŸ‘» SPECTATING - Waiting for others to finish...', canvas.width / 2, 26);
                    }

                    // Show all player scores on the right (with bananas)
                    ctx.textAlign = 'right';
                    let scoreY = 35;
                    Object.values(allPlayersStates)
                        .sort((a, b) => b.score - a.score)
                        .forEach((p, i) => {
                            const isLocal = p.id === currentUser?.id;
                            ctx.fillStyle = isLocal ? DS.colors.primary : (p.isAlive ? '#333' : '#888');
                            ctx.font = `${isLocal ? 'bold ' : ''}14px monospace`;
                            const status = p.isAlive ? '' : ' ðŸ‘»';
                            // Show score and banana count
                            ctx.fillText(`${p.username}: ${p.score} (ðŸŒ${p.bananas || 0})${status}`, canvas.width - 20, scoreY);
                            scoreY += 20;
                        });
                } else {
                    // Solo mode - draw single player with skin colors and accessibility outline
                    if (trexActive) {
                        // Draw T-Rex sprite when transformed
                        // T-Rex is 48px wide, player is 32px wide - center the T-Rex on player position
                        const trexWidth = sprites.trex[0].length; // 48
                        const trexHeight = sprites.trex.length; // 48
                        const playerWidth = 32;
                        const trexX = player.x - ((trexWidth - playerWidth) / 2) * player.scale;
                        // Align T-Rex feet with where player's feet would be
                        const trexY = player.groundY + (48 * player.scale) - (trexHeight * player.scale);
                        drawSpriteWithOutline(ctx, trexX, trexY, sprites.trex, player.scale, colors.trex, DS.colors.outlinePlayer, 1);
                    } else {
                        // Normal player
                        const soloPlayerColors = getSkinColors(land.runnerColors, selectedSkin);
                        // Apply transparency for ghost skin
                        const soloSkin = SKINS[selectedSkin];
                        if (soloSkin?.transparency) {
                            ctx.globalAlpha = soloSkin.transparency;
                        }
                        drawSpriteWithOutlinePlayer(ctx, player.x, player.y, land.runner, player.scale, soloPlayerColors, DS.colors.outlinePlayer, 1, soloSkin);
                        ctx.globalAlpha = 1;
                    }
                }

                // Draw particle effects (behind UI, after player)
                drawParticles();

                // Draw floating score texts
                drawFloatingTexts();

                // Draw local scores (left side)
                ctx.fillStyle = '#000';
                ctx.font = 'bold 28px monospace';
                ctx.textAlign = 'left';
                ctx.fillText(`Score: ${score}`, 20, 35);
                ctx.fillText(`Bananas: ${bananasCollected}`, 20, 70);

                // Draw jetpack timer if active (right of player)
                if (jetpackActive) {
                    const timerX = player.x + PLAYER_WIDTH + 15;
                    const timerY = player.y + PLAYER_HEIGHT / 2;
                    const secondsLeft = Math.ceil(jetpackTimer / 60);

                    // Timer background pill
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                    ctx.beginPath();
                    ctx.roundRect(timerX - 5, timerY - 12, 55, 24, 12);
                    ctx.fill();

                    // Clock icon (simple)
                    ctx.fillStyle = '#FFEB3B';
                    ctx.font = 'bold 14px monospace';
                    ctx.textAlign = 'left';
                    ctx.fillText('â±', timerX, timerY + 5);

                    // Timer countdown
                    ctx.fillStyle = '#FFFFFF';
                    ctx.font = 'bold 16px monospace';
                    ctx.fillText(`${secondsLeft}s`, timerX + 20, timerY + 5);
                }

                // Draw T-Rex timer if active (right of player)
                if (trexActive) {
                    const timerX = player.x + PLAYER_WIDTH + 50; // Further right for larger T-Rex
                    const timerY = player.groundY - 20;
                    const secondsLeft = Math.ceil(trexTimer / 60);

                    // Timer background pill
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                    ctx.beginPath();
                    ctx.roundRect(timerX - 5, timerY - 12, 55, 24, 12);
                    ctx.fill();

                    // Dino icon
                    ctx.fillStyle = '#4CAF50';
                    ctx.font = 'bold 14px monospace';
                    ctx.textAlign = 'left';
                    ctx.fillText('ðŸ¦–', timerX, timerY + 5);

                    // Timer countdown
                    ctx.fillStyle = '#FFFFFF';
                    ctx.font = 'bold 16px monospace';
                    ctx.fillText(`${secondsLeft}s`, timerX + 20, timerY + 5);
                }

                // Show current land
                ctx.fillStyle = '#666';
                ctx.font = '18px monospace';
                ctx.textAlign = 'right';
                if (gameMode !== 'multiplayer') {
                    ctx.fillText(land.name, canvas.width - 20, 35);
                }

            } else if (gameState === 'gameover') {
                // Draw player and entities frozen with skin colors, overlay, and accessibility outlines
                const gameoverPlayerColors = getSkinColors(land.runnerColors, selectedSkin);
                const gameoverSkin = SKINS[selectedSkin];
                drawSpriteWithOutlinePlayer(ctx, player.x, player.y, land.runner, player.scale, gameoverPlayerColors, DS.colors.outlinePlayer, 1, gameoverSkin);
                entities.forEach(ent => {
                    if (ent.type === 'obstacle') {
                        drawSpriteWithOutline(ctx, ent.x, ent.y, ent.pixels, ent.scale, ent.colors, DS.colors.outlineObstacle, 1);
                    } else if (ent.type === 'banana') {
                        drawSpriteWithOutline(ctx, ent.x, ent.y, ent.pixels, ent.scale, ent.colors, DS.colors.outlineCollectible, 1);
                    } else {
                        drawSprite(ctx, ent.x, ent.y, ent.pixels, ent.scale, ent.colors);
                    }
                });

                // Dark overlay
                resetClickables();
                ctx.fillStyle = DS.colors.bgOverlay;
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                const centerX = canvas.width / 2;
                let y = canvas.height * 0.15;
                ctx.textAlign = 'center';

                // Show multiplayer result
                if (gameMode === 'multiplayer' && gameResult) {
                    const resultColors = { win: DS.colors.success, lose: DS.colors.error, tie: DS.colors.primary };
                    const resultText = { win: 'YOU WIN!', lose: 'YOU LOSE!', tie: 'TIE GAME!' };

                    ctx.fillStyle = resultColors[gameResult];
                    ctx.font = DS.font('h1', 'bold');
                    ctx.fillText(resultText[gameResult], centerX, y);
                    y += DS.fontSize('h1') + DS.spacing.lg;

                    ctx.fillStyle = DS.colors.white;
                    ctx.font = DS.font('h3', 'bold');
                    ctx.fillText(`Your Score: ${score}`, centerX, y);
                    y += DS.fontSize('h3') + DS.spacing.md;

                    ctx.fillStyle = DS.colors.error;
                    ctx.fillText(`Opponent: ${opponentScore}`, centerX, y);
                    y += DS.fontSize('h3') + DS.spacing.lg;
                } else {
                    ctx.fillStyle = DS.colors.white;
                    ctx.font = DS.font('h1', 'bold');
                    ctx.fillText('Game Over', centerX, y);
                    y += DS.fontSize('h1') + DS.spacing.md;

                    // Your score panel
                    const panelWidth = Math.min(340, canvas.width - DS.spacing.lg * 2);
                    const yourScorePanelHeight = DS.fontSize('h2') + DS.fontSize('small') + DS.spacing.lg;
                    drawPanel(centerX, y, panelWidth, yourScorePanelHeight, { centered: true });

                    ctx.fillStyle = DS.colors.primary;
                    ctx.font = DS.font('h2', 'bold');
                    ctx.fillText(score.toString(), centerX, y + DS.spacing.md + DS.fontSize('h2') / 2);

                    ctx.fillStyle = DS.colors.textSecondary;
                    ctx.font = DS.font('small');
                    ctx.fillText(`${bananasCollected} bananas collected`, centerX, y + DS.spacing.md + DS.fontSize('h2') + DS.spacing.xs);
                    y += yourScorePanelHeight + DS.spacing.md;

                    // New high score notification
                    if (currentUser && userProfile && score > (userProfile.high_score || 0)) {
                        ctx.fillStyle = DS.colors.primary;
                        ctx.font = DS.font('body', 'bold');
                        ctx.fillText('NEW PERSONAL BEST!', centerX, y);
                        y += DS.fontSize('body') + DS.spacing.sm;
                    }

                    // Stats comparison section
                    if (!gameOverStats.loading && supabaseClient) {
                        const statsRowHeight = DS.fontSize('small') + DS.spacing.sm;
                        const statsPanelHeight = statsRowHeight * 3 + DS.spacing.md * 2;
                        const currentLandName = lands[selectedLand].name;

                        y += DS.spacing.sm;
                        drawPanel(centerX, y, panelWidth, statsPanelHeight, { centered: true });

                        const statsX = centerX - panelWidth / 2 + DS.spacing.md;
                        const statsRightX = centerX + panelWidth / 2 - DS.spacing.md;
                        let statsY = y + DS.spacing.md + statsRowHeight / 2;

                        // Global top score
                        ctx.textAlign = 'left';
                        ctx.fillStyle = DS.colors.textSecondary;
                        ctx.font = DS.font('small');
                        ctx.fillText('Global Best', statsX, statsY);
                        ctx.textAlign = 'right';
                        if (gameOverStats.isNewGlobalBest) {
                            ctx.fillStyle = DS.colors.success;
                            ctx.font = DS.font('small', 'bold');
                            ctx.fillText('NEW RECORD!', statsRightX, statsY);
                        } else if (gameOverStats.globalTopScore !== null) {
                            ctx.fillStyle = DS.colors.white;
                            ctx.font = DS.font('small', 'bold');
                            ctx.fillText(`${gameOverStats.globalTopScore} by ${gameOverStats.globalTopPlayer}`, statsRightX, statsY);
                        }
                        statsY += statsRowHeight;

                        // Biome top score
                        ctx.textAlign = 'left';
                        ctx.fillStyle = DS.colors.textSecondary;
                        ctx.font = DS.font('small');
                        ctx.fillText(`${currentLandName} Best`, statsX, statsY);
                        ctx.textAlign = 'right';
                        if (gameOverStats.biomeTopScore !== null) {
                            const isNewBiomeRecord = score > gameOverStats.biomeTopScore;
                            if (isNewBiomeRecord) {
                                ctx.fillStyle = DS.colors.success;
                                ctx.font = DS.font('small', 'bold');
                                ctx.fillText('NEW RECORD!', statsRightX, statsY);
                            } else {
                                ctx.fillStyle = DS.colors.white;
                                ctx.font = DS.font('small', 'bold');
                                ctx.fillText(`${gameOverStats.biomeTopScore} by ${gameOverStats.biomeTopPlayer}`, statsRightX, statsY);
                            }
                        } else {
                            ctx.fillStyle = DS.colors.success;
                            ctx.font = DS.font('small', 'bold');
                            ctx.fillText('FIRST SCORE!', statsRightX, statsY);
                        }
                        statsY += statsRowHeight;

                        // Personal biome best
                        if (currentUser) {
                            ctx.textAlign = 'left';
                            ctx.fillStyle = DS.colors.textSecondary;
                            ctx.font = DS.font('small');
                            ctx.fillText(`Your ${currentLandName} Best`, statsX, statsY);
                            ctx.textAlign = 'right';
                            if (gameOverStats.isNewBiomeBest) {
                                ctx.fillStyle = DS.colors.success;
                                ctx.font = DS.font('small', 'bold');
                                ctx.fillText('NEW!', statsRightX, statsY);
                            } else if (gameOverStats.personalBiomeBest !== null) {
                                ctx.fillStyle = DS.colors.white;
                                ctx.font = DS.font('small', 'bold');
                                ctx.fillText(gameOverStats.personalBiomeBest.toString(), statsRightX, statsY);
                            }
                        }

                        y += statsPanelHeight + DS.spacing.md;
                    } else if (gameOverStats.loading) {
                        ctx.fillStyle = DS.colors.textMuted;
                        ctx.font = DS.font('small');
                        ctx.textAlign = 'center';
                        ctx.fillText('Loading stats...', centerX, y + DS.spacing.md);
                        y += DS.fontSize('small') + DS.spacing.lg;
                    }
                }

                // Land selection instruction
                ctx.textAlign = 'center';
                y = drawSectionTitle('SELECT LAND & TAP TO PLAY', y);
                drawLandButtons(y, false);
                y += Math.max(44, Math.round(canvas.width * 0.055)) + DS.spacing.lg; // Land button height + spacing

                // Back to menu button
                const menuBtnWidth = Math.min(180, canvas.width - DS.spacing.xl * 2);
                const menuBtnHeight = Math.max(40, DS.button.height() * 0.8);
                const menuBtnBounds = drawStyledButton(centerX, y, menuBtnWidth, menuBtnHeight, 'MENU', { action: 'back', primary: false });
                addClickable(menuBtnBounds);

            } else if (gameState === 'multiplayer-results') {
                // Multiplayer round results screen
                resetClickables();
                ctx.fillStyle = DS.colors.bgOverlay;
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                const centerX = canvas.width / 2;
                let y = DS.spacing.xl;

                // Title
                ctx.textAlign = 'center';
                ctx.fillStyle = DS.colors.primary;
                ctx.font = DS.font('h1', 'bold');
                ctx.fillText('ROUND OVER', centerX, y + DS.fontSize('h1'));
                y += DS.fontSize('h1') + DS.spacing.lg;

                // Result message
                if (gameResult === 'win') {
                    ctx.fillStyle = DS.colors.success;
                    ctx.font = DS.font('h2', 'bold');
                    ctx.fillText('ðŸ† YOU WON!', centerX, y + DS.fontSize('h2'));
                } else {
                    ctx.fillStyle = DS.colors.error;
                    ctx.font = DS.font('h2', 'bold');
                    ctx.fillText('Better luck next time!', centerX, y + DS.fontSize('h2'));
                }
                y += DS.fontSize('h2') + DS.spacing.xl;

                // Leaderboard panel
                const panelWidth = Math.min(400, canvas.width - DS.spacing.lg * 2);
                const results = Object.values(allPlayersStates)
                    .sort((a, b) => b.score - a.score);
                const rowHeight = 36;
                const panelHeight = rowHeight * (results.length + 1) + DS.spacing.lg * 2;

                drawPanel(centerX, y, panelWidth, panelHeight, { centered: true });

                // Header row
                const tableStartY = y + DS.spacing.lg;
                const panelLeft = centerX - panelWidth / 2;
                const colRank = panelLeft + DS.spacing.md;
                const colPlayer = panelLeft + DS.spacing.xl * 1.5;
                const colScore = panelLeft + panelWidth - DS.spacing.lg - 60;
                const colBananas = panelLeft + panelWidth - DS.spacing.md;

                ctx.fillStyle = DS.colors.textMuted;
                ctx.font = DS.font('small', 'bold');
                ctx.textAlign = 'left';
                ctx.fillText('#', colRank, tableStartY + rowHeight / 2);
                ctx.fillText('PLAYER', colPlayer, tableStartY + rowHeight / 2);
                ctx.textAlign = 'right';
                ctx.fillText('SCORE', colScore, tableStartY + rowHeight / 2);
                ctx.fillText('ðŸŒ', colBananas, tableStartY + rowHeight / 2);

                // Player rows
                results.forEach((p, i) => {
                    const rowY = tableStartY + (i + 1) * rowHeight + rowHeight / 2;
                    const isLocal = p.id === currentUser?.id;
                    const medal = i === 0 ? 'ðŸ¥‡' : (i === 1 ? 'ðŸ¥ˆ' : (i === 2 ? 'ðŸ¥‰' : ''));

                    ctx.fillStyle = isLocal ? DS.colors.primary : DS.colors.white;
                    ctx.font = DS.font('body', isLocal ? 'bold' : 'normal');
                    ctx.textAlign = 'left';
                    ctx.fillText(`${medal || (i + 1)}`, colRank, rowY);
                    ctx.fillText(p.username + (isLocal ? ' (You)' : ''), colPlayer, rowY);
                    ctx.textAlign = 'right';
                    ctx.fillText(p.score.toString(), colScore, rowY);
                    ctx.fillText(p.bananas.toString(), colBananas, rowY);
                });

                y += panelHeight + DS.spacing.xl;

                // Buttons - Play Again is prominent, Leave is minor
                const btnWidth = Math.min(220, canvas.width - DS.spacing.xl * 2);
                const btnHeight = DS.button.height();

                if (isLobbyHost) {
                    // Large prominent PLAY AGAIN button for host
                    const playAgainBounds = drawStyledButton(centerX, y, btnWidth, btnHeight * 1.2, 'PLAY AGAIN', { action: 'play_again', primary: true });
                    addClickable(playAgainBounds);
                    y += btnHeight * 1.2 + DS.spacing.xl;
                } else {
                    ctx.fillStyle = DS.colors.textMuted;
                    ctx.font = DS.font('body');
                    ctx.fillText('Waiting for host to start next round...', centerX, y + DS.fontSize('body') / 2);
                    y += DS.fontSize('body') + DS.spacing.xl;
                }

                // Minor text-link style "leave" option
                ctx.fillStyle = DS.colors.textMuted;
                ctx.font = DS.font('small');
                const leaveText = 'Leave Lobby';
                const leaveWidth = ctx.measureText(leaveText).width + 20;
                const leaveHeight = DS.fontSize('small') + 16;
                const leaveX = centerX - leaveWidth / 2;
                const leaveY = y;
                ctx.fillText(leaveText, centerX, leaveY + leaveHeight / 2 + 2);

                // Add subtle underline
                const textWidth = ctx.measureText(leaveText).width;
                ctx.beginPath();
                ctx.moveTo(centerX - textWidth / 2, leaveY + leaveHeight / 2 + 6);
                ctx.lineTo(centerX + textWidth / 2, leaveY + leaveHeight / 2 + 6);
                ctx.strokeStyle = DS.colors.textMuted;
                ctx.lineWidth = 1;
                ctx.stroke();

                addClickable({ x: leaveX, y: leaveY, w: leaveWidth, h: leaveHeight, action: 'leave_results' });
            }

            // Draw notifications on top of everything
            drawNotifications();

            ctx.textAlign = 'left';
        }

        // Game loop
        // Update shop scroll momentum
        function updateShopScroll() {
            if (gameState !== 'shop') return;

            // Apply momentum when not dragging
            if (!shopDragging && Math.abs(shopScrollVel) > 0.1) {
                shopScrollY += shopScrollVel;
                shopScrollY = Math.max(0, Math.min(shopScrollMax, shopScrollY));
                shopScrollVel *= 0.92;  // Friction
            } else if (!shopDragging) {
                shopScrollVel = 0;
            }
        }

        function gameLoop() {
            update();
            updateShopScroll();
            draw();
            requestAnimationFrame(gameLoop);
        }

        // Start the game
        gameLoop();
    </script>
</body>
</html>