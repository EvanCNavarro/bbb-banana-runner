<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Banana Runner</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: #000;
            font-family: monospace;
        }
        canvas {
            display: block;
            background: #FAFAFA;
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
        }
        /* Auth Modal Styles */
        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            z-index: 1000;
            justify-content: center;
            align-items: center;
            cursor: pointer;
        }
        .modal-overlay.active {
            display: flex;
        }
        .auth-modal {
            background: #1a1a2e;
            border: 3px solid #FFE135;
            border-radius: 12px;
            padding: 30px;
            max-width: 400px;
            width: 90%;
            box-shadow: 0 0 30px rgba(255, 225, 53, 0.3);
            cursor: default;
        }
        .auth-modal h2 {
            color: #FFE135;
            text-align: center;
            margin-bottom: 25px;
            font-size: 28px;
        }
        .auth-modal input {
            width: 100%;
            padding: 12px;
            margin-bottom: 15px;
            background: #16213e;
            border: 2px solid #444;
            border-radius: 6px;
            color: #fff;
            font-family: monospace;
            font-size: 16px;
            box-sizing: border-box;
        }
        .auth-modal input:focus {
            outline: none;
            border-color: #FFE135;
        }
        .auth-modal button {
            width: 100%;
            padding: 14px;
            margin-bottom: 10px;
            background: #FFE135;
            border: none;
            border-radius: 6px;
            color: #000;
            font-family: monospace;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            transition: transform 0.1s, background 0.2s;
        }
        .auth-modal button:hover {
            background: #FFC107;
            transform: scale(1.02);
        }
        .auth-modal button.secondary {
            background: transparent;
            border: 2px solid #666;
            color: #aaa;
        }
        .auth-modal button.secondary:hover {
            border-color: #FFE135;
            color: #FFE135;
        }
        .auth-modal .toggle-text {
            text-align: center;
            color: #888;
            margin-top: 15px;
        }
        .auth-modal .toggle-text a {
            color: #FFE135;
            cursor: pointer;
            text-decoration: underline;
        }
        .auth-modal .error-msg {
            color: #ff6b6b;
            text-align: center;
            margin-bottom: 15px;
            min-height: 20px;
        }
        .auth-modal .success-msg {
            color: #4CAF50;
            text-align: center;
            margin-bottom: 15px;
        }
        .user-info {
            position: fixed;
            top: 10px;
            right: 10px;
            color: #fff;
            font-family: monospace;
            font-size: 14px;
            z-index: 100;
            text-align: right;
        }
        .user-info .username {
            color: #FFE135;
            font-weight: bold;
        }
        .user-info .logout-btn {
            color: #888;
            cursor: pointer;
            margin-left: 10px;
        }
        .user-info .logout-btn:hover {
            color: #ff6b6b;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>

    <!-- Hidden input for native keyboard on mobile/desktop -->
    <input type="text" id="lobbyCodeInput" autocomplete="off" autocorrect="off" autocapitalize="characters"
           style="position: absolute; left: -9999px; opacity: 0; pointer-events: none;"
           maxlength="6" pattern="[A-Za-z]{6}">

    <!-- User Info Display -->
    <div id="userInfo" class="user-info" style="display: none;">
        <span class="username" id="displayUsername"></span>
        <span class="logout-btn" onclick="logout()">[Logout]</span>
    </div>

    <!-- Auth Modal -->
    <div id="authModal" class="modal-overlay">
        <div class="auth-modal">
            <h2 id="authTitle">Sign Up</h2>
            <div id="authError" class="error-msg"></div>
            <div id="authSuccess" class="success-msg" style="display: none;"></div>
            <form id="authForm">
                <input type="text" id="authUsername" placeholder="Username" autocomplete="username" required>
                <input type="password" id="authPassword" placeholder="Password" autocomplete="current-password" required>
                <button type="submit" id="authSubmit">Create Account</button>
            </form>
            <div class="toggle-text" id="authToggle">
                Already have an account? <a onclick="toggleAuthMode()">Login</a>
            </div>
        </div>
    </div>

    <!-- Supabase SDK -->
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>

    <script type="module">
        // ============================================
        // MODULE IMPORTS
        // ============================================

        // Core configuration
        import {
            SUPABASE_URL,
            SUPABASE_ANON_KEY,
            PLAYER_SCALE,
            ENTITY_SCALE,
            BANANA_HEIGHT_OFFSET,
            JUMP_BUFFER_MS,
            INITIAL_SPEED,
            SPEED_INCREMENT,
            JUMP_VELOCITY,
            GRAVITY,
            SPAWN_INTERVAL,
            BANANA_SPAWN_CHANCE,
            BANANA_POINTS,
            GROUND_HEIGHT_RATIO,
            GAME_STATES,
            GAME_MODES
        } from './src/core/config.js';

        // Design system
        import { createDesignSystem } from './src/core/designSystem.js';

        // Utilities
        import {
            drawSprite as drawSpriteUtil,
            pointInBounds as pointInBoundsUtil,
            clamp,
            lerp,
            randomInt
        } from './src/core/utils.js';

        // UI Components (available for future use)
        import { createUIComponents } from './src/ui/components.js';

        // Click handling (available for future use)
        import { createClickManager, createInputHandler } from './src/ui/clickHandler.js';

        // Services
        import { createAuthService, usernameToEmail as authUsernameToEmail, validateUsername } from './src/services/auth.js';
        import { createDatabaseService } from './src/services/database.js';
        import { createMultiplayerService } from './src/services/multiplayer.js';

        // ============================================
        // CANVAS SETUP
        // ============================================
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        ctx.imageSmoothingEnabled = false;

        // Initialize design system bound to canvas
        const DS = createDesignSystem(canvas);

        // ============================================
        // UI COMPONENTS
        // ============================================

        // Navigation stack for back button
        let navigationStack = [];

        function navigateTo(screen, addToStack = true) {
            if (addToStack && gameState !== 'welcome' && gameState !== 'playing') {
                navigationStack.push(gameState);
            }
            gameState = screen;
        }

        function navigateBack() {
            if (navigationStack.length > 0) {
                gameState = navigationStack.pop();
            } else {
                gameState = 'menu';
            }
        }

        // Draw a styled button - returns bounds for click detection
        function drawStyledButton(x, y, width, height, label, options = {}) {
            const {
                primary = true,
                disabled = false,
                centered = true
            } = options;

            const actualX = centered ? x - width / 2 : x;
            const actualY = y;

            // Background
            if (disabled) {
                ctx.fillStyle = DS.colors.locked;
            } else if (primary) {
                ctx.fillStyle = DS.colors.primary;
            } else {
                ctx.fillStyle = 'transparent';
                ctx.strokeStyle = DS.colors.primary;
                ctx.lineWidth = 2;
            }

            // Draw rounded rect
            const r = DS.button.radius;
            ctx.beginPath();
            ctx.roundRect(actualX, actualY, width, height, r);
            if (primary || disabled) {
                ctx.fill();
            } else {
                ctx.stroke();
            }

            // Text
            ctx.fillStyle = primary ? DS.colors.bgDark : DS.colors.primary;
            if (disabled) ctx.fillStyle = DS.colors.textMuted;
            ctx.font = DS.font('body', 'bold');
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(label, actualX + width / 2, actualY + height / 2);

            // Return bounds for click detection
            return { x: actualX, y: actualY, w: width, h: height, action: options.action || label };
        }

        // Draw header with title and optional back button
        function drawHeader(title, showBack = true) {
            const height = DS.header.height();

            // Background
            ctx.fillStyle = DS.colors.bgOverlay;
            ctx.fillRect(0, 0, canvas.width, height);

            // Bottom border
            ctx.strokeStyle = DS.colors.primary;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(0, height);
            ctx.lineTo(canvas.width, height);
            ctx.stroke();

            // Back button
            let backBounds = null;
            if (showBack) {
                const backSize = height - DS.spacing.lg;
                const backX = DS.spacing.md;
                const backY = (height - backSize) / 2;

                ctx.fillStyle = DS.colors.primary;
                ctx.font = DS.font('h3', 'bold');
                ctx.textAlign = 'left';
                ctx.textBaseline = 'middle';
                ctx.fillText('â†', backX, height / 2);

                backBounds = { x: 0, y: 0, w: height, h: height, action: 'back' };
            }

            // Title
            ctx.fillStyle = DS.colors.white;
            ctx.font = DS.font('h3', 'bold');
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(title, canvas.width / 2, height / 2);

            return { height, backBounds };
        }

        // Draw a panel/card
        function drawPanel(x, y, width, height, options = {}) {
            const { centered = false, title = null } = options;
            const actualX = centered ? x - width / 2 : x;

            // Background
            ctx.fillStyle = DS.colors.bgPanel;
            ctx.beginPath();
            ctx.roundRect(actualX, y, width, height, 12);
            ctx.fill();

            // Border
            ctx.strokeStyle = DS.colors.primary;
            ctx.lineWidth = 2;
            ctx.stroke();

            // Title if provided
            if (title) {
                ctx.fillStyle = DS.colors.primary;
                ctx.font = DS.font('body', 'bold');
                ctx.textAlign = 'left';
                ctx.textBaseline = 'top';
                ctx.fillText(title, actualX + DS.spacing.md, y + DS.spacing.md);
            }

            return { x: actualX, y, w: width, h: height };
        }

        // Draw section title
        function drawSectionTitle(text, y) {
            ctx.fillStyle = DS.colors.textSecondary;
            ctx.font = DS.font('small', 'bold');
            ctx.textAlign = 'center';
            ctx.textBaseline = 'top';
            ctx.fillText(text.toUpperCase(), canvas.width / 2, y);
            return y + DS.fontSize('small') + DS.spacing.sm;
        }

        // Check if point is in bounds
        function pointInBounds(px, py, bounds) {
            if (!bounds) return false;
            return px >= bounds.x && px <= bounds.x + bounds.w &&
                   py >= bounds.y && py <= bounds.y + bounds.h;
        }

        // Store clickable areas for current frame
        let clickableAreas = [];

        function resetClickables() {
            clickableAreas = [];
        }

        function addClickable(bounds) {
            if (bounds) clickableAreas.push(bounds);
        }

        // ============================================
        // SUPABASE INITIALIZATION
        // Config imported from ./src/core/config.js
        // ============================================

        // Initialize Supabase client
        let supabaseClient = null;
        let currentUser = null;
        let userProfile = null;
        let isAuthMode = 'signup'; // 'signup' or 'login' - default to signup for new users

        // Declare early to avoid temporal dead zone issues with callbacks and resize handlers
        let gameState = 'welcome';
        let player = null;
        let entities = [];
        let spawnCounter = 0;
        let jetpackSpawnCounter = 0;

        // ============================================
        // SEEDED RANDOM NUMBER GENERATOR
        // For synchronized multiplayer - all players use same seed = same obstacles
        // ============================================
        let gameSeed = 0;
        let seededRandom = null;

        /**
         * Create a seeded PRNG using mulberry32 algorithm
         * @param {number} seed - The seed value
         * @returns {function} A function that returns random numbers 0-1
         */
        function createSeededRandom(seed) {
            return function() {
                seed |= 0;
                seed = seed + 0x6D2B79F5 | 0;
                let t = Math.imul(seed ^ seed >>> 15, 1 | seed);
                t = t + Math.imul(t ^ t >>> 7, 61 | t) ^ t;
                return ((t ^ t >>> 14) >>> 0) / 4294967296;
            };
        }

        /**
         * Initialize the game with a specific seed
         * @param {number} seed - Seed for random generation
         */
        function initGameSeed(seed) {
            gameSeed = seed;
            seededRandom = createSeededRandom(seed);
            console.log(`[Game] Initialized with seed: ${seed}`);
        }

        /**
         * Get a seeded random number (falls back to Math.random if not initialized)
         * @returns {number} Random number between 0 and 1
         */
        function getRandom() {
            return seededRandom ? seededRandom() : Math.random();
        }

        function initSupabase() {
            if (SUPABASE_URL !== 'YOUR_SUPABASE_URL' && typeof window.supabase !== 'undefined') {
                supabaseClient = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
                checkAuth();
            } else {
                console.log('Supabase not configured - running in guest mode');
            }
        }

        // ============================================
        // AUTHENTICATION FUNCTIONS
        // ============================================
        async function checkAuth() {
            if (!supabaseClient) return;

            const { data: { session } } = await supabaseClient.auth.getSession();
            if (session) {
                currentUser = session.user;
                // Set fallback profile immediately
                userProfile = {
                    id: currentUser.id,
                    username: currentUser.user_metadata?.username || 'Player'
                };
                await loadUserProfileWithTimeout();
                updateUserDisplay();
                // Go to menu if already logged in
                gameState = 'menu';
            }

            // Listen for auth changes (e.g., from other tabs)
            supabaseClient.auth.onAuthStateChange(async (event, session) => {
                // Skip if this is from our own signIn (already handled)
                if (event === 'SIGNED_IN' && currentUser?.id === session?.user?.id) {
                    return;
                }

                if (session) {
                    currentUser = session.user;
                    userProfile = {
                        id: currentUser.id,
                        username: currentUser.user_metadata?.username || 'Player'
                    };
                    await loadUserProfileWithTimeout();
                    updateUserDisplay();
                    if (gameState === 'welcome') {
                        gameState = 'menu';
                    }
                } else {
                    currentUser = null;
                    userProfile = null;
                    updateUserDisplay();
                    gameState = 'welcome';
                }
            });
        }

        async function loadUserProfile() {
            if (!supabaseClient || !currentUser) return;

            try {
                const { data, error } = await supabaseClient
                    .from('profiles')
                    .select('*')
                    .eq('id', currentUser.id)
                    .single();

                if (error) {
                    // Keep fallback profile that was already set
                } else if (data) {
                    userProfile = data;

                    // Sync playerStats with loaded profile data
                    playerStats = {
                        total_games: data.total_games || 0,
                        high_score: data.high_score || 0,
                        total_score: data.total_score || 0,
                        total_bananas: data.total_bananas || 0,
                        spendable_bananas: data.spendable_bananas || 0,
                        total_time_played: data.total_time_played || 0,
                        jetpacks_collected: data.jetpacks_collected || 0,
                        dino_stomps_collected: data.dino_stomps_collected || 0,
                        bubbles_collected: data.bubbles_collected || 0,
                        bubble_hits_absorbed: data.bubble_hits_absorbed || 0,
                        pogos_collected: data.pogos_collected || 0,
                        lions_collected: data.lions_collected || 0,
                        turtles_collected: data.turtles_collected || 0,
                        stars_collected: data.stars_collected || 0,
                        snow_games_played: data.snow_games_played || 0,
                        desert_games_played: data.desert_games_played || 0,
                        jungle_games_played: data.jungle_games_played || 0,
                        ocean_games_played: data.ocean_games_played || 0,
                        snow_best_score: data.snow_best_score || 0,
                        desert_best_score: data.desert_best_score || 0,
                        jungle_best_score: data.jungle_best_score || 0,
                        ocean_best_score: data.ocean_best_score || 0,
                        first_game_at: data.first_game_at || null,
                        last_game_at: data.last_game_at || null,
                        highest_level_reached: data.highest_level_reached || 0,
                        times_reached_rank_one: data.times_reached_rank_one || 0,
                        total_purchases: data.total_purchases || 0,
                        total_spent: data.total_spent || 0,
                        multiplayer_games: data.multiplayer_games || 0,
                        multiplayer_wins: data.multiplayer_wins || 0
                    };

                    // Initialize lands played set from loaded data
                    landsPlayed = new Set();
                    if (data.snow_games_played > 0) landsPlayed.add('snow');
                    if (data.desert_games_played > 0) landsPlayed.add('desert');
                    if (data.jungle_games_played > 0) landsPlayed.add('jungle');
                    if (data.ocean_games_played > 0) landsPlayed.add('ocean');
                }

                // Also load skins and achievements
                await loadPlayerProgress();
            } catch (err) {
                // Keep fallback profile that was already set
            }
        }

        // Convert username to internal email format for Supabase auth
        function usernameToEmail(username) {
            return `${username.toLowerCase()}@banana-jump.local`;
        }

        async function signUp(username, password) {
            if (!supabaseClient) {
                showAuthError('Supabase not configured');
                return false;
            }

            // Validate username
            if (username.length < 3) {
                showAuthError('Username must be at least 3 characters');
                return false;
            }
            if (!/^[a-zA-Z0-9_]+$/.test(username)) {
                showAuthError('Username can only contain letters, numbers, and underscores');
                return false;
            }

            const email = usernameToEmail(username);

            const { data, error } = await supabaseClient.auth.signUp({
                email,
                password,
                options: {
                    data: { username }
                }
            });

            if (error) {
                // Make error messages more user-friendly
                if (error.message.includes('already registered')) {
                    showAuthError('Username already taken');
                } else {
                    showAuthError(error.message);
                }
                return false;
            }

            // Create profile
            if (data.user) {
                const { error: profileError } = await supabaseClient
                    .from('profiles')
                    .upsert({
                        id: data.user.id,
                        username: username
                    });

                if (profileError) {
                    console.error('Profile creation error:', profileError);
                }
            }

            // Auto-login after signup (since email confirmation is disabled)
            if (data.session && data.user) {
                // Session already exists, user is logged in
                // Set user immediately (don't wait for onAuthStateChange)
                currentUser = data.user;
                // Set a basic profile immediately (the upsert above created it)
                userProfile = { id: data.user.id, username: username };
                updateUserDisplay();
                closeAuthModal();
                return true;
            } else {
                // Manually sign in if no session returned
                const signInResult = await signIn(username, password);
                return signInResult;
            }
        }

        async function signIn(username, password) {
            if (!supabaseClient) {
                showAuthError('Supabase not configured');
                return false;
            }

            // Check if already logged in (e.g., from another tab)
            const { data: { session: existingSession } } = await supabaseClient.auth.getSession();
            if (existingSession) {
                // Already authenticated - just load profile and proceed
                currentUser = existingSession.user;
                userProfile = {
                    id: currentUser.id,
                    username: currentUser.user_metadata?.username || 'Player'
                };
                await loadUserProfileWithTimeout();
                updateUserDisplay();
                closeAuthModal();
                return true;
            }

            const email = usernameToEmail(username);

            try {
                const { data, error } = await supabaseClient.auth.signInWithPassword({
                    email,
                    password
                });

                if (error) {
                    if (error.message.includes('Invalid login')) {
                        showAuthError('Invalid username or password');
                    } else {
                        showAuthError(error.message);
                    }
                    return false;
                }

                if (data && data.user) {
                    currentUser = data.user;
                    userProfile = {
                        id: data.user.id,
                        username: data.user.user_metadata?.username || 'Player'
                    };

                    await loadUserProfileWithTimeout();
                    updateUserDisplay();
                    closeAuthModal();
                    return true;
                } else {
                    showAuthError('Login failed - please try again');
                    return false;
                }
            } catch (err) {
                console.error('SignIn error:', err);
                showAuthError('Login failed - please try again');
                return false;
            }
        }

        // Helper to load profile with timeout protection
        async function loadUserProfileWithTimeout() {
            try {
                const profilePromise = loadUserProfile();
                const timeoutPromise = new Promise((_, reject) =>
                    setTimeout(() => reject(new Error('timeout')), 5000)
                );
                await Promise.race([profilePromise, timeoutPromise]);
            } catch (err) {
                // Profile load failed/timed out, fallback profile already set
            }
        }

        async function logout() {
            if (!supabaseClient) return;

            await supabaseClient.auth.signOut();
            currentUser = null;
            userProfile = null;
            updateUserDisplay();
            gameState = 'welcome';
        }

        // ============================================
        // SCORE PERSISTENCE
        // ============================================
        async function saveScore(finalScore, bananas, landPlayed, isMultiplayer = false, didWin = false) {
            console.log('[SaveScore] Called with:', { finalScore, bananas, landPlayed, isMultiplayer, didWin });
            console.log('[SaveScore] User profile:', userProfile ? { id: userProfile.id, username: userProfile.username, high_score: userProfile.high_score } : 'null');

            if (!supabaseClient || !currentUser) {
                console.log('[SaveScore] Aborting - no supabase or user');
                return;
            }

            // Calculate game duration in seconds (gameTime is in frames at 60fps)
            const gameDurationSeconds = Math.floor(gameTime / 60);

            // Save to game_sessions with basic tracked data
            // Note: Only using columns that exist in the base schema
            const { error: sessionError } = await supabaseClient
                .from('game_sessions')
                .insert({
                    player_id: currentUser.id,
                    score: finalScore,
                    bananas_collected: bananas,
                    land_played: landPlayed,
                    game_mode: isMultiplayer ? 'multiplayer' : 'solo',
                    duration: gameDurationSeconds
                });

            if (sessionError) {
                console.error('Error saving session:', sessionError);
                // Don't return - still try to update profile even if session save fails
            }

            // Update profile stats - ONLY high_score to minimize failure points
            if (userProfile) {
                console.log('[SaveScore] Starting profile update...');
                console.log('[SaveScore] Current user ID:', currentUser.id);

                // Check if this is a new high score
                const isNewHighScore = finalScore > (userProfile.high_score || 0);
                console.log('[SaveScore] High score check:', {
                    finalScore: finalScore,
                    currentHighScore: userProfile.high_score || 0,
                    isNewHighScore: isNewHighScore
                });

                if (isNewHighScore) {
                    console.log('[SaveScore] NEW HIGH SCORE! Attempting to save:', finalScore);

                    // MINIMAL UPDATE - just high_score to avoid any column issues
                    const { data, error: updateError } = await supabaseClient
                        .from('profiles')
                        .update({ high_score: finalScore })
                        .eq('id', currentUser.id)
                        .select();

                    console.log('[SaveScore] Update response:', { data, error: updateError });

                    if (updateError) {
                        console.error('[SaveScore] ERROR updating high score:', updateError);
                    } else {
                        console.log('[SaveScore] SUCCESS! High score updated to:', finalScore);
                        userProfile.high_score = finalScore;
                    }
                }

                // Now try to update other stats separately (so high score isn't blocked)
                try {
                    const now = new Date().toISOString();
                    const otherUpdates = {
                        total_games: (userProfile.total_games || 0) + 1,
                        total_bananas: (userProfile.total_bananas || 0) + bananas,
                        total_score: (userProfile.total_score || 0) + finalScore,
                        spendable_bananas: (userProfile.spendable_bananas || 0) + bananas,
                        last_game_at: now
                    };

                    const { error: statsError } = await supabaseClient
                        .from('profiles')
                        .update(otherUpdates)
                        .eq('id', currentUser.id);

                    if (statsError) {
                        console.error('[SaveScore] Error updating other stats:', statsError);
                    } else {
                        console.log('[SaveScore] Other stats updated successfully');
                        userProfile = { ...userProfile, ...otherUpdates };
                        spendableBananas = userProfile.spendable_bananas;
                        Object.assign(playerStats, otherUpdates);
                    }
                } catch (err) {
                    console.error('[SaveScore] Exception updating stats:', err);
                }
            }

            console.log('[SaveScore] Complete. Final userProfile.high_score:', userProfile?.high_score);
        }

        async function getLeaderboard(land = null, limit = 10) {
            if (!supabaseClient) return [];

            let query = supabaseClient
                .from('leaderboard')
                .select('*')
                .order('high_score', { ascending: false })
                .limit(limit);

            if (land) {
                // Get land-specific leaderboard from game_sessions
                const { data, error } = await supabaseClient
                    .from('game_sessions')
                    .select('player_id, score, profiles!inner(username)')
                    .eq('land_played', land)
                    .order('score', { ascending: false })
                    .limit(limit);

                return data || [];
            }

            const { data, error } = await query;
            return data || [];
        }

        // Fetch stats for game over screen
        async function fetchGameOverStats(currentScore, landPlayed) {
            gameOverStats.loading = true;

            if (!supabaseClient) {
                gameOverStats.loading = false;
                return;
            }

            try {
                // Fetch global top score (from profiles - overall high score)
                const { data: globalData } = await supabaseClient
                    .from('profiles')
                    .select('username, high_score')
                    .order('high_score', { ascending: false })
                    .limit(1)
                    .single();

                if (globalData) {
                    gameOverStats.globalTopScore = globalData.high_score;
                    gameOverStats.globalTopPlayer = globalData.username;
                    gameOverStats.isNewGlobalBest = currentUser && currentScore > globalData.high_score;

                    // Track reaching #1 rank
                    if (gameOverStats.isNewGlobalBest && currentUser) {
                        playerStats.times_reached_rank_one = (playerStats.times_reached_rank_one || 0) + 1;

                        // Persist to database
                        await supabaseClient
                            .from('profiles')
                            .update({ times_reached_rank_one: playerStats.times_reached_rank_one })
                            .eq('id', currentUser.id);

                        if (userProfile) {
                            userProfile.times_reached_rank_one = playerStats.times_reached_rank_one;
                        }

                        // Check leaderboard achievement immediately
                        checkLeaderboardAchievement();
                    }
                }

                // Fetch biome/land top score
                const { data: biomeData } = await supabaseClient
                    .from('game_sessions')
                    .select('score, profiles!inner(username)')
                    .eq('land_played', landPlayed)
                    .order('score', { ascending: false })
                    .limit(1)
                    .single();

                if (biomeData) {
                    gameOverStats.biomeTopScore = biomeData.score;
                    gameOverStats.biomeTopPlayer = biomeData.profiles?.username || 'Unknown';
                }

                // Fetch personal best for this biome (only if logged in)
                if (currentUser) {
                    const { data: personalData } = await supabaseClient
                        .from('game_sessions')
                        .select('score')
                        .eq('player_id', currentUser.id)
                        .eq('land_played', landPlayed)
                        .order('score', { ascending: false })
                        .limit(1)
                        .single();

                    if (personalData) {
                        // This is the previous best (before this game was saved)
                        gameOverStats.personalBiomeBest = personalData.score;
                        gameOverStats.isNewBiomeBest = currentScore > personalData.score;
                    } else {
                        // First time playing this biome
                        gameOverStats.personalBiomeBest = 0;
                        gameOverStats.isNewBiomeBest = true;
                    }
                }
            } catch (err) {
                console.error('Error fetching game over stats:', err);
            }

            gameOverStats.loading = false;
        }

        // ============================================
        // MULTIPLAYER LOBBY FUNCTIONS
        // ============================================
        async function createLobby() {
            if (!supabaseClient || !currentUser) return null;

            const lobbyCode = Math.random().toString(36).substring(2, 8).toUpperCase();

            const { data, error } = await supabaseClient
                .from('game_lobbies')
                .insert({
                    code: lobbyCode,
                    host_id: currentUser.id,
                    land: selectedLand,
                    status: 'waiting'
                })
                .select()
                .single();

            if (error) {
                console.error('Error creating lobby:', error);
                return null;
            }

            currentLobby = data;
            isLobbyHost = true;
            await joinLobbyAsPlayer(data.id);
            subscribeLobbyUpdates(data.id);
            return data;
        }

        async function findOrCreateLobby() {
            if (!supabaseClient || !currentUser) return;

            // First try to find an existing waiting lobby
            const { data: existingLobbies, error } = await supabaseClient
                .from('game_lobbies')
                .select('*')
                .eq('status', 'waiting')
                .neq('host_id', currentUser.id)
                .order('created_at', { ascending: true })
                .limit(1);

            if (existingLobbies && existingLobbies.length > 0) {
                // Join existing lobby
                currentLobby = existingLobbies[0];
                isLobbyHost = false;
                selectedLand = currentLobby.land;
                await joinLobbyAsPlayer(currentLobby.id);
                subscribeLobbyUpdates(currentLobby.id);
            } else {
                // Create new lobby
                await createLobby();
            }

            gameState = 'lobby';
        }

        async function joinLobbyAsPlayer(lobbyId) {
            if (!supabaseClient || !currentUser) return;

            const { error } = await supabaseClient
                .from('lobby_players')
                .insert({
                    lobby_id: lobbyId,
                    player_id: currentUser.id,
                    is_ready: true  // Joining = ready (no toggle needed)
                });

            if (error) {
                console.error('Error joining lobby:', error);
            }
        }

        function subscribeLobbyUpdates(lobbyId) {
            if (!supabaseClient) return;

            // Subscribe to lobby changes
            lobbySubscription = supabaseClient
                .channel(`lobby:${lobbyId}`)
                .on('postgres_changes',
                    { event: '*', schema: 'public', table: 'lobby_players', filter: `lobby_id=eq.${lobbyId}` },
                    (payload) => {
                        loadLobbyPlayers(lobbyId);
                    }
                )
                .on('postgres_changes',
                    { event: 'UPDATE', schema: 'public', table: 'game_lobbies', filter: `id=eq.${lobbyId}` },
                    (payload) => {
                        if (payload.new.status === 'playing') {
                            startMultiplayerGame();
                        }
                    }
                )
                .subscribe();

            loadLobbyPlayers(lobbyId);
        }

        async function loadLobbyPlayers(lobbyId) {
            if (!supabaseClient) return;

            const { data, error } = await supabaseClient
                .from('lobby_players')
                .select('*, profiles:player_id(username)')
                .eq('lobby_id', lobbyId)
                .order('joined_at', { ascending: true });

            if (data) {
                lobbyPlayers = data;

                // Calculate local player index for multiplayer rendering
                const myIndex = data.findIndex(p => currentUser && p.player_id === currentUser.id);
                if (myIndex !== -1) {
                    localPlayerIndex = myIndex;
                }
            }
        }

        // toggleReady is no longer needed - joining = ready
        async function toggleReady() {
            // Deprecated - kept for compatibility
            if (!supabaseClient || !currentUser || !currentLobby) return;

            const currentPlayer = lobbyPlayers.find(p => p.player_id === currentUser.id);
            if (!currentPlayer) return;

            await supabaseClient
                .from('lobby_players')
                .update({ is_ready: !currentPlayer.is_ready })
                .eq('lobby_id', currentLobby.id)
                .eq('player_id', currentUser.id);
        }

        async function startLobbyGame() {
            if (!supabaseClient || !currentLobby || !isLobbyHost) return;

            await supabaseClient
                .from('game_lobbies')
                .update({ status: 'playing' })
                .eq('id', currentLobby.id);
        }

        // Visual stagger: each player is 60px apart horizontally
        const PLAYER_STAGGER_X = 60;

        function startMultiplayerGame() {
            gameMode = 'multiplayer';
            localPlayerAlive = true;
            gameResult = null;

            // Initialize seeded random with shared seed for synchronized obstacles
            if (multiplayerGameSeed) {
                initGameSeed(multiplayerGameSeed);
            } else {
                // Fallback: use lobby ID as seed if no seed received
                const fallbackSeed = currentLobby?.id ?
                    currentLobby.id.split('').reduce((a, c) => a + c.charCodeAt(0), 0) :
                    Date.now();
                initGameSeed(fallbackSeed);
                console.warn('[Game] No seed received, using fallback:', fallbackSeed);
            }

            // Initialize all players states from lobby
            initializeMultiplayerPlayers();

            // Start the game
            startGame();

            // Position local player based on their index (host rightmost, joiners to left)
            if (player) {
                const playerCount = lobbyPlayers.length;
                player.x = 80 + ((playerCount - 1 - localPlayerIndex) * PLAYER_STAGGER_X);
            }

            // Subscribe to game updates from all players
            if (supabaseClient && currentLobby) {
                subscribeGameUpdates();
            }
        }

        function initializeMultiplayerPlayers() {
            // Create player state objects for all lobby players
            // Position: host (index 0) is RIGHTMOST, joiners to the LEFT in join order
            const playerCount = lobbyPlayers.length;
            allPlayersStates = {};
            multiplayerPlayers = lobbyPlayers.map((lp, index) => {
                // Reverse the X position: host at right, later joiners at left
                const xPosition = 80 + ((playerCount - 1 - index) * PLAYER_STAGGER_X);
                const playerState = {
                    id: lp.player_id,
                    username: lp.profiles?.username || 'Player',
                    playerIndex: index,
                    x: xPosition,
                    yOffset: 0,  // Offset from ground (0 = standing, negative = jumping)
                    score: 0,
                    bananas: 0,
                    isAlive: true,
                    isLocal: lp.player_id === currentUser?.id
                };
                allPlayersStates[lp.player_id] = playerState;
                return playerState;
            });

            // Find local player index
            localPlayerIndex = multiplayerPlayers.findIndex(p => p.isLocal);
        }

        let gameChannelReady = false;

        function subscribeGameUpdates() {
            if (!supabaseClient || !currentLobby) return;

            // Clean up existing channel
            if (gameChannel) {
                supabaseClient.removeChannel(gameChannel);
                gameChannel = null;
            }
            gameChannelReady = false;

            gameChannel = supabaseClient
                .channel(`game:${currentLobby.id}`)
                .on('broadcast', { event: 'player_update' }, (payload) => {
                    const data = payload.payload;
                    if (data.playerId !== currentUser?.id) {
                        // Update remote player state
                        if (allPlayersStates[data.playerId]) {
                            // Store yOffset (offset from ground) for screen-size-independent positioning
                            allPlayersStates[data.playerId].yOffset = data.yOffset || 0;
                            allPlayersStates[data.playerId].score = data.score;
                            allPlayersStates[data.playerId].bananas = data.bananas;
                            allPlayersStates[data.playerId].isAlive = data.isAlive;
                            allPlayersStates[data.playerId].skin = data.skin || 'default';
                            // Debug: log received state occasionally
                            if (Math.random() < 0.02) { // ~2% of updates to reduce spam
                                console.log(`[Received] ${allPlayersStates[data.playerId].username}: score=${data.score}, bananas=${data.bananas}, yOffset=${data.yOffset}`);
                            }
                        }

                        // Check if all players are dead
                        checkRoundOver();
                    }
                })
                .on('broadcast', { event: 'round_over' }, (payload) => {
                    // Someone detected round is over - transition everyone
                    if (gameState === 'playing') {
                        // Update final states from payload
                        if (payload.payload?.finalStates) {
                            Object.assign(allPlayersStates, payload.payload.finalStates);
                        }
                        endMultiplayerRound();
                    }
                })
                .on('broadcast', { event: 'play_again' }, async (payload) => {
                    // Host triggered play again - includes new seed
                    if (gameState === 'multiplayer-results') {
                        if (payload.payload?.seed) {
                            multiplayerGameSeed = payload.payload.seed;
                            console.log(`[Play Again] Received seed: ${multiplayerGameSeed}`);
                        }
                        // Reload active players from database to remove anyone who left
                        await resetMultiplayerGame();
                    }
                })
                .on('broadcast', { event: 'game_seed' }, (payload) => {
                    // Receive seed from host before game starts
                    if (payload.payload?.seed) {
                        multiplayerGameSeed = payload.payload.seed;
                        console.log(`[Game] Received seed from host: ${multiplayerGameSeed}`);
                    }
                })
                .subscribe((status) => {
                    if (status === 'SUBSCRIBED') {
                        gameChannelReady = true;
                        // Send initial state once connected
                        broadcastPlayerState();
                    }
                });
        }

        function broadcastPlayerState() {
            if (!gameChannel || !gameChannelReady || gameMode !== 'multiplayer') return;

            // Calculate Y offset from ground (negative when jumping)
            // This normalizes across different screen sizes
            const yOffset = player ? (player.y - player.groundY) : 0;

            gameChannel.send({
                type: 'broadcast',
                event: 'player_update',
                payload: {
                    playerId: currentUser?.id,
                    playerIndex: localPlayerIndex,
                    yOffset: yOffset,  // Offset from ground, not absolute Y
                    score: score,
                    bananas: bananasCollected,
                    isAlive: localPlayerAlive,
                    skin: selectedSkin  // Include skin for visual rendering
                }
            });
        }

        function checkRoundOver() {
            if (gameMode !== 'multiplayer' || gameState !== 'playing') return;

            // Check if all players are dead
            const allDead = Object.values(allPlayersStates).every(p => !p.isAlive);
            if (allDead) {
                // Broadcast round_over to ensure everyone transitions
                if (gameChannel && gameChannelReady) {
                    gameChannel.send({
                        type: 'broadcast',
                        event: 'round_over',
                        payload: { finalStates: allPlayersStates }
                    });
                }
                endMultiplayerRound();
            }
        }

        function endMultiplayerRound() {
            if (gameState === 'multiplayer-results') return; // Already ended

            // Determine results - sort by score descending
            const results = Object.values(allPlayersStates)
                .sort((a, b) => b.score - a.score);

            // Find local player's position
            const localResult = results.find(p => p.isLocal);
            if (localResult) {
                const position = results.indexOf(localResult);
                if (position === 0) {
                    gameResult = 'win';
                } else {
                    gameResult = 'lose';
                }
            }

            // Save score for local player and check achievements
            if (currentUser && !scoreSaved) {
                scoreSaved = true;
                const gameTimeSeconds = Math.floor(gameTime / 60);
                const didWin = gameResult === 'win';

                // Wait for score to save (with multiplayer flags), then check achievements
                saveScore(score, bananasCollected, selectedLand, true, didWin).then(() => {
                    checkAchievements(score, bananasCollected, gameTimeSeconds, true, didWin);
                });
            }

            gameState = 'multiplayer-results';
        }

        // Legacy function for compatibility
        function broadcastGameState(isGameOver = false) {
            broadcastPlayerState();
        }

        async function leaveLobby() {
            if (!supabaseClient || !currentLobby) {
                gameState = 'menu';
                return;
            }

            // Unsubscribe from updates
            if (lobbySubscription) {
                supabaseClient.removeChannel(lobbySubscription);
                lobbySubscription = null;
            }

            // Remove player from lobby
            await supabaseClient
                .from('lobby_players')
                .delete()
                .eq('lobby_id', currentLobby.id)
                .eq('player_id', currentUser.id);

            // If host, delete the lobby
            if (isLobbyHost) {
                await supabaseClient
                    .from('game_lobbies')
                    .delete()
                    .eq('id', currentLobby.id);
            }

            currentLobby = null;
            lobbyPlayers = [];
            isLobbyHost = false;
            gameState = 'menu';
        }

        // New multiplayer functions for Create/Join flow
        async function createNewLobby() {
            if (!supabaseClient || !currentUser) return;

            const code = await generateLobbyCode();
            const { data, error } = await supabaseClient
                .from('game_lobbies')
                .insert({
                    code: code,
                    host_id: currentUser.id,
                    land: selectedLand,
                    status: 'waiting'
                })
                .select()
                .single();

            if (error) {
                console.error('Error creating lobby:', error);
                return;
            }

            currentLobby = data;
            isLobbyHost = true;
            await joinLobbyAsPlayer(currentLobby.id);
            subscribeLobbyUpdates(currentLobby.id);
            gameState = 'lobby';
        }

        // ============================================
        // MEMORABLE LOBBY WORDS (6 letters, child-friendly)
        // ============================================
        const LOBBY_WORDS = [
            // Animals
            'MONKEY', 'BANANA', 'TURTLE', 'RABBIT', 'KITTEN', 'PUPPY', 'DRAGON', 'PARROT',
            'PANDA', 'TIGER', 'LION', 'ZEBRA', 'GOPHER', 'BADGER', 'BEAVER', 'FALCON',
            'CONDOR', 'JAGUAR', 'COUGAR', 'DONKEY', 'LIZARD', 'IGUANA', 'SALMON', 'SHRIMP',
            'OYSTER', 'HERMIT', 'CANARY', 'TOUCAN', 'SPIDER', 'BEETLE', 'CICADA', 'MANTIS',
            'WALRUS', 'GIBBON', 'BABOON', 'FERRET', 'WEASEL', 'POSSUM', 'ALPACA', 'VICUNA',
            // Food & Drinks
            'CHEESE', 'COOKIE', 'MUFFIN', 'WAFFLE', 'NOODLE', 'PICKLE', 'TOMATO', 'POTATO',
            'CARROT', 'CELERY', 'PEPPER', 'RADISH', 'TURNIP', 'SQUASH', 'CHERRY', 'ORANGE',
            'LEMON', 'MANGO', 'PAPAYA', 'GRAPES', 'MELON', 'APPLES', 'COFFEE', 'BUTTER',
            'YOGURT', 'PASTRY', 'DONUT', 'BAGEL', 'PRETZE', 'CEREAL', 'OATMEA', 'TACOS',
            'NACHOS', 'FUDGE', 'TOFFEE', 'SUNDAE', 'SORBET', 'GELATO', 'MOUSSE', 'TRUFFLE',
            // Nature & Weather
            'FOREST', 'GARDEN', 'MEADOW', 'VALLEY', 'CANYON', 'ISLAND', 'LAGOON', 'STREAM',
            'BREEZE', 'SUMMER', 'WINTER', 'SPRING', 'AUTUMN', 'SUNSET', 'CLOUDS', 'STORMY',
            'SNOWY', 'FROSTY', 'MISTY', 'FLOWER', 'POLLEN', 'PEBBLE', 'GRAVEL', 'BAMBOO',
            'WILLOW', 'MAPLE', 'SPRUCE', 'JUNGLE', 'DESERT', 'TUNDRA', 'ARCTIC', 'TROPIC',
            'CORAL', 'OYSTER', 'FOSSIL', 'MARBLE', 'QUARTZ', 'COPPER', 'SILVER', 'GOLDEN',
            // Colors & Patterns
            'PURPLE', 'YELLOW', 'ORANGE', 'INDIGO', 'VIOLET', 'MAROON', 'SALMON', 'CORAL',
            'GOLDEN', 'SILVER', 'BRONZE', 'STRIPE', 'POLKA', 'ZIGZAG', 'SWIRLY', 'DOTTED',
            'BRIGHT', 'GLOSSY', 'SHINY', 'SPARKL', 'GLITTE', 'PASTEL', 'NEON',
            // Objects & Things
            'ROCKET', 'PLANET', 'METEOR', 'COMET', 'GALAXY', 'CASTLE', 'PALACE', 'THRONE',
            'CROWN', 'SHIELD', 'SWORD', 'HELMET', 'ARMOR', 'BANNER', 'TROPHY', 'MEDAL',
            'RIBBON', 'BUTTON', 'ZIPPER', 'POCKET', 'BASKET', 'BUCKET', 'MIRROR', 'PILLOW',
            'BLANKE', 'CANDLE', 'LANTERN', 'BEACON', 'BRIDGE', 'TUNNEL', 'TOWERS', 'TEMPLE',
            'MARKET', 'BAKERY', 'CIRCUS', 'ARCADE', 'MUSEUM', 'STUDIO', 'GARAGE', 'CABINS',
            // Actions & Adjectives
            'JUMPIN', 'RUNNIN', 'DANCIN', 'FLYING', 'SWIMMI', 'BOUNCI', 'ZOOMIN', 'RACIN',
            'SMILIN', 'LAUGHI', 'HAPPY', 'JOLLY', 'MERRY', 'CHEERF', 'PLAYFU', 'CLEVER',
            'MIGHTY', 'SPEEDY', 'SNAPPY', 'GROOVY', 'FUNKY', 'WACKY', 'ZANY', 'SILLY',
            'GOOFY', 'FLUFFY', 'FUZZY', 'CRISPY', 'CRUNCHY', 'SQUISHY', 'BOUNCY', 'WIGGLY',
            // Fantasy & Magic
            'WIZARD', 'FAERIE', 'SPRITE', 'GOBLIN', 'TROLL', 'GNOME', 'PIXIE', 'MERMAID',
            'UNICOR', 'PHOENIX', 'GRIFFIN', 'KRAKEN', 'SPIRIT', 'MAGICA', 'MYSTIC', 'LEGEND',
            'MYTHIC', 'COSMIC', 'ASTRAL', 'DREAMM', 'FANTSY', 'WONDER', 'MARVEL', 'ENIGMA',
            // Music & Sound
            'MELODY', 'RHYTHM', 'JINGLE', 'CHIMES', 'WHISPE', 'ECHOES', 'STEREO', 'TEMPO',
            'GUITAR', 'VIOLIN', 'FLUTE', 'DRUMS', 'PIANO', 'TRUMPE', 'CYMBAL', 'UKULEL',
            // Sports & Games
            'SOCCER', 'TENNIS', 'HOCKEY', 'BASKET', 'VOLLEY', 'RACKET', 'TROPHY', 'ARCADE',
            'PUZZLE', 'RIDDLE', 'TRIVIA', 'BINGO', 'CHESS', 'DOMINO', 'MARBLE', 'JIGSAW',
            // Places & Geography
            'ALASKA', 'HAWAII', 'LONDON', 'PARIS', 'TOKYO', 'SYDNEY', 'DENVER', 'AUSTIN',
            'BOSTON', 'DALLAS', 'MIAMI', 'VEGAS', 'SEATTLE', 'CHICAGO', 'BERLIN', 'MADRID',
            // Space & Science
            'NEBULA', 'QUASAR', 'PULSAR', 'PHOTON', 'PROTON', 'NEUTRON', 'PLASMA', 'ATOMIC',
            'CARBON', 'OXYGEN', 'HELIUM', 'NEON', 'ARGON', 'XENON', 'RADON', 'KRYPTON',
            // Misc Fun Words
            'DOODLE', 'NOODLE', 'GIGGLE', 'WIGGLE', 'JIGGLE', 'BUBBLE', 'PEBBLE', 'NIBBLE',
            'WOBBLE', 'COBBLE', 'GOBBLE', 'HOBBIT', 'WADDLE', 'PADDLE', 'SADDLE', 'FIDDLE',
            'RIDDLE', 'MIDDLE', 'PUDDLE', 'CUDDLE', 'MUDDLE', 'HUDDLE', 'BUMBLE', 'HUMBLE',
            'JUMBLE', 'MUMBLE', 'RUMBLE', 'TUMBLE', 'FUMBLE', 'CRUMBL', 'GRUMBL', 'STUMBL',
            'JUNGLE', 'BUNGLE', 'TANGLE', 'MANGLE', 'DANGLE', 'JANGLE', 'WRANGLE', 'SPANGLE',
            'TWINKL', 'SPRINKL', 'CRINKL', 'WRINKL', 'TINKLE', 'JINGLE', 'MINGLE', 'SINGLE',
            'SIMPLE', 'DIMPLE', 'PIMPLE', 'RIPPLE', 'NIPPLE', 'TIPPLE', 'SUPPLE', 'PURPLE',
            'TURTLE', 'HURTLE', 'MYRTLE', 'RUSTLE', 'BUSTLE', 'HUSTLE', 'MUSCLE', 'CASTLE',
            'HASSLE', 'TASSEL', 'VESSEL', 'NESTLE', 'WRESTL', 'THISTLE', 'WHISTLE', 'BRISTLE',
            // More Animals
            'BEAGLE', 'POODLE', 'COLLIE', 'HUSKY', 'CORGI', 'DACHSH', 'TERRIE', 'SETTER',
            'HERON', 'CRANE', 'STORK', 'EGRET', 'PELICA', 'SEAGUL', 'PIGEON', 'SPAROW',
            'FINCH', 'ROBIN', 'THRUSH', 'WREN', 'RAVEN', 'MAGPIE', 'BLUEJA', 'CARDIN',
            'CONDOR', 'VULTUR', 'OSPREY', 'KESTRL', 'PEREGR', 'MERLIN', 'HOBBY',
            // Food continued
            'BISCUI', 'CRUMPE', 'SCONE', 'CROISS', 'DANISH', 'ECLAIR', 'CANOLI', 'STRUDE',
            'COBBLE', 'CRISP', 'TART', 'TORTE', 'GATEAU', 'FONDUO', 'RACLTTE', 'QUICHE',
            'BISQUE', 'CHOWDE', 'GUMBO', 'JAMBAL', 'PAELLA', 'RISOTT', 'GNOCCHI', 'RAVIOL',
            'TORTLL', 'BURRIT', 'FAJITA', 'TAMALE', 'ENCHIA', 'QUESAD', 'SALSA', 'GUACAM',
            // Ocean & Beach
            'ANCHOR', 'SAILOR', 'PIRATE', 'CAPTAI', 'VOYAGE', 'HARBOR', 'MARINA', 'LIGHTHOUSE',
            'BEACON', 'BUOY', 'KAYAK', 'CANOE', 'PADDLE', 'SURFIN', 'DIVING', 'SNORKL',
            'SCUBA', 'REEF', 'ATOLL', 'SHOAL', 'SANDBA', 'DRIFTW', 'SHELLS', 'CONCH',
            // Adventure
            'QUEST', 'SAFARI', 'VOYAGE', 'JOURNY', 'ADVENT', 'EXPLOR', 'DISCOV', 'TREASR',
            'BOUNTY', 'REWARD', 'SECRET', 'HIDDEN', 'MYSTIC', 'ENIGMA', 'PUZZLE', 'RIDDLE',
            // Positive Words
            'KINDLY', 'GENTLE', 'TENDER', 'CARING', 'LOVING', 'GIVING', 'HELPFUL', 'HONEST',
            'TRUSTY', 'LOYAL', 'BRAVE', 'BOLD', 'DARING', 'FIERCE', 'STRONG', 'MIGHTY',
            'HEROIC', 'NOBLE', 'ROYAL', 'REGAL', 'GRAND', 'SUPERB', 'DIVINE', 'BLISSS',
            // Technology
            'ROBOT', 'CYBORG', 'ANDROID', 'GADGET', 'WIDGET', 'DEVICE', 'GIZMO', 'TECHNO',
            'DIGITAL', 'BINARY', 'PIXEL', 'VECTOR', 'MATRIX', 'CIPHER', 'CRYPTO', 'QUANTUM',
            // Weather continued
            'BLIZZA', 'FLURRY', 'DRIZZL', 'SHOWRS', 'THUNDR', 'LIGHTN', 'TORNAD', 'CYCLONE',
            'TYPHOO', 'MONSOO', 'SQUALL', 'GUST', 'BREEZE', 'ZEPHYR', 'TRADES', 'JETSTR',
            // Buildings
            'CABIN', 'LODGE', 'CHALET', 'VILLA', 'MANOR', 'ESTATE', 'PALACE', 'CASTLE',
            'TOWER', 'TURRET', 'SPIRE', 'STEEPL', 'DOME', 'VAULT', 'CRYPT', 'CHAPEL',
            'ABBEY', 'PRIORY', 'CLOISTER', 'SHRINE', 'TEMPLE', 'PAGODA', 'MOSQUE', 'CATHEDRAL'
        ].filter(w => w.length === 6); // Ensure all are exactly 6 letters

        /**
         * Generate a unique lobby code from memorable words
         * Checks database to ensure code isn't already in use
         */
        async function generateLobbyCode() {
            // Shuffle and try words until we find an unused one
            const shuffled = [...LOBBY_WORDS].sort(() => Math.random() - 0.5);

            for (const word of shuffled.slice(0, 20)) { // Try up to 20 words
                if (supabaseClient) {
                    const { data: existing } = await supabaseClient
                        .from('game_lobbies')
                        .select('code')
                        .eq('code', word)
                        .eq('status', 'waiting')
                        .single();

                    if (!existing) {
                        return word; // Word is available
                    }
                } else {
                    return word; // No database, just return first word
                }
            }

            // Fallback: combine two short words or use random
            const fallback = LOBBY_WORDS[Math.floor(Math.random() * LOBBY_WORDS.length)];
            return fallback || Math.random().toString(36).substring(2, 8).toUpperCase();
        }

        async function joinLobbyWithCode() {
            if (!supabaseClient || !currentUser || !lobbyCodeInput) {
                lobbyJoinError = 'Please enter a lobby code';
                return;
            }

            const code = lobbyCodeInput.toUpperCase().trim();
            if (code.length !== 6) {
                lobbyJoinError = 'Code must be 6 characters';
                return;
            }

            // Find lobby by code
            const { data: lobby, error } = await supabaseClient
                .from('game_lobbies')
                .select('*')
                .eq('code', code)
                .eq('status', 'waiting')
                .single();

            if (error || !lobby) {
                lobbyJoinError = 'Lobby not found or game already started';
                return;
            }

            // Check if lobby is full
            const { data: players } = await supabaseClient
                .from('lobby_players')
                .select('id')
                .eq('lobby_id', lobby.id);

            if (players && players.length >= MAX_LOBBY_PLAYERS) {
                lobbyJoinError = 'Lobby is full (max 7 players)';
                return;
            }

            // Join the lobby
            currentLobby = lobby;
            isLobbyHost = false;
            selectedLand = lobby.land;
            await joinLobbyAsPlayer(currentLobby.id);
            subscribeLobbyUpdates(currentLobby.id);
            lobbyJoinError = '';
            gameState = 'lobby';
        }

        // Multiplayer game seed - shared across all players
        let multiplayerGameSeed = 0;

        async function hostStartGame() {
            if (!supabaseClient || !currentLobby || !isLobbyHost) return;
            if (lobbyPlayers.length < 2) return;

            // Generate a random seed for this game
            multiplayerGameSeed = Math.floor(Math.random() * 2147483647);
            console.log(`[Host] Generated game seed: ${multiplayerGameSeed}`);

            // First, ensure game channel is ready, then broadcast seed
            if (!gameChannel) {
                subscribeGameUpdates();
            }

            // Wait a moment for channel to be ready, then broadcast seed and start
            setTimeout(async () => {
                // Broadcast seed to all players
                if (gameChannel) {
                    gameChannel.send({
                        type: 'broadcast',
                        event: 'game_seed',
                        payload: { seed: multiplayerGameSeed }
                    });
                }

                // Update lobby status to trigger game start for all
                await supabaseClient
                    .from('game_lobbies')
                    .update({ status: 'playing' })
                    .eq('id', currentLobby.id);
            }, 500);
        }

        async function hostPlayAgain() {
            if (!supabaseClient || !currentLobby || !isLobbyHost) return;

            // Generate new seed for this round
            multiplayerGameSeed = Math.floor(Math.random() * 2147483647);
            console.log(`[Host] Generated new game seed for play again: ${multiplayerGameSeed}`);

            // Broadcast play again signal with new seed
            if (gameChannel) {
                gameChannel.send({
                    type: 'broadcast',
                    event: 'play_again',
                    payload: { seed: multiplayerGameSeed }
                });
            }

            // Start locally (reload players to remove anyone who left)
            await resetMultiplayerGame();
        }

        function leaveMultiplayerResults() {
            // Clean up and go to menu
            if (gameChannel) {
                supabaseClient.removeChannel(gameChannel);
                gameChannel = null;
            }
            if (lobbySubscription) {
                supabaseClient.removeChannel(lobbySubscription);
                lobbySubscription = null;
            }
            currentLobby = null;
            lobbyPlayers = [];
            isLobbyHost = false;
            multiplayerPlayers = [];
            allPlayersStates = {};
            gameMode = 'solo';
            gameState = 'menu';
        }

        async function resetMultiplayerGame() {
            // Reset local state for new round
            localPlayerAlive = true;
            gameResult = null;
            scoreSaved = false;

            // IMPORTANT: Reload lobby players from database to get current active players
            // This removes players who left during the previous round
            if (supabaseClient && currentLobby) {
                await loadLobbyPlayers(currentLobby.id);
                console.log(`[Reset] Reloaded ${lobbyPlayers.length} active players`);
            }

            // Initialize seeded random with shared seed for synchronized obstacles
            if (multiplayerGameSeed) {
                initGameSeed(multiplayerGameSeed);
            }

            // Reinitialize all players from lobby (only active players)
            initializeMultiplayerPlayers();

            // Start the game
            startGame();

            // Position local player based on their index (host rightmost, joiners to left)
            if (player) {
                const playerCount = lobbyPlayers.length;
                player.x = 80 + ((playerCount - 1 - localPlayerIndex) * PLAYER_STAGGER_X);
            }

            // Set game state to playing
            gameState = 'playing';
        }

        // ============================================
        // SKINS & ACHIEVEMENTS FUNCTIONS
        // ============================================
        async function loadPlayerProgress() {
            if (!supabaseClient || !currentUser) return;

            try {
                // Load unlocked skins
                const { data: skins, error: skinsError } = await supabaseClient
                    .from('player_skins')
                    .select('skin_id')
                    .eq('player_id', currentUser.id);

                if (!skinsError && skins) {
                    unlockedSkins = ['default', ...skins.map(s => s.skin_id)];
                }

                // Load equipped skin and spendable bananas from profile
                if (userProfile?.equipped_skin) {
                    selectedSkin = userProfile.equipped_skin;
                }
                // Load spendable bananas (default to total_bananas for migration)
                spendableBananas = userProfile?.spendable_bananas ?? userProfile?.total_bananas ?? 0;

                // Load achievements
                const { data: achievements, error: achievementsError } = await supabaseClient
                    .from('player_achievements')
                    .select('achievement_id')
                    .eq('player_id', currentUser.id);

                if (!achievementsError && achievements) {
                    unlockedAchievements = achievements.map(a => a.achievement_id);
                }
            } catch (err) {
                // Continue anyway - skins/achievements are not critical
            }
        }

        async function unlockSkin(skinId) {
            if (!supabaseClient || !currentUser || unlockedSkins.includes(skinId)) return;

            const { error } = await supabaseClient
                .from('player_skins')
                .insert({ player_id: currentUser.id, skin_id: skinId });

            if (!error) {
                unlockedSkins.push(skinId);
                showNotification(`Skin Unlocked: ${SKINS[skinId].name}!`);
            }
        }

        async function unlockAchievement(achievementId) {
            if (!currentUser || unlockedAchievements.includes(achievementId)) return;

            const achievement = ACHIEVEMENTS[achievementId];
            if (!achievement) return;

            // Persist to database
            if (supabaseClient) {
                const { error } = await supabaseClient
                    .from('player_achievements')
                    .insert({ player_id: currentUser.id, achievement_id: achievementId });

                if (error) {
                    console.error('Error unlocking achievement:', error);
                    return;
                }

                // Award banana reward
                if (achievement.reward > 0) {
                    spendableBananas += achievement.reward;

                    await supabaseClient
                        .from('profiles')
                        .update({ spendable_bananas: spendableBananas })
                        .eq('id', currentUser.id);

                    if (userProfile) {
                        userProfile.spendable_bananas = spendableBananas;
                    }
                }
            }

            unlockedAchievements.push(achievementId);
            showNotification(`Achievement: ${achievement.name}! +${achievement.reward} bananas`);
        }

        async function equipSkin(skinId) {
            if (!unlockedSkins.includes(skinId)) return;

            selectedSkin = skinId;

            if (supabaseClient && currentUser) {
                await supabaseClient
                    .from('profiles')
                    .update({ equipped_skin: skinId })
                    .eq('id', currentUser.id);
            }
        }

        async function purchaseSkin(skinId) {
            const skin = SKINS[skinId];

            // Validation
            if (!skin || skin.type !== 'purchasable') return;
            if (unlockedSkins.includes(skinId)) return; // Already owned
            if (spendableBananas < skin.price) return; // Can't afford

            // Deduct and unlock
            spendableBananas -= skin.price;
            unlockedSkins.push(skinId);
            showNotification(`Purchased: ${skin.name}!`);

            // Update local stats
            playerStats.total_purchases = (playerStats.total_purchases || 0) + 1;
            playerStats.total_spent = (playerStats.total_spent || 0) + skin.price;

            // Persist to Supabase
            if (supabaseClient && currentUser) {
                // Update profile with new balance and purchase stats
                const { error: updateError } = await supabaseClient
                    .from('profiles')
                    .update({
                        spendable_bananas: spendableBananas,
                        total_purchases: playerStats.total_purchases,
                        total_spent: playerStats.total_spent
                    })
                    .eq('id', currentUser.id);

                if (updateError) {
                    console.error('Error updating balance:', updateError);
                    // Rollback on error
                    spendableBananas += skin.price;
                    unlockedSkins = unlockedSkins.filter(s => s !== skinId);
                    playerStats.total_purchases--;
                    playerStats.total_spent -= skin.price;
                    return;
                }

                // Record skin purchase
                const { error: skinError } = await supabaseClient
                    .from('player_skins')
                    .insert({ player_id: currentUser.id, skin_id: skinId });

                if (skinError) {
                    console.error('Error recording skin:', skinError);
                }

                // Update local profile
                if (userProfile) {
                    userProfile.spendable_bananas = spendableBananas;
                    userProfile.total_purchases = playerStats.total_purchases;
                    userProfile.total_spent = playerStats.total_spent;
                }

                // Check purchase-related achievements
                checkPurchaseAchievements();
            }
        }

        /**
         * Check purchase-related achievements after a shop purchase
         */
        function checkPurchaseAchievements() {
            if (!userProfile) return;

            const purchaseAchievements = ['first_purchase', 'collector', 'shopaholic'];

            for (const achId of purchaseAchievements) {
                if (unlockedAchievements.includes(achId)) continue;

                const achievement = ACHIEVEMENTS[achId];
                if (!achievement) continue;

                const req = achievement.requirement;
                if (req.type === 'total_purchases' && playerStats.total_purchases >= req.value) {
                    unlockAchievement(achId);
                }
            }
        }

        /**
         * Check leaderboard achievement after reaching #1
         */
        function checkLeaderboardAchievement() {
            if (!userProfile) return;

            if (unlockedAchievements.includes('top_banana')) return;

            const achievement = ACHIEVEMENTS['top_banana'];
            if (!achievement) return;

            if (playerStats.times_reached_rank_one >= 1) {
                unlockAchievement('top_banana');
            }
        }

        /**
         * Check all achievements against current player stats
         * Called after each game to award any newly earned achievements
         * Note: This is called AFTER saveScore(), so playerStats should be updated
         */
        function checkAchievements(gameScore, gameBananas, gameTimeSeconds, isMultiplayer, didWin) {
            if (!userProfile) return;

            // Track land played locally
            landsPlayed.add(selectedLand);

            // Get the current land key for checking land-specific stats
            const landKey = selectedLand.toLowerCase();

            // Build current stats object for checking
            // Include the current game's contributions
            const stats = {
                // Core stats (playerStats should already include this game's data)
                total_games: playerStats.total_games || 0,
                high_score: Math.max(playerStats.high_score || 0, gameScore),
                total_bananas: playerStats.total_bananas || 0,
                total_time_played: (playerStats.total_time_played || 0) + gameTimeSeconds,
                jetpacks_collected: playerStats.jetpacks_collected || 0,
                dino_stomps_collected: playerStats.dino_stomps_collected || 0,
                highest_level_reached: Math.max(playerStats.highest_level_reached || 0, highestLevelReached),

                // New power-up stats
                bubbles_collected: playerStats.bubbles_collected || 0,
                bubble_hits_absorbed: playerStats.bubble_hits_absorbed || 0,
                pogos_collected: playerStats.pogos_collected || 0,
                lions_collected: playerStats.lions_collected || 0,
                turtles_collected: playerStats.turtles_collected || 0,
                stars_collected: playerStats.stars_collected || 0,

                // Land-specific (use playerStats which was just updated)
                snow_games_played: playerStats.snow_games_played || 0,
                desert_games_played: playerStats.desert_games_played || 0,
                jungle_games_played: playerStats.jungle_games_played || 0,
                ocean_games_played: playerStats.ocean_games_played || 0,

                // These need special handling since they're not always persisted
                times_reached_rank_one: playerStats.times_reached_rank_one || 0,
                total_purchases: playerStats.total_purchases || 0,

                // Multiplayer stats - add current game contribution
                multiplayer_games: (playerStats.multiplayer_games || 0) + (isMultiplayer ? 1 : 0),
                multiplayer_wins: (playerStats.multiplayer_wins || 0) + (isMultiplayer && didWin ? 1 : 0),

                // Special check for all lands
                all_lands_played: landsPlayed.size >= 4
            };

            // Check each achievement
            for (const [achievementId, achievement] of Object.entries(ACHIEVEMENTS)) {
                // Skip if already unlocked
                if (unlockedAchievements.includes(achievementId)) continue;

                const req = achievement.requirement;
                if (!req) continue;

                let shouldUnlock = false;

                // Special handling for all_lands_played
                if (req.type === 'all_lands_played') {
                    shouldUnlock = stats.all_lands_played;
                }
                // Standard numeric comparisons
                else if (stats[req.type] !== undefined) {
                    shouldUnlock = stats[req.type] >= req.value;
                }

                if (shouldUnlock) {
                    unlockAchievement(achievementId);
                }
            }

            // Check skin unlocks based on achievements
            // Pass multiplayer wins from this game
            const mpWinsThisGame = (isMultiplayer && didWin) ? 1 : 0;
            checkSkinUnlocks(gameScore, mpWinsThisGame);
        }

        function checkSkinUnlocks(gameScore, multiplayerWins = 0) {
            if (!userProfile) return;

            // Golden - 100 total bananas
            if ((userProfile.total_bananas || 0) >= 100) {
                unlockSkin('golden');
            }

            // Speedster - 5000 points in one game
            if (gameScore >= 5000) {
                unlockSkin('speedster');
            }

            // Veteran - 50 games
            if ((userProfile.total_games || 0) >= 50) {
                unlockSkin('veteran');
            }

            // Champion - 10 multiplayer wins
            const totalMpWins = (playerStats.multiplayer_wins || 0) + multiplayerWins;
            if (totalMpWins >= 10) {
                unlockSkin('champion');
            }
        }

        /**
         * Retroactively check all achievements against current player stats.
         * Fetches fresh data from database, checks each incomplete achievement,
         * and unlocks any that should have been earned.
         *
         * @returns {Promise<{checked: number, unlocked: number, newRewards: number}>}
         */
        async function checkAllAchievementsRetroactive() {
            if (!currentUser || !supabaseClient) {
                return { checked: 0, unlocked: 0, newRewards: 0 };
            }

            // Fetch fresh profile data from database
            const { data: profile, error } = await supabaseClient
                .from('profiles')
                .select('*')
                .eq('id', currentUser.id)
                .single();

            if (error || !profile) {
                console.error('Error fetching profile for achievement check:', error);
                return { checked: 0, unlocked: 0, newRewards: 0 };
            }

            // Also count actual purchased skins (in case total_purchases counter was broken)
            const { data: purchasedSkins } = await supabaseClient
                .from('player_skins')
                .select('skin_id')
                .eq('player_id', currentUser.id);

            // Count purchased skins (excluding 'default' which is free)
            const actualPurchaseCount = purchasedSkins
                ? purchasedSkins.filter(s => s.skin_id !== 'default').length
                : 0;

            // Use the higher of stored count or actual count
            const truePurchaseCount = Math.max(profile.total_purchases || 0, actualPurchaseCount);

            // Update local state with fresh data
            Object.assign(playerStats, {
                total_games: profile.total_games || 0,
                high_score: profile.high_score || 0,
                total_score: profile.total_score || 0,
                total_bananas: profile.total_bananas || 0,
                spendable_bananas: profile.spendable_bananas || 0,
                total_time_played: profile.total_time_played || 0,
                jetpacks_collected: profile.jetpacks_collected || 0,
                dino_stomps_collected: profile.dino_stomps_collected || 0,
                snow_games_played: profile.snow_games_played || 0,
                desert_games_played: profile.desert_games_played || 0,
                jungle_games_played: profile.jungle_games_played || 0,
                ocean_games_played: profile.ocean_games_played || 0,
                highest_level_reached: profile.highest_level_reached || 0,
                times_reached_rank_one: profile.times_reached_rank_one || 0,
                total_purchases: truePurchaseCount,
                total_spent: profile.total_spent || 0,
                multiplayer_games: profile.multiplayer_games || 0,
                multiplayer_wins: profile.multiplayer_wins || 0
            });

            // Also update userProfile
            if (userProfile) {
                Object.assign(userProfile, profile);
            }
            spendableBananas = profile.spendable_bananas || 0;

            // Check if user is currently #1 on leaderboard (for retroactive achievement)
            const { data: topPlayer } = await supabaseClient
                .from('profiles')
                .select('id, high_score')
                .order('high_score', { ascending: false })
                .limit(1)
                .single();

            // If user is currently #1 and times_reached_rank_one is 0, set it to 1
            const isCurrentlyRankOne = topPlayer && topPlayer.id === currentUser.id;
            let timesReachedRankOne = playerStats.times_reached_rank_one || 0;

            if (isCurrentlyRankOne && timesReachedRankOne === 0) {
                timesReachedRankOne = 1;
                playerStats.times_reached_rank_one = 1;

                // Also persist this to the database
                await supabaseClient
                    .from('profiles')
                    .update({ times_reached_rank_one: 1 })
                    .eq('id', currentUser.id);

                if (userProfile) {
                    userProfile.times_reached_rank_one = 1;
                }
            }

            // Build stats object for checking
            const stats = {
                total_games: playerStats.total_games,
                high_score: playerStats.high_score,
                total_bananas: playerStats.total_bananas,
                total_time_played: playerStats.total_time_played,
                jetpacks_collected: playerStats.jetpacks_collected,
                dino_stomps_collected: playerStats.dino_stomps_collected,
                highest_level_reached: playerStats.highest_level_reached,
                snow_games_played: playerStats.snow_games_played,
                desert_games_played: playerStats.desert_games_played,
                jungle_games_played: playerStats.jungle_games_played,
                ocean_games_played: playerStats.ocean_games_played,
                times_reached_rank_one: timesReachedRankOne,
                total_purchases: playerStats.total_purchases,
                multiplayer_games: playerStats.multiplayer_games || 0,
                multiplayer_wins: playerStats.multiplayer_wins || 0,
                // Check if all 4 lands have been played
                all_lands_played: (playerStats.snow_games_played > 0) &&
                                   (playerStats.desert_games_played > 0) &&
                                   (playerStats.jungle_games_played > 0) &&
                                   (playerStats.ocean_games_played > 0)
            };

            let checked = 0;
            let unlocked = 0;
            let newRewards = 0;

            // Check each achievement that isn't already unlocked
            for (const [achievementId, achievement] of Object.entries(ACHIEVEMENTS)) {
                if (unlockedAchievements.includes(achievementId)) continue;

                checked++;
                const req = achievement.requirement;
                if (!req) continue;

                let shouldUnlock = false;

                // Special handling for all_lands_played
                if (req.type === 'all_lands_played') {
                    shouldUnlock = stats.all_lands_played;
                }
                // Standard numeric comparisons
                else if (stats[req.type] !== undefined) {
                    shouldUnlock = stats[req.type] >= req.value;
                }

                if (shouldUnlock) {
                    await unlockAchievement(achievementId);
                    unlocked++;
                    newRewards += achievement.reward || 0;
                }
            }

            // Also check skin unlocks
            checkSkinUnlocks(playerStats.high_score, 0);

            return { checked, unlocked, newRewards };
        }

        // Notification system
        let notifications = [];

        function showNotification(message) {
            notifications.push({
                message,
                time: Date.now(),
                opacity: 1
            });

            // Remove after 3 seconds
            setTimeout(() => {
                notifications.shift();
            }, 3000);
        }

        function drawNotifications() {
            const now = Date.now();
            notifications.forEach((notif, i) => {
                const age = now - notif.time;
                const opacity = Math.max(0, 1 - (age / 3000));

                ctx.globalAlpha = opacity;
                ctx.fillStyle = '#FFE135';
                ctx.font = 'bold 20px monospace';
                ctx.textAlign = 'center';
                ctx.fillText(notif.message, canvas.width / 2, 100 + i * 30);
                ctx.globalAlpha = 1;
            });
        }

        // ============================================
        // AUTH UI FUNCTIONS
        // ============================================
        function showAuthModal() {
            document.getElementById('authModal').classList.add('active');
            document.getElementById('authError').textContent = '';
            document.getElementById('authSuccess').style.display = 'none';
        }

        function closeAuthModal() {
            document.getElementById('authModal').classList.remove('active');
            document.getElementById('authError').textContent = '';
            document.getElementById('authSuccess').style.display = 'none';
            // Go to menu after login (only if logged in)
            if (currentUser) {
                gameState = 'menu';
            }
        }

        function toggleAuthMode() {
            isAuthMode = isAuthMode === 'login' ? 'signup' : 'login';

            const title = document.getElementById('authTitle');
            const submit = document.getElementById('authSubmit');
            const toggle = document.getElementById('authToggle');

            if (isAuthMode === 'signup') {
                title.textContent = 'Sign Up';
                submit.textContent = 'Create Account';
                toggle.innerHTML = 'Already have an account? <a onclick="toggleAuthMode()">Login</a>';
            } else {
                title.textContent = 'Login';
                submit.textContent = 'Login';
                toggle.innerHTML = 'Don\'t have an account? <a onclick="toggleAuthMode()">Sign Up</a>';
            }

            document.getElementById('authError').textContent = '';
            document.getElementById('authSuccess').style.display = 'none';
        }

        // Expose functions to global scope for HTML onclick handlers
        window.toggleAuthMode = toggleAuthMode;
        window.logout = logout;

        function showAuthError(message) {
            document.getElementById('authError').textContent = message;
            document.getElementById('authSuccess').style.display = 'none';
        }

        function showAuthSuccess(message) {
            document.getElementById('authSuccess').textContent = message;
            document.getElementById('authSuccess').style.display = 'block';
            document.getElementById('authError').textContent = '';
        }

        function updateUserDisplay() {
            const userInfo = document.getElementById('userInfo');
            const displayName = document.getElementById('displayUsername');

            if (currentUser && userProfile) {
                displayName.textContent = userProfile.username || 'Player';
                userInfo.style.display = 'block';
            } else {
                userInfo.style.display = 'none';
            }
        }

        // Auth form handler
        document.getElementById('authForm').addEventListener('submit', async (e) => {
            e.preventDefault();

            const username = document.getElementById('authUsername').value.trim();
            const password = document.getElementById('authPassword').value;

            if (!username) {
                showAuthError('Username is required');
                return;
            }

            if (isAuthMode === 'signup') {
                await signUp(username, password);
            } else {
                await signIn(username, password);
            }
        });

        // Click outside modal to close
        document.getElementById('authModal').addEventListener('click', (e) => {
            // Only close if clicking the overlay itself, not the modal content
            if (e.target.id === 'authModal') {
                closeAuthModal();
            }
        });

        // Initialize Supabase when DOM is ready
        document.addEventListener('DOMContentLoaded', initSupabase);

        // Resize canvas to fill screen
        let lastCanvasHeight = 0;

        function resizeCanvas() {
            const oldWidth = canvas.width;
            const oldHeight = canvas.height;
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            ctx.imageSmoothingEnabled = false;

            // Detect significant orientation/size change (more than 100px difference)
            const significantChange = (Math.abs(canvas.width - oldWidth) > 100 ||
                                       Math.abs(canvas.height - oldHeight) > 100);

            // Handle resize during active gameplay
            if (oldHeight > 0 && player !== null && typeof PLAYER_HEIGHT !== 'undefined') {
                const newGroundLevel = canvas.height - 70;

                // Always snap player to correct ground position
                if (!player.jumping) {
                    player.y = newGroundLevel - PLAYER_HEIGHT;
                } else {
                    // Adjust jump position proportionally
                    const oldGroundLevel = oldHeight - 70;
                    const groundDiff = newGroundLevel - oldGroundLevel;
                    player.y += groundDiff;

                    // Ensure player doesn't end up below ground
                    if (player.y > newGroundLevel - PLAYER_HEIGHT) {
                        player.y = newGroundLevel - PLAYER_HEIGHT;
                        player.jumping = false;
                        player.vy = 0;
                    }
                }

                // Reposition all entities on resize (including orientation change)
                // Entities keep their X position but Y adjusts to new ground level
                if (entities && entities.length > 0) {
                    const newGroundLevel = canvas.height - 70;
                    const widthRatio = canvas.width / oldWidth;

                    for (let i = entities.length - 1; i >= 0; i--) {
                        const ent = entities[i];
                        const entHeight = ent.pixels.length * ent.scale;

                        // Scale X position proportionally for width changes
                        if (significantChange && widthRatio !== 1) {
                            ent.x = ent.x * widthRatio;
                        }

                        // Snap to new ground level
                        if (ent.type === 'obstacle') {
                            ent.y = newGroundLevel - entHeight;
                        } else if (ent.type === 'banana') {
                            ent.y = newGroundLevel - entHeight - BANANA_HEIGHT_OFFSET;
                        }

                        // Remove entities now off-screen (but keep ones ahead)
                        if (ent.x < -100) {
                            entities.splice(i, 1);
                        }
                    }
                }
            }

            lastCanvasHeight = canvas.height;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // Dynamic constants based on screen size
        // Note: PLAYER_SCALE, ENTITY_SCALE, BANANA_HEIGHT_OFFSET imported from config.js
        function getGroundLevel() {
            return canvas.height - 70;
        }

        // High-definition pixel art sprites (32x48 runners, doubled detail)
        const sprites = {
            // Snow runner - winter hat with pom-pom, puffy jacket (32x48)
            runnerSnow: [
                [0,0,0,0,0,0,0,0,0,0,0,0,0,7,7,7,7,7,7,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,7,7,7,7,7,7,7,7,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,4,4,4,4,4,4,4,4,4,4,4,4,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,4,4,4,4,4,4,4,4,4,4,4,4,4,4,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,1,2,2,2,2,2,2,1,1,2,2,2,2,2,2,1,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,1,2,2,3,3,2,2,1,1,2,2,3,3,2,2,1,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,1,2,2,3,3,2,2,2,2,2,2,3,3,2,2,1,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,1,1,2,2,2,2,2,2,2,2,2,2,2,2,1,1,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,1,1,2,2,2,8,8,8,8,2,2,2,1,1,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,1,1,2,2,2,2,2,2,2,2,1,1,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,5,5,5,5,5,5,5,5,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,4,4,4,4,4,4,4,4,4,4,4,4,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,4,4,4,4,4,4,4,4,4,4,4,4,4,4,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,0,0,0,0,0,0],
                [0,0,0,0,0,2,2,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,2,2,0,0,0,0,0],
                [0,0,0,0,2,2,2,2,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,2,2,2,2,0,0,0,0],
                [0,0,0,0,2,2,2,0,0,4,4,4,4,4,4,4,4,4,4,4,4,4,4,0,0,2,2,2,0,0,0,0],
                [0,0,0,0,2,2,0,0,0,4,4,4,4,4,4,4,4,4,4,4,4,4,4,0,0,0,2,2,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,4,4,4,4,4,4,4,4,4,4,4,4,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,4,4,4,4,4,4,4,4,4,4,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,5,5,5,5,0,0,5,5,5,5,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,5,5,5,5,0,0,5,5,5,5,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,5,5,5,5,5,0,0,5,5,5,5,5,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,5,5,5,5,0,0,0,0,5,5,5,5,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,5,5,5,5,5,0,0,0,0,5,5,5,5,5,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,5,5,5,5,0,0,0,0,0,0,5,5,5,5,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,5,5,5,5,5,0,0,0,0,0,0,5,5,5,5,5,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,5,5,5,5,0,0,0,0,0,0,0,0,5,5,5,5,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,5,5,5,5,5,0,0,0,0,0,0,0,0,5,5,5,5,5,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,5,5,5,5,0,0,0,0,0,0,0,0,0,0,5,5,5,5,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,6,6,6,6,6,6,0,0,0,0,0,0,0,0,6,6,6,6,6,6,0,0,0,0,0,0],
                [0,0,0,0,0,0,6,6,6,6,6,6,0,0,0,0,0,0,0,0,6,6,6,6,6,6,0,0,0,0,0,0],
                [0,0,0,0,0,0,6,6,6,6,6,6,0,0,0,0,0,0,0,0,6,6,6,6,6,6,0,0,0,0,0,0],
                [0,0,0,0,0,0,6,6,6,6,6,6,0,0,0,0,0,0,0,0,6,6,6,6,6,6,0,0,0,0,0,0]
            ],
            // Desert runner - cowboy hat, vest (32x48)
            runnerDesert: [
                [0,0,0,0,0,0,0,0,0,0,0,0,4,4,4,4,4,4,4,4,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,4,4,4,4,4,4,4,4,4,4,4,4,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,4,4,4,4,4,4,4,4,4,4,4,4,4,4,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,0,0,0,0,0,0],
                [0,0,0,0,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,1,2,2,2,2,2,2,2,2,2,2,2,2,1,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,1,2,2,3,3,2,2,2,2,3,3,2,2,1,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,1,2,2,3,3,2,2,2,2,3,3,2,2,1,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,1,1,2,2,2,2,2,2,2,2,2,2,1,1,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,1,1,2,2,8,8,8,8,2,2,1,1,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,1,1,2,2,2,2,2,2,1,1,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,5,5,5,5,5,5,5,5,5,5,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,5,5,5,5,5,5,5,5,5,5,5,5,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,5,5,5,6,6,6,6,6,6,6,6,5,5,5,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,5,5,5,5,6,6,6,6,6,6,6,6,5,5,5,5,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,5,5,5,5,5,6,6,6,6,6,6,6,6,5,5,5,5,5,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,5,5,5,5,5,5,6,6,6,6,6,6,6,6,5,5,5,5,5,5,0,0,0,0,0,0],
                [0,0,0,0,0,2,2,5,5,5,5,5,6,6,6,6,6,6,6,6,5,5,5,5,5,2,2,0,0,0,0,0],
                [0,0,0,0,2,2,2,2,5,5,5,5,6,6,6,6,6,6,6,6,5,5,5,5,2,2,2,2,0,0,0,0],
                [0,0,0,0,2,2,2,0,0,5,5,5,5,5,5,5,5,5,5,5,5,5,5,0,0,2,2,2,0,0,0,0],
                [0,0,0,0,2,2,0,0,0,5,5,5,5,5,5,5,5,5,5,5,5,5,5,0,0,0,2,2,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,5,5,5,5,5,5,5,5,5,5,5,5,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,5,5,5,5,5,5,5,5,5,5,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,7,7,7,7,0,0,7,7,7,7,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,7,7,7,7,0,0,7,7,7,7,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,7,7,7,7,7,0,0,7,7,7,7,7,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,7,7,7,7,0,0,0,0,7,7,7,7,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,7,7,7,7,7,0,0,0,0,7,7,7,7,7,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,7,7,7,7,0,0,0,0,0,0,7,7,7,7,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,7,7,7,7,7,0,0,0,0,0,0,7,7,7,7,7,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,7,7,7,7,0,0,0,0,0,0,0,0,7,7,7,7,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,7,7,7,7,7,0,0,0,0,0,0,0,0,7,7,7,7,7,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,7,7,7,7,0,0,0,0,0,0,0,0,0,0,7,7,7,7,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,9,9,9,9,9,9,0,0,0,0,0,0,0,0,9,9,9,9,9,9,0,0,0,0,0,0],
                [0,0,0,0,0,0,9,9,9,9,9,9,0,0,0,0,0,0,0,0,9,9,9,9,9,9,0,0,0,0,0,0],
                [0,0,0,0,0,0,9,9,9,9,9,9,0,0,0,0,0,0,0,0,9,9,9,9,9,9,0,0,0,0,0,0],
                [0,0,0,0,0,0,9,9,9,9,9,9,0,0,0,0,0,0,0,0,9,9,9,9,9,9,0,0,0,0,0,0]
            ],
            // Jungle runner - Tarzan loincloth, bare chest (32x48)
            runnerJungle: [
                [0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,1,2,2,2,2,2,2,1,1,2,2,2,2,2,2,1,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,1,2,2,3,3,2,2,2,2,2,2,3,3,2,2,1,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,1,2,2,3,3,2,2,2,2,2,2,3,3,2,2,1,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,1,1,2,2,2,2,2,2,2,2,2,2,2,2,1,1,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,1,1,2,2,2,2,2,2,2,2,2,2,1,1,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,1,1,2,2,2,2,2,2,2,2,1,1,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,2,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,2,2,2,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,2,2,2,2,2,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,0,0,0,0,0,0],
                [0,0,0,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,0,0,0,0],
                [0,0,0,0,2,2,2,2,0,0,2,2,2,2,2,2,2,2,2,2,2,2,0,0,2,2,2,2,0,0,0,0],
                [0,0,0,0,2,2,2,0,0,0,2,2,2,2,2,2,2,2,2,2,2,2,0,0,0,2,2,2,0,0,0,0],
                [0,0,0,0,2,2,0,0,0,0,0,4,4,4,4,4,4,4,4,4,4,0,0,0,0,0,2,2,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,4,4,4,4,4,4,4,4,4,4,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,4,4,4,4,4,4,4,4,4,4,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,4,4,4,4,4,4,4,4,4,4,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,0,0,2,2,2,2,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,0,0,2,2,2,2,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,0,0,2,2,2,2,2,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,2,2,2,2,0,0,0,0,2,2,2,2,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,2,2,2,2,2,0,0,0,0,2,2,2,2,2,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,2,2,2,2,0,0,0,0,0,0,2,2,2,2,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,2,2,2,2,2,0,0,0,0,0,0,2,2,2,2,2,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,2,2,2,2,0,0,0,0,0,0,0,0,2,2,2,2,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,2,2,2,2,2,0,0,0,0,0,0,0,0,2,2,2,2,2,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,2,2,2,2,0,0,0,0,0,0,0,0,0,0,2,2,2,2,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,2,2,2,2,0,0,0,0,0,0,0,0,0,0,2,2,2,2,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,2,2,2,2,0,0,0,0,0,0,0,0,0,0,2,2,2,2,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,2,2,2,2,0,0,0,0,0,0,0,0,0,0,2,2,2,2,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,2,2,2,2,0,0,0,0,0,0,0,0,0,0,2,2,2,2,0,0,0,0,0,0,0]
            ],
            // Ocean runner - scuba helmet, wetsuit (32x48)
            runnerOcean: [
                [0,0,0,0,0,0,0,0,0,0,4,4,4,4,4,4,4,4,4,4,4,4,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,4,4,4,4,4,4,4,4,4,4,4,4,4,4,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,4,4,4,5,5,5,5,4,4,4,4,5,5,5,5,4,4,4,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,4,4,4,5,5,5,5,4,4,4,4,5,5,5,5,4,4,4,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,4,4,4,5,5,3,3,4,4,4,4,3,3,5,5,4,4,4,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,4,4,4,5,5,3,3,4,4,4,4,3,3,5,5,4,4,4,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,4,4,4,4,4,4,4,4,4,4,4,4,4,4,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,4,4,4,4,4,4,4,4,4,4,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,6,6,6,6,6,6,6,6,6,6,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,6,6,6,6,6,6,6,6,6,6,6,6,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,6,6,6,6,6,6,6,6,6,6,6,6,6,6,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,0,0,0,0,0,0],
                [0,0,0,0,0,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,0,0,0,0,0],
                [0,0,0,0,6,6,6,6,0,0,6,6,6,6,6,6,6,6,6,6,6,6,0,0,6,6,6,6,0,0,0,0],
                [0,0,0,0,6,6,6,0,0,0,6,6,6,6,6,6,6,6,6,6,6,6,0,0,0,6,6,6,0,0,0,0],
                [0,0,0,0,6,6,0,0,0,0,6,6,6,6,6,6,6,6,6,6,6,6,0,0,0,0,6,6,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,6,6,6,6,6,6,6,6,6,6,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,6,6,6,6,6,6,6,6,6,6,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,6,6,6,6,0,0,6,6,6,6,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,6,6,6,6,0,0,6,6,6,6,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,6,6,6,6,6,0,0,6,6,6,6,6,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,6,6,6,6,0,0,0,0,6,6,6,6,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,6,6,6,6,6,0,0,0,0,6,6,6,6,6,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,6,6,6,6,0,0,0,0,0,0,6,6,6,6,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,6,6,6,6,6,0,0,0,0,0,0,6,6,6,6,6,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,6,6,6,6,0,0,0,0,0,0,0,0,6,6,6,6,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,6,6,6,6,6,0,0,0,0,0,0,0,0,6,6,6,6,6,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,6,6,6,6,0,0,0,0,0,0,0,0,0,0,6,6,6,6,0,0,0,0,0,0,0],
                [0,0,0,0,0,7,7,7,7,7,7,7,7,0,0,0,0,0,0,7,7,7,7,7,7,7,7,0,0,0,0,0],
                [0,0,0,0,0,7,7,7,7,7,7,7,7,0,0,0,0,0,0,7,7,7,7,7,7,7,7,0,0,0,0,0],
                [0,0,0,0,0,7,7,7,7,7,7,7,7,0,0,0,0,0,0,7,7,7,7,7,7,7,7,0,0,0,0,0],
                [0,0,0,0,0,7,7,7,7,7,7,7,7,0,0,0,0,0,0,7,7,7,7,7,7,7,7,0,0,0,0,0]
            ],
            // Curved banana (20x36 pixels) - doubled detail
            banana: [
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,3,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,3,3,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,3,3,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,3,3,3,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,3,3,3,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,1,1,2,2,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,1,1,1,1,2,2,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,2,0,0,0,0],
                [0,0,0,0,0,0,0,0,1,1,1,1,1,1,2,2,0,0,0,0],
                [0,0,0,0,0,0,0,1,1,1,1,1,1,1,2,2,0,0,0,0],
                [0,0,0,0,0,0,1,1,1,1,1,1,1,2,2,0,0,0,0,0],
                [0,0,0,0,0,1,1,1,1,1,1,1,1,2,2,0,0,0,0,0],
                [0,0,0,0,1,1,1,1,1,1,1,1,2,2,0,0,0,0,0,0],
                [0,0,0,1,1,1,1,1,1,1,1,1,2,2,0,0,0,0,0,0],
                [0,0,1,1,1,1,1,1,1,1,1,2,2,0,0,0,0,0,0,0],
                [0,1,1,1,1,1,1,1,1,1,1,2,2,0,0,0,0,0,0,0],
                [0,1,1,1,1,1,1,1,1,1,2,2,0,0,0,0,0,0,0,0],
                [1,1,1,1,1,1,1,1,1,1,2,2,0,0,0,0,0,0,0,0],
                [1,1,1,1,1,1,1,1,1,2,2,0,0,0,0,0,0,0,0,0],
                [1,1,1,1,1,1,1,1,1,2,2,0,0,0,0,0,0,0,0,0],
                [1,1,1,1,1,1,1,1,2,2,0,0,0,0,0,0,0,0,0,0],
                [1,1,1,1,1,1,1,1,2,2,0,0,0,0,0,0,0,0,0,0],
                [1,1,1,1,1,1,1,2,2,0,0,0,0,0,0,0,0,0,0,0],
                [0,1,1,1,1,1,1,2,2,0,0,0,0,0,0,0,0,0,0,0],
                [0,1,1,1,1,1,2,2,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,1,1,1,1,2,2,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,1,1,1,1,2,2,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,1,1,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,1,1,2,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,4,4,4,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,4,4,4,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,4,4,0,0,0,0,0,0,0,0,0,0,0,0,0]
            ],
            // Banana Bundle (40x36 pixels) - 3 bananas clustered, worth 300 points
            bananaBundle: [
                [0,0,0,0,0,0,0,0,0,0,0,0,3,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,3,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,3,3,3,0,0,0,0,0,0,0,0,0,0,0,0,0,3,3,3,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,3,3,3,0,0,0,0,0,0,0,0,0,0,0,0,0,3,3,3,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,3,3,3,0,0,0,0,0,0,3,3,0,0,0,0,0,3,3,3,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,3,3,3,0,0,0,0,0,0,3,3,3,0,0,0,0,3,3,3,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,1,1,2,2,0,0,0,0,0,3,3,3,0,0,0,0,1,1,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,1,1,1,1,2,2,0,0,0,3,3,3,0,0,0,0,1,1,1,1,2,2,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,1,1,1,1,1,1,2,0,0,1,1,2,2,0,0,0,1,1,1,1,1,1,2,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,1,1,1,1,1,1,2,2,0,1,1,1,1,2,2,0,1,1,1,1,1,1,2,2,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,1,1,1,1,1,1,1,2,2,1,1,1,1,1,1,2,1,1,1,1,1,1,1,2,2,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,1,1,1,1,1,1,1,2,2,0,1,1,1,1,1,1,2,2,1,1,1,1,1,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,1,1,1,1,1,1,1,1,2,2,0,1,1,1,1,1,2,2,0,0,1,1,1,1,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,1,1,1,1,1,1,1,2,2,0,0,1,1,1,1,1,2,2,0,0,0,1,1,1,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [1,1,1,1,1,1,1,1,2,2,0,0,1,1,1,1,2,2,0,0,0,0,0,1,1,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [1,1,1,1,1,1,1,2,2,0,0,0,0,1,1,1,2,2,0,0,0,0,0,0,1,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [1,1,1,1,1,1,1,2,2,0,0,0,0,1,1,2,2,0,0,0,0,0,0,0,4,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [1,1,1,1,1,1,2,2,0,0,0,0,0,0,1,1,2,0,0,0,0,0,0,0,4,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,1,1,1,1,1,2,2,0,0,0,0,0,0,4,4,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,1,1,1,1,2,2,0,0,0,0,0,0,0,4,4,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,1,1,1,2,2,0,0,0,0,0,0,0,0,4,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,1,1,1,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,1,1,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,4,4,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,4,4,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,4,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
            ],
            // Jetpack Power-up (48x48 pixels) - Rocket in circular bubble with green outline
            // 7 = green outline (good collectible)
            jetpack: [
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,7,7,7,7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,7,7,7,7,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,7,7,7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,7,7,7,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,7,7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,7,7,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,7,7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,7,7,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,7,7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,7,7,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,7,7,5,5,5,5,5,5,5,5,5,5,5,5,1,1,1,1,1,1,5,5,5,5,5,5,5,5,5,5,7,7,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,7,7,5,5,5,5,5,5,5,5,5,5,5,5,1,1,1,1,1,1,1,1,5,5,5,5,5,5,5,5,5,5,7,7,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,7,5,5,5,5,5,5,5,5,5,5,5,5,1,1,1,1,1,1,1,1,1,1,5,5,5,5,5,5,5,5,5,5,7,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,7,7,5,5,5,5,5,5,5,5,5,5,5,1,1,1,1,1,1,1,1,1,1,1,1,5,5,5,5,5,5,5,5,5,7,7,0,0,0,0,0,0,0],
                [0,0,0,0,0,7,5,5,5,5,5,5,5,5,5,5,5,5,1,1,1,1,2,2,2,2,1,1,1,1,5,5,5,5,5,5,5,5,5,5,7,0,0,0,0,0,0,0],
                [0,0,0,0,7,7,5,5,5,5,5,5,5,5,5,5,5,5,1,1,1,2,2,2,2,2,2,1,1,1,5,5,5,5,5,5,5,5,5,5,7,7,0,0,0,0,0,0],
                [0,0,0,0,7,5,5,5,5,5,5,5,5,5,5,5,5,5,1,1,1,2,2,2,2,2,2,1,1,1,5,5,5,5,5,5,5,5,5,5,5,7,0,0,0,0,0,0],
                [0,0,0,7,7,5,5,5,5,5,5,5,5,5,5,5,5,5,1,1,1,2,2,2,2,2,2,1,1,1,5,5,5,5,5,5,5,5,5,5,5,7,7,0,0,0,0,0],
                [0,0,0,7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,1,1,1,1,1,1,1,1,1,1,1,1,5,5,5,5,5,5,5,5,5,5,5,5,7,0,0,0,0,0],
                [0,0,7,7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,1,1,1,1,1,1,1,1,1,1,1,1,5,5,5,5,5,5,5,5,5,5,5,5,7,7,0,0,0,0],
                [0,0,7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,1,1,1,1,1,1,1,1,1,1,1,1,5,5,5,5,5,5,5,5,5,5,5,5,5,7,0,0,0,0],
                [0,7,7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,1,1,1,1,1,1,1,1,1,1,1,1,5,5,5,5,5,5,5,5,5,5,5,5,5,7,7,0,0,0],
                [0,7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,1,1,1,1,1,1,1,1,1,1,1,1,5,5,5,5,5,5,5,5,5,5,5,5,5,5,7,0,0,0],
                [0,7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,3,3,1,1,1,1,1,1,1,1,1,1,3,3,5,5,5,5,5,5,5,5,5,5,5,5,5,7,0,0,0],
                [7,7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,3,3,1,1,1,1,1,1,1,1,1,1,3,3,5,5,5,5,5,5,5,5,5,5,5,5,5,7,7,0,0],
                [7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,3,3,1,1,1,1,1,1,1,1,1,1,3,3,5,5,5,5,5,5,5,5,5,5,5,5,5,5,7,0,0],
                [7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,3,3,1,1,1,1,1,1,1,1,1,1,3,3,5,5,5,5,5,5,5,5,5,5,5,5,5,5,7,0,0],
                [7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,4,4,4,4,4,4,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,7,0,0],
                [7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,4,4,4,4,4,4,4,4,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,7,0,0],
                [7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,4,4,4,6,6,6,6,4,4,4,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,7,0,0],
                [7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,4,4,6,6,6,6,6,6,4,4,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,7,0,0],
                [7,7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,4,6,6,6,6,6,6,6,6,4,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,7,7,0,0],
                [0,7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,6,6,6,6,6,6,6,6,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,7,0,0,0],
                [0,7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,6,6,6,6,6,6,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,7,0,0,0],
                [0,7,7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,6,6,6,6,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,7,7,0,0,0],
                [0,0,7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,6,6,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,7,0,0,0,0],
                [0,0,7,7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,7,7,0,0,0,0],
                [0,0,0,7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,7,0,0,0,0,0],
                [0,0,0,7,7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,7,7,0,0,0,0,0],
                [0,0,0,0,7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,7,0,0,0,0,0,0],
                [0,0,0,0,7,7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,7,7,0,0,0,0,0,0],
                [0,0,0,0,0,7,7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,7,7,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,7,7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,7,7,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,7,7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,7,7,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,7,7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,7,7,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,7,7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,7,7,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,7,7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,7,7,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,7,7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,7,7,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,7,7,7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,7,7,7,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,7,7,7,7,5,5,5,5,5,5,5,5,5,5,5,5,5,7,7,7,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
            ],
            // T-Rex Power-up (48x48 pixels) - Dino in circular bubble with green outline
            // 7 = green outline (good collectible)
            trexPowerUp: [
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,7,7,7,7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,7,7,7,7,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,7,7,7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,7,7,7,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,7,7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,7,7,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,7,7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,7,7,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,7,7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,7,7,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,7,7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,1,1,1,1,1,1,5,5,5,5,5,5,7,7,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,7,7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,1,1,1,1,1,1,1,1,5,5,5,5,5,5,7,7,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,1,1,1,1,1,1,1,1,1,1,5,5,5,5,5,5,7,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,7,7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,1,1,1,2,2,1,1,1,1,1,1,5,5,5,5,5,5,7,7,0,0,0,0,0,0,0],
                [0,0,0,0,0,7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,1,1,1,1,1,1,1,1,1,1,1,5,5,5,5,5,5,5,7,0,0,0,0,0,0,0],
                [0,0,0,0,7,7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,1,1,3,3,3,3,1,1,1,5,5,5,5,5,5,5,5,7,7,0,0,0,0,0,0],
                [0,0,0,0,7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,1,1,1,1,1,1,1,5,5,5,5,5,5,5,5,5,5,7,0,0,0,0,0,0],
                [0,0,0,7,7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,1,1,1,1,1,5,5,5,5,5,5,5,5,5,5,5,7,7,0,0,0,0,0],
                [0,0,0,7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,1,1,1,5,5,5,5,5,5,5,5,5,5,5,5,5,7,0,0,0,0,0],
                [0,0,7,7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,1,1,1,5,5,5,5,5,5,5,5,5,5,5,5,5,7,7,0,0,0,0],
                [0,0,7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,1,1,1,1,1,5,5,5,5,5,5,5,5,5,5,5,5,5,7,0,0,0,0],
                [0,7,7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,1,1,1,1,1,1,1,5,5,5,5,5,5,5,5,5,5,5,5,7,7,0,0,0],
                [0,7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,1,1,1,1,1,1,1,1,1,5,5,5,5,5,5,5,5,5,5,5,5,7,0,0,0],
                [0,7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,1,1,1,1,1,1,1,1,1,1,1,5,5,5,5,5,5,5,5,5,5,5,7,0,0,0],
                [7,7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,1,1,5,5,5,5,5,5,1,1,1,5,5,5,5,5,5,5,5,5,5,5,7,7,0,0],
                [7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,1,1,5,5,5,5,5,5,5,1,1,5,5,5,5,5,5,5,5,5,5,5,5,7,0,0],
                [7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,1,5,5,5,5,5,5,5,5,5,1,5,5,5,5,5,5,5,5,5,5,5,5,7,0,0],
                [7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,1,5,5,5,5,5,5,5,5,5,1,5,5,5,5,5,5,5,5,5,5,5,5,7,0,0],
                [7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,1,1,5,5,5,5,5,5,5,5,5,1,1,5,5,5,5,5,5,5,5,5,5,5,7,0,0],
                [7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,1,1,5,5,5,5,5,5,5,5,5,1,1,5,5,5,5,5,5,5,5,5,5,5,7,0,0],
                [7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,1,5,5,5,5,5,5,5,5,5,5,5,1,5,5,5,5,5,5,5,5,5,5,5,7,0,0],
                [7,7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,1,5,5,5,5,5,5,5,5,5,5,5,1,5,5,5,5,5,5,5,5,5,5,7,7,0,0],
                [0,7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,1,1,1,5,5,5,5,5,5,5,5,5,1,1,1,5,5,5,5,5,5,5,5,5,7,0,0,0],
                [0,7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,1,1,1,5,5,5,5,5,5,5,5,5,1,1,1,5,5,5,5,5,5,5,5,5,7,0,0,0],
                [0,7,7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,7,7,0,0,0],
                [0,0,7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,7,0,0,0,0],
                [0,0,7,7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,7,7,0,0,0,0],
                [0,0,0,7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,7,0,0,0,0,0],
                [0,0,0,7,7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,7,7,0,0,0,0,0],
                [0,0,0,0,7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,7,0,0,0,0,0,0],
                [0,0,0,0,7,7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,7,7,0,0,0,0,0,0],
                [0,0,0,0,0,7,7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,7,7,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,7,7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,7,7,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,7,7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,7,7,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,7,7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,7,7,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,7,7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,7,7,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,7,7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,7,7,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,7,7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,7,7,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,7,7,7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,7,7,7,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,7,7,7,7,5,5,5,5,5,5,5,5,5,5,5,5,5,7,7,7,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
            ],
            // Bubble Shield Power-up (48x48 pixels) - Shield icon in cyan bubble
            // 7 = cyan outline (permanent buff)
            bubblePowerUp: [
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,7,7,7,7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,7,7,7,7,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,7,7,7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,7,7,7,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,7,7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,7,7,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,7,7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,7,7,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,7,7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,7,7,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,7,7,5,5,5,5,5,5,5,5,5,5,5,1,1,1,1,1,1,1,1,5,5,5,5,5,5,5,5,5,7,7,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,7,7,5,5,5,5,5,5,5,5,5,5,1,1,1,1,1,1,1,1,1,1,1,1,5,5,5,5,5,5,5,5,7,7,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,7,5,5,5,5,5,5,5,5,5,5,1,1,1,1,2,2,2,2,2,2,1,1,1,1,5,5,5,5,5,5,5,5,7,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,7,7,5,5,5,5,5,5,5,5,5,1,1,1,2,2,2,2,2,2,2,2,2,2,1,1,1,5,5,5,5,5,5,5,7,7,0,0,0,0,0,0,0],
                [0,0,0,0,0,7,5,5,5,5,5,5,5,5,5,5,1,1,2,2,2,2,2,2,2,2,2,2,2,2,1,1,5,5,5,5,5,5,5,5,7,0,0,0,0,0,0,0],
                [0,0,0,0,7,7,5,5,5,5,5,5,5,5,5,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,5,5,5,5,5,5,5,7,7,0,0,0,0,0,0],
                [0,0,0,0,7,5,5,5,5,5,5,5,5,5,5,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,5,5,5,5,5,5,5,5,7,0,0,0,0,0,0],
                [0,0,0,7,7,5,5,5,5,5,5,5,5,5,5,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,5,5,5,5,5,5,5,5,7,7,0,0,0,0,0],
                [0,0,0,7,5,5,5,5,5,5,5,5,5,5,5,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,5,5,5,5,5,5,5,5,5,7,0,0,0,0,0],
                [0,0,7,7,5,5,5,5,5,5,5,5,5,5,5,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,5,5,5,5,5,5,5,5,5,7,7,0,0,0,0],
                [0,0,7,5,5,5,5,5,5,5,5,5,5,5,5,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,5,5,5,5,5,5,5,5,5,5,7,0,0,0,0],
                [0,7,7,5,5,5,5,5,5,5,5,5,5,5,5,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,5,5,5,5,5,5,5,5,5,5,7,7,0,0,0],
                [0,7,5,5,5,5,5,5,5,5,5,5,5,5,5,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,5,5,5,5,5,5,5,5,5,5,5,7,0,0,0],
                [0,7,5,5,5,5,5,5,5,5,5,5,5,5,5,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,5,5,5,5,5,5,5,5,5,5,5,7,0,0,0],
                [7,7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,1,1,2,2,2,2,2,2,2,2,2,2,2,2,1,1,5,5,5,5,5,5,5,5,5,5,5,5,7,7,0,0],
                [7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,1,1,2,2,2,2,2,2,2,2,2,2,2,2,1,1,5,5,5,5,5,5,5,5,5,5,5,5,5,7,0,0],
                [7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,1,1,2,2,2,2,2,2,2,2,2,2,1,1,5,5,5,5,5,5,5,5,5,5,5,5,5,5,7,0,0],
                [7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,1,1,1,2,2,2,2,2,2,2,2,1,1,1,5,5,5,5,5,5,5,5,5,5,5,5,5,5,7,0,0],
                [7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,1,1,1,2,2,2,2,2,2,1,1,1,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,7,0,0],
                [7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,1,1,1,2,2,2,2,1,1,1,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,7,0,0],
                [7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,1,1,1,2,2,1,1,1,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,7,0,0],
                [7,7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,1,1,1,1,1,1,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,7,7,0,0],
                [0,7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,1,1,1,1,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,7,0,0,0],
                [0,7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,7,0,0,0],
                [0,7,7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,7,7,0,0,0],
                [0,0,7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,7,0,0,0,0],
                [0,0,7,7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,7,7,0,0,0,0],
                [0,0,0,7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,7,0,0,0,0,0],
                [0,0,0,7,7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,7,7,0,0,0,0,0],
                [0,0,0,0,7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,7,0,0,0,0,0,0],
                [0,0,0,0,7,7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,7,7,0,0,0,0,0,0],
                [0,0,0,0,0,7,7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,7,7,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,7,7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,7,7,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,7,7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,7,7,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,7,7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,7,7,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,7,7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,7,7,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,7,7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,7,7,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,7,7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,7,7,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,7,7,7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,7,7,7,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,7,7,7,7,5,5,5,5,5,5,5,5,5,5,5,5,5,7,7,7,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
            ],
            // Pogo Stick Power-up (48x48 pixels) - Spring coil in cyan bubble
            pogoPowerUp: [
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,7,7,7,7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,7,7,7,7,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,7,7,7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,7,7,7,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,7,7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,7,7,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,7,7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,7,7,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,7,7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,7,7,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,7,7,5,5,5,5,5,5,5,5,5,5,5,5,1,1,1,1,1,1,5,5,5,5,5,5,5,5,5,5,7,7,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,7,7,5,5,5,5,5,5,5,5,5,5,5,5,1,1,2,2,2,2,1,1,5,5,5,5,5,5,5,5,5,5,7,7,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,7,5,5,5,5,5,5,5,5,5,5,5,5,1,1,2,2,2,2,2,2,1,1,5,5,5,5,5,5,5,5,5,5,7,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,7,7,5,5,5,5,5,5,5,5,5,5,5,5,1,2,2,5,5,5,5,2,2,1,5,5,5,5,5,5,5,5,5,5,7,7,0,0,0,0,0,0,0],
                [0,0,0,0,0,7,5,5,5,5,5,5,5,5,5,5,5,5,5,1,2,5,5,5,5,5,5,2,1,5,5,5,5,5,5,5,5,5,5,5,7,0,0,0,0,0,0,0],
                [0,0,0,0,7,7,5,5,5,5,5,5,5,5,5,5,5,5,1,1,2,2,5,5,5,5,2,2,1,1,5,5,5,5,5,5,5,5,5,5,7,7,0,0,0,0,0,0],
                [0,0,0,0,7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,1,2,2,2,2,2,2,2,2,1,5,5,5,5,5,5,5,5,5,5,5,5,7,0,0,0,0,0,0],
                [0,0,0,7,7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,1,1,2,2,2,2,2,2,1,1,5,5,5,5,5,5,5,5,5,5,5,5,7,7,0,0,0,0,0],
                [0,0,0,7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,1,2,5,5,5,5,2,1,5,5,5,5,5,5,5,5,5,5,5,5,5,5,7,0,0,0,0,0],
                [0,0,7,7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,1,2,5,5,5,5,2,1,5,5,5,5,5,5,5,5,5,5,5,5,5,5,7,7,0,0,0,0],
                [0,0,7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,1,1,2,2,5,5,2,2,1,1,5,5,5,5,5,5,5,5,5,5,5,5,5,5,7,0,0,0,0],
                [0,7,7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,1,2,2,2,2,2,2,2,2,1,5,5,5,5,5,5,5,5,5,5,5,5,5,5,7,7,0,0,0],
                [0,7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,1,1,2,2,2,2,2,2,1,1,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,7,0,0,0],
                [0,7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,1,2,5,5,5,5,2,1,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,7,0,0,0],
                [7,7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,1,2,5,5,5,5,2,1,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,7,7,0,0],
                [7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,1,1,2,2,5,5,2,2,1,1,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,7,0,0],
                [7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,1,2,2,2,2,2,2,2,2,1,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,7,0,0],
                [7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,1,1,2,2,2,2,2,2,1,1,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,7,0,0],
                [7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,1,2,5,5,5,5,2,1,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,7,0,0],
                [7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,1,2,5,5,5,5,2,1,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,7,0,0],
                [7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,1,1,2,2,5,5,2,2,1,1,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,7,0,0],
                [7,7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,1,2,2,2,2,2,2,2,2,1,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,7,7,0,0],
                [0,7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,1,1,2,2,2,2,2,2,1,1,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,7,0,0,0],
                [0,7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,1,1,3,3,3,3,1,1,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,7,0,0,0],
                [0,7,7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,1,3,3,3,3,1,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,7,7,0,0,0],
                [0,0,7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,3,3,3,3,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,7,0,0,0,0],
                [0,0,7,7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,7,7,0,0,0,0],
                [0,0,0,7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,7,0,0,0,0,0],
                [0,0,0,7,7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,7,7,0,0,0,0,0],
                [0,0,0,0,7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,7,0,0,0,0,0,0],
                [0,0,0,0,7,7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,7,7,0,0,0,0,0,0],
                [0,0,0,0,0,7,7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,7,7,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,7,7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,7,7,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,7,7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,7,7,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,7,7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,7,7,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,7,7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,7,7,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,7,7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,7,7,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,7,7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,7,7,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,7,7,7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,7,7,7,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,7,7,7,7,5,5,5,5,5,5,5,5,5,5,5,5,5,7,7,7,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
            ],
            // Lion Roar Power-up (48x48 pixels) - Lion face in gold bubble (rare)
            // 8 = gold outline (rare/special)
            lionPowerUp: [
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,8,8,8,8,5,5,5,5,5,5,5,5,5,5,5,5,5,5,8,8,8,8,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,8,8,8,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,8,8,8,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,8,8,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,8,8,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,8,8,5,5,5,5,5,5,5,5,1,1,1,5,5,5,5,1,1,1,5,5,5,5,5,5,8,8,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,8,8,5,5,5,5,5,5,5,5,1,1,1,1,1,5,5,1,1,1,1,1,5,5,5,5,5,5,8,8,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,8,8,5,5,5,5,5,5,5,5,1,1,1,1,1,1,1,1,1,1,1,1,1,1,5,5,5,5,5,5,8,8,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,8,8,5,5,5,5,5,5,5,5,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,5,5,5,5,5,5,8,8,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,8,5,5,5,5,5,5,5,5,5,1,1,1,2,2,2,2,2,2,2,2,2,2,1,1,1,5,5,5,5,5,5,5,8,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,8,8,5,5,5,5,5,5,5,5,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,1,1,1,5,5,5,5,5,5,8,8,0,0,0,0,0,0,0],
                [0,0,0,0,0,8,5,5,5,5,5,5,5,5,5,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,5,5,5,5,5,5,5,8,0,0,0,0,0,0,0],
                [0,0,0,0,8,8,5,5,5,5,5,5,5,5,1,1,2,2,2,2,3,3,2,2,2,2,3,3,2,2,2,2,1,1,5,5,5,5,5,5,8,8,0,0,0,0,0,0],
                [0,0,0,0,8,5,5,5,5,5,5,5,5,5,1,1,2,2,2,2,3,3,2,2,2,2,3,3,2,2,2,2,1,1,5,5,5,5,5,5,5,8,0,0,0,0,0,0],
                [0,0,0,8,8,5,5,5,5,5,5,5,5,5,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,5,5,5,5,5,5,5,8,8,0,0,0,0,0],
                [0,0,0,8,5,5,5,5,5,5,5,5,5,5,1,2,2,2,2,2,2,2,4,4,4,4,2,2,2,2,2,2,2,1,5,5,5,5,5,5,5,5,8,0,0,0,0,0],
                [0,0,8,8,5,5,5,5,5,5,5,5,5,5,1,2,2,2,2,2,2,2,2,4,4,2,2,2,2,2,2,2,2,1,5,5,5,5,5,5,5,5,8,8,0,0,0,0],
                [0,0,8,5,5,5,5,5,5,5,5,5,5,5,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,5,5,5,5,5,5,5,5,5,8,0,0,0,0],
                [0,8,8,5,5,5,5,5,5,5,5,5,5,5,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,5,5,5,5,5,5,5,5,5,8,8,0,0,0],
                [0,8,5,5,5,5,5,5,5,5,5,5,5,5,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,5,5,5,5,5,5,5,5,5,5,8,0,0,0],
                [0,8,5,5,5,5,5,5,5,5,5,5,5,5,5,1,1,2,2,2,6,6,6,6,6,6,6,6,2,2,1,1,5,5,5,5,5,5,5,5,5,5,5,5,8,0,0,0],
                [8,8,5,5,5,5,5,5,5,5,5,5,5,5,5,5,1,1,2,2,6,6,6,6,6,6,6,6,2,2,1,1,5,5,5,5,5,5,5,5,5,5,5,5,8,8,0,0],
                [8,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,1,1,2,2,2,2,2,2,2,2,2,2,1,1,5,5,5,5,5,5,5,5,5,5,5,5,5,5,8,0,0],
                [8,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,1,1,2,2,2,2,2,2,2,2,1,1,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,8,0,0],
                [8,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,1,1,1,1,1,1,1,1,1,1,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,8,0,0],
                [8,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,1,1,1,1,1,1,1,1,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,8,0,0],
                [8,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,8,0,0],
                [8,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,8,0,0],
                [8,8,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,8,8,0,0],
                [0,8,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,8,0,0,0],
                [0,8,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,8,0,0,0],
                [0,8,8,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,8,8,0,0,0],
                [0,0,8,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,8,0,0,0,0],
                [0,0,8,8,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,8,8,0,0,0,0],
                [0,0,0,8,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,8,0,0,0,0,0],
                [0,0,0,8,8,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,8,8,0,0,0,0,0],
                [0,0,0,0,8,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,8,0,0,0,0,0,0],
                [0,0,0,0,8,8,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,8,8,0,0,0,0,0,0],
                [0,0,0,0,0,8,8,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,8,8,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,8,8,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,8,8,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,8,8,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,8,8,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,8,8,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,8,8,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,8,8,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,8,8,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,8,8,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,8,8,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,8,8,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,8,8,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,8,8,8,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,8,8,8,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,8,8,8,8,5,5,5,5,5,5,5,5,5,5,5,5,5,8,8,8,8,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
            ],
            // Turtle Power-up (48x48 pixels) - Cute turtle with head/legs in gold bubble
            turtlePowerUp: [
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,8,8,8,8,5,5,5,5,5,5,5,5,5,5,5,5,5,5,8,8,8,8,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,8,8,8,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,8,8,8,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,8,8,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,8,8,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,8,8,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,8,8,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,8,8,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,8,8,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,8,8,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,8,8,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,8,8,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,8,8,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,8,5,5,5,5,5,5,5,5,5,5,5,5,5,5,1,1,1,1,1,1,5,5,5,5,5,5,5,5,5,5,5,5,8,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,8,8,5,5,5,5,5,5,5,5,5,5,5,5,1,1,1,1,1,1,1,1,1,1,5,5,5,5,5,5,5,5,5,5,8,8,0,0,0,0,0,0,0],
                [0,0,0,0,0,8,5,5,5,5,5,5,5,5,5,5,5,5,1,1,1,2,2,2,2,2,2,1,1,1,5,5,5,5,5,5,5,5,5,5,8,0,0,0,0,0,0,0],
                [0,0,0,0,8,8,5,5,5,5,5,5,5,5,5,5,5,1,1,2,2,2,2,2,2,2,2,2,2,1,1,5,5,5,5,5,5,5,5,5,8,8,0,0,0,0,0,0],
                [0,0,0,0,8,5,5,5,5,5,5,5,5,5,5,5,1,1,2,2,1,2,2,2,2,2,2,1,2,2,1,1,5,5,5,5,5,5,5,5,5,8,0,0,0,0,0,0],
                [0,0,0,8,8,5,5,5,5,5,5,5,5,5,5,5,1,2,2,1,1,1,2,2,2,2,1,1,1,2,2,1,5,5,5,5,5,5,5,5,5,8,8,0,0,0,0,0],
                [0,0,0,8,5,5,5,5,5,5,5,3,3,3,5,5,1,2,2,2,1,1,2,2,2,2,1,1,2,2,2,1,5,5,5,5,5,5,5,5,5,5,8,0,0,0,0,0],
                [0,0,8,8,5,5,5,5,5,5,3,3,3,3,3,5,1,1,2,2,2,2,2,2,2,2,2,2,2,2,1,1,5,5,5,5,5,5,5,5,5,5,8,8,0,0,0,0],
                [0,0,8,5,5,5,5,5,5,3,3,4,4,3,3,5,5,1,1,2,2,2,2,2,2,2,2,2,2,1,1,5,5,5,5,5,5,5,5,5,5,5,5,8,0,0,0,0],
                [0,8,8,5,5,5,5,5,5,3,3,3,3,3,3,5,5,5,1,1,1,2,2,2,2,2,2,1,1,1,5,5,5,5,5,5,5,5,5,5,5,5,5,8,8,0,0,0],
                [0,8,5,5,5,5,5,5,5,5,3,3,3,3,5,5,5,5,5,1,1,1,1,1,1,1,1,1,1,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,8,0,0,0],
                [0,8,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,8,0,0,0],
                [8,8,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,8,8,0,0],
                [8,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,8,0,0],
                [8,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,8,0,0],
                [8,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,8,0,0],
                [8,5,5,5,5,5,5,5,5,5,5,5,3,3,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,3,3,5,5,5,5,5,5,5,5,8,0,0],
                [8,5,5,5,5,5,5,5,5,5,5,5,3,3,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,3,3,5,5,5,5,5,5,5,5,8,0,0],
                [8,5,5,5,5,5,5,5,5,5,5,5,3,3,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,3,3,5,5,5,5,5,5,5,5,8,0,0],
                [8,8,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,8,8,0,0],
                [0,8,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,8,0,0,0],
                [0,8,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,8,0,0,0],
                [0,8,8,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,8,8,0,0,0],
                [0,0,8,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,8,0,0,0,0],
                [0,0,8,8,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,8,8,0,0,0,0],
                [0,0,0,8,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,8,0,0,0,0,0],
                [0,0,0,8,8,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,8,8,0,0,0,0,0],
                [0,0,0,0,8,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,8,0,0,0,0,0,0],
                [0,0,0,0,8,8,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,8,8,0,0,0,0,0,0],
                [0,0,0,0,0,8,8,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,8,8,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,8,8,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,8,8,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,8,8,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,8,8,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,8,8,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,8,8,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,8,8,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,8,8,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,8,8,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,8,8,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,8,8,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,8,8,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,8,8,8,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,8,8,8,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,8,8,8,8,5,5,5,5,5,5,5,5,5,5,5,5,5,8,8,8,8,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
            ],
            // Star Power-up (48x48 pixels) - Star in gold bubble
            starPowerUp: [
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,8,8,8,8,5,5,5,5,5,5,5,5,5,5,5,5,5,5,8,8,8,8,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,8,8,8,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,8,8,8,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,8,8,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,8,8,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,8,8,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,8,8,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,8,8,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,8,8,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,8,8,5,5,5,5,5,5,5,5,5,5,5,5,5,1,1,5,5,5,5,5,5,5,5,5,5,5,5,5,8,8,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,8,8,5,5,5,5,5,5,5,5,5,5,5,5,5,1,1,1,1,5,5,5,5,5,5,5,5,5,5,5,5,5,8,8,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,8,5,5,5,5,5,5,5,5,5,5,5,5,5,5,1,1,1,1,5,5,5,5,5,5,5,5,5,5,5,5,5,5,8,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,8,8,5,5,5,5,5,5,5,5,5,5,5,5,5,1,1,1,1,1,1,5,5,5,5,5,5,5,5,5,5,5,5,5,8,8,0,0,0,0,0,0,0],
                [0,0,0,0,0,8,5,5,5,5,5,5,5,5,5,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,5,5,5,5,5,5,5,5,5,8,0,0,0,0,0,0,0],
                [0,0,0,0,8,8,5,5,5,5,5,5,5,5,5,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,5,5,5,5,5,5,5,5,5,8,8,0,0,0,0,0,0],
                [0,0,0,0,8,5,5,5,5,5,5,5,5,5,5,5,1,1,1,1,1,1,1,1,1,1,1,1,1,1,5,5,5,5,5,5,5,5,5,5,5,8,0,0,0,0,0,0],
                [0,0,0,8,8,5,5,5,5,5,5,5,5,5,5,5,5,1,1,1,1,1,1,1,1,1,1,1,1,5,5,5,5,5,5,5,5,5,5,5,5,8,8,0,0,0,0,0],
                [0,0,0,8,5,5,5,5,5,5,5,5,5,5,5,5,5,5,1,1,1,1,1,1,1,1,1,1,5,5,5,5,5,5,5,5,5,5,5,5,5,5,8,0,0,0,0,0],
                [0,0,8,8,5,5,5,5,5,5,5,5,5,5,5,5,5,5,1,1,1,1,1,1,1,1,1,1,5,5,5,5,5,5,5,5,5,5,5,5,5,5,8,8,0,0,0,0],
                [0,0,8,5,5,5,5,5,5,5,5,5,5,5,5,5,5,1,1,1,1,1,1,1,1,1,1,1,1,5,5,5,5,5,5,5,5,5,5,5,5,5,5,8,0,0,0,0],
                [0,8,8,5,5,5,5,5,5,5,5,5,5,5,5,5,5,1,1,1,1,5,1,1,1,1,5,1,1,1,5,5,5,5,5,5,5,5,5,5,5,5,5,8,8,0,0,0],
                [0,8,5,5,5,5,5,5,5,5,5,5,5,5,5,5,1,1,1,1,5,5,5,1,1,5,5,5,1,1,1,5,5,5,5,5,5,5,5,5,5,5,5,5,8,0,0,0],
                [0,8,5,5,5,5,5,5,5,5,5,5,5,5,5,5,1,1,1,5,5,5,5,1,1,5,5,5,5,1,1,5,5,5,5,5,5,5,5,5,5,5,5,5,8,0,0,0],
                [8,8,5,5,5,5,5,5,5,5,5,5,5,5,5,1,1,1,5,5,5,5,5,1,1,5,5,5,5,5,1,1,5,5,5,5,5,5,5,5,5,5,5,5,8,8,0,0],
                [8,5,5,5,5,5,5,5,5,5,5,5,5,5,5,1,1,5,5,5,5,5,5,1,1,5,5,5,5,5,5,1,5,5,5,5,5,5,5,5,5,5,5,5,5,8,0,0],
                [8,5,5,5,5,5,5,5,5,5,5,5,5,5,1,1,1,5,5,5,5,5,5,1,1,5,5,5,5,5,5,1,1,5,5,5,5,5,5,5,5,5,5,5,5,8,0,0],
                [8,5,5,5,5,5,5,5,5,5,5,5,5,5,1,1,5,5,5,5,5,5,5,1,1,5,5,5,5,5,5,5,1,5,5,5,5,5,5,5,5,5,5,5,5,8,0,0],
                [8,5,5,5,5,5,5,5,5,5,5,5,5,5,1,1,5,5,5,5,5,5,5,1,1,5,5,5,5,5,5,5,1,5,5,5,5,5,5,5,5,5,5,5,5,8,0,0],
                [8,5,5,5,5,5,5,5,5,5,5,5,5,5,5,1,1,5,5,5,5,5,5,1,1,5,5,5,5,5,5,1,5,5,5,5,5,5,5,5,5,5,5,5,5,8,0,0],
                [8,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,1,1,5,5,5,5,5,1,1,5,5,5,5,5,1,5,5,5,5,5,5,5,5,5,5,5,5,5,5,8,0,0],
                [8,8,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,1,1,1,5,5,1,1,1,1,5,5,1,1,5,5,5,5,5,5,5,5,5,5,5,5,5,5,8,8,0,0],
                [0,8,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,1,1,1,1,1,1,1,1,1,1,1,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,8,0,0,0],
                [0,8,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,1,1,1,1,1,1,1,1,1,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,8,0,0,0],
                [0,8,8,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,8,8,0,0,0],
                [0,0,8,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,8,0,0,0,0],
                [0,0,8,8,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,8,8,0,0,0,0],
                [0,0,0,8,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,8,0,0,0,0,0],
                [0,0,0,8,8,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,8,8,0,0,0,0,0],
                [0,0,0,0,8,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,8,0,0,0,0,0,0],
                [0,0,0,0,8,8,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,8,8,0,0,0,0,0,0],
                [0,0,0,0,0,8,8,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,8,8,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,8,8,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,8,8,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,8,8,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,8,8,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,8,8,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,8,8,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,8,8,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,8,8,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,8,8,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,8,8,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,8,8,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,8,8,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,8,8,8,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,8,8,8,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,8,8,8,8,5,5,5,5,5,5,5,5,5,5,5,5,5,8,8,8,8,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
            ],
            // Money Power-up (48x48 pixels) - Dollar sign in green bubble
            moneyPowerUp: [
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,8,8,8,8,5,5,5,5,5,5,5,5,5,5,5,5,5,5,8,8,8,8,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,8,8,8,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,8,8,8,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,8,8,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,8,8,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,8,8,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,8,8,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,8,8,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,8,8,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,8,8,5,5,5,5,5,5,5,5,5,5,5,5,5,1,1,5,5,5,5,5,5,5,5,5,5,5,5,5,8,8,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,8,8,5,5,5,5,5,5,5,5,5,5,5,5,5,1,1,1,1,5,5,5,5,5,5,5,5,5,5,5,5,5,8,8,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,8,5,5,5,5,5,5,5,5,5,5,5,5,5,5,1,1,1,1,5,5,5,5,5,5,5,5,5,5,5,5,5,5,8,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,8,8,5,5,5,5,5,5,5,5,5,5,5,5,1,1,1,1,1,1,1,1,5,5,5,5,5,5,5,5,5,5,5,5,8,8,0,0,0,0,0,0,0],
                [0,0,0,0,0,8,5,5,5,5,5,5,5,5,5,5,5,5,1,1,1,1,1,1,1,1,1,1,5,5,5,5,5,5,5,5,5,5,5,5,8,0,0,0,0,0,0,0],
                [0,0,0,0,8,8,5,5,5,5,5,5,5,5,5,5,5,5,1,1,5,5,5,5,5,5,1,1,5,5,5,5,5,5,5,5,5,5,5,5,8,8,0,0,0,0,0,0],
                [0,0,0,0,8,5,5,5,5,5,5,5,5,5,5,5,5,5,1,1,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,8,0,0,0,0,0,0],
                [0,0,0,8,8,5,5,5,5,5,5,5,5,5,5,5,5,5,1,1,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,8,8,0,0,0,0,0],
                [0,0,0,8,5,5,5,5,5,5,5,5,5,5,5,5,5,5,1,1,1,1,1,1,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,8,0,0,0,0,0],
                [0,0,8,8,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,1,1,1,1,1,1,1,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,8,8,0,0,0,0],
                [0,0,8,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,1,1,1,1,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,8,0,0,0,0],
                [0,8,8,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,1,1,1,1,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,8,8,0,0,0],
                [0,8,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,1,1,1,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,8,0,0,0],
                [0,8,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,1,1,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,8,0,0,0],
                [8,8,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,1,1,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,8,8,0,0],
                [8,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,1,1,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,8,0,0],
                [8,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,1,1,5,5,5,5,5,5,1,1,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,8,0,0],
                [8,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,1,1,1,1,1,1,1,1,1,1,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,8,0,0],
                [8,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,1,1,1,1,1,1,1,1,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,8,0,0],
                [8,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,1,1,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,8,0,0],
                [8,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,1,1,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,8,0,0],
                [8,8,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,1,1,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,8,8,0,0],
                [0,8,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,1,1,5,5,5,5,1,1,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,8,0,0,0],
                [0,8,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,1,1,1,1,1,1,1,1,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,8,0,0,0],
                [0,8,8,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,1,1,1,1,1,1,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,8,8,0,0,0],
                [0,0,8,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,8,0,0,0,0],
                [0,0,8,8,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,8,8,0,0,0,0],
                [0,0,0,8,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,8,0,0,0,0,0],
                [0,0,0,8,8,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,8,8,0,0,0,0,0],
                [0,0,0,0,8,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,8,0,0,0,0,0,0],
                [0,0,0,0,8,8,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,8,8,0,0,0,0,0,0],
                [0,0,0,0,0,8,8,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,8,8,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,8,8,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,8,8,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,8,8,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,8,8,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,8,8,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,8,8,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,8,8,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,8,8,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,8,8,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,8,8,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,8,8,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,8,8,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,8,8,8,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,8,8,8,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,8,8,8,8,5,5,5,5,5,5,5,5,5,5,5,5,5,8,8,8,8,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
            ],
            // Laser Power-up (48x48 pixels) - Eye with beam in red bubble
            laserPowerUp: [
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,8,8,8,8,5,5,5,5,5,5,5,5,5,5,5,5,5,5,8,8,8,8,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,8,8,8,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,8,8,8,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,8,8,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,8,8,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,8,8,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,8,8,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,8,8,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,8,8,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,8,8,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,8,8,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,8,8,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,8,8,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,8,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,8,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,8,8,5,5,5,5,5,5,5,5,5,5,5,1,1,1,1,1,1,1,1,1,1,1,1,5,5,5,5,5,5,5,5,5,8,8,0,0,0,0,0,0,0],
                [0,0,0,0,0,8,5,5,5,5,5,5,5,5,5,5,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,5,5,5,5,5,5,5,5,8,0,0,0,0,0,0,0],
                [0,0,0,0,8,8,5,5,5,5,5,5,5,5,5,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,5,5,5,5,5,5,5,8,8,0,0,0,0,0,0],
                [0,0,0,0,8,5,5,5,5,5,5,5,5,5,1,1,1,1,1,1,1,2,2,2,2,2,2,1,1,1,1,1,1,1,5,5,5,5,5,5,5,8,0,0,0,0,0,0],
                [0,0,0,8,8,5,5,5,5,5,5,5,5,5,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,1,1,1,1,1,5,5,5,5,5,5,5,8,8,0,0,0,0,0],
                [0,0,0,8,5,5,5,5,5,5,5,5,5,1,1,1,1,1,2,2,2,2,3,3,3,3,2,2,2,2,1,1,1,1,1,5,5,5,5,5,5,5,8,0,0,0,0,0],
                [0,0,8,8,5,5,5,5,5,5,5,5,5,1,1,1,1,2,2,2,2,3,3,3,3,3,3,2,2,2,2,1,1,1,1,5,5,5,5,5,5,5,8,8,0,0,0,0],
                [0,0,8,5,5,5,5,5,5,5,5,5,5,1,1,1,1,2,2,2,3,3,3,4,4,3,3,3,2,2,2,1,1,1,1,5,5,5,5,5,5,5,5,8,0,0,0,0],
                [0,8,8,5,5,5,5,5,5,5,5,5,5,1,1,1,1,2,2,2,3,3,4,4,4,4,3,3,2,2,2,1,1,1,1,5,5,5,5,5,5,5,5,8,8,0,0,0],
                [0,8,5,5,5,5,5,5,5,5,5,5,5,1,1,1,1,2,2,2,3,3,4,4,4,4,3,3,2,2,2,1,1,1,1,5,5,5,5,5,5,5,5,5,8,0,0,0],
                [0,8,5,5,5,5,5,5,5,5,5,5,5,1,1,1,1,2,2,2,3,3,3,4,4,3,3,3,2,2,2,1,1,1,1,5,5,5,5,5,5,5,5,5,8,0,0,0],
                [8,8,5,5,5,5,5,5,5,5,5,5,5,1,1,1,1,2,2,2,2,3,3,3,3,3,3,2,2,2,2,1,1,1,1,5,5,5,5,5,5,5,5,5,8,8,0,0],
                [8,5,5,5,5,5,5,5,5,5,5,5,5,1,1,1,1,1,2,2,2,2,3,3,3,3,2,2,2,2,1,1,1,1,1,5,5,5,5,5,5,5,5,5,5,8,0,0],
                [8,5,5,5,5,5,5,5,5,5,5,5,5,5,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,1,1,1,1,1,5,5,5,5,5,5,5,5,5,5,5,8,0,0],
                [8,5,5,5,5,5,5,5,5,5,5,5,5,5,1,1,1,1,1,1,1,2,2,2,2,2,2,1,1,1,1,1,1,1,5,5,5,5,5,5,5,5,5,5,5,8,0,0],
                [8,5,5,5,5,5,5,5,5,5,5,5,5,5,5,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,5,5,5,5,5,5,5,5,5,5,5,5,8,0,0],
                [8,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,5,5,5,5,5,5,5,5,5,5,5,5,5,8,0,0],
                [8,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,1,1,1,1,1,1,1,1,1,1,1,1,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,8,0,0],
                [8,8,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,8,8,0,0],
                [0,8,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,8,0,0,0],
                [0,8,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,8,0,0,0],
                [0,8,8,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,8,8,0,0,0],
                [0,0,8,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,8,0,0,0,0],
                [0,0,8,8,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,8,8,0,0,0,0],
                [0,0,0,8,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,8,0,0,0,0,0],
                [0,0,0,8,8,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,8,8,0,0,0,0,0],
                [0,0,0,0,8,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,8,0,0,0,0,0,0],
                [0,0,0,0,8,8,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,8,8,0,0,0,0,0,0],
                [0,0,0,0,0,8,8,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,8,8,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,8,8,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,8,8,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,8,8,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,8,8,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,8,8,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,8,8,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,8,8,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,8,8,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,8,8,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,8,8,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,8,8,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,8,8,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,8,8,8,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,8,8,8,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,8,8,8,8,5,5,5,5,5,5,5,5,5,5,5,5,5,8,8,8,8,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
            ],
            // Body Double Power-up (48x48 pixels) - Two figures connected by energy beam in cyan bubble
            bodyDoublePowerUp: [
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,8,8,8,8,5,5,5,5,5,5,5,5,5,5,5,5,5,5,8,8,8,8,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,8,8,8,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,8,8,8,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,8,8,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,8,8,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,8,8,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,8,8,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,8,8,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,8,8,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,8,8,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,8,8,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,8,8,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,8,8,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,8,5,5,5,5,5,5,1,1,1,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,3,3,3,5,5,5,5,5,8,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,8,8,5,5,5,5,5,1,1,1,1,1,5,5,5,5,5,5,5,5,5,5,5,5,5,3,3,3,3,3,5,5,5,5,8,8,0,0,0,0,0,0,0],
                [0,0,0,0,0,8,5,5,5,5,5,5,1,1,1,1,1,5,5,5,5,5,5,5,5,5,5,5,5,5,3,3,3,3,3,5,5,5,5,5,8,0,0,0,0,0,0,0],
                [0,0,0,0,8,8,5,5,5,5,5,5,5,1,1,1,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,3,3,3,5,5,5,5,5,5,8,8,0,0,0,0,0,0],
                [0,0,0,0,8,5,5,5,5,5,5,5,5,2,2,2,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,4,4,4,5,5,5,5,5,5,5,8,0,0,0,0,0,0],
                [0,0,0,8,8,5,5,5,5,5,5,5,2,2,2,2,2,5,5,5,5,5,5,5,5,5,5,5,5,5,4,4,4,4,4,5,5,5,5,5,5,8,8,0,0,0,0,0],
                [0,0,0,8,5,5,5,5,5,5,5,5,2,2,2,2,2,5,5,5,5,5,5,5,5,5,5,5,5,5,4,4,4,4,4,5,5,5,5,5,5,5,8,0,0,0,0,0],
                [0,0,8,8,5,5,5,5,5,5,5,5,5,2,2,2,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,4,4,4,5,5,5,5,5,5,5,5,8,8,0,0,0,0],
                [0,0,8,5,5,5,5,5,5,5,5,5,5,2,2,2,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,4,4,4,5,5,5,5,5,5,5,5,5,8,0,0,0,0],
                [0,8,8,5,5,5,5,5,5,5,5,5,2,2,5,2,2,5,5,5,5,5,5,5,5,5,5,5,5,5,4,4,5,4,4,5,5,5,5,5,5,5,5,8,8,0,0,0],
                [0,8,5,5,5,5,5,5,5,5,5,5,2,5,5,5,2,6,6,6,6,6,6,6,6,6,6,6,6,6,4,5,5,5,4,5,5,5,5,5,5,5,5,5,8,0,0,0],
                [0,8,5,5,5,5,5,5,5,5,5,5,2,5,5,5,2,6,6,6,6,6,6,6,6,6,6,6,6,6,4,5,5,5,4,5,5,5,5,5,5,5,5,5,8,0,0,0],
                [8,8,5,5,5,5,5,5,5,5,5,5,2,2,5,2,2,5,5,5,5,5,5,5,5,5,5,5,5,5,4,4,5,4,4,5,5,5,5,5,5,5,5,5,8,8,0,0],
                [8,5,5,5,5,5,5,5,5,5,5,5,5,2,2,2,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,4,4,4,5,5,5,5,5,5,5,5,5,5,5,8,0,0],
                [8,5,5,5,5,5,5,5,5,5,5,5,5,2,2,2,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,4,4,4,5,5,5,5,5,5,5,5,5,5,5,8,0,0],
                [8,5,5,5,5,5,5,5,5,5,5,5,2,2,2,2,2,5,5,5,5,5,5,5,5,5,5,5,5,5,4,4,4,4,4,5,5,5,5,5,5,5,5,5,5,8,0,0],
                [8,5,5,5,5,5,5,5,5,5,5,5,2,2,2,2,2,5,5,5,5,5,5,5,5,5,5,5,5,5,4,4,4,4,4,5,5,5,5,5,5,5,5,5,5,8,0,0],
                [8,5,5,5,5,5,5,5,5,5,5,5,5,2,5,2,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,4,5,4,5,5,5,5,5,5,5,5,5,5,5,8,0,0],
                [8,5,5,5,5,5,5,5,5,5,5,5,5,2,5,2,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,4,5,4,5,5,5,5,5,5,5,5,5,5,5,8,0,0],
                [8,8,5,5,5,5,5,5,5,5,5,5,2,2,5,2,2,5,5,5,5,5,5,5,5,5,5,5,5,5,4,4,5,4,4,5,5,5,5,5,5,5,5,5,8,8,0,0],
                [0,8,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,8,0,0,0],
                [0,8,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,8,0,0,0],
                [0,8,8,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,8,8,0,0,0],
                [0,0,8,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,8,0,0,0,0],
                [0,0,8,8,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,8,8,0,0,0,0],
                [0,0,0,8,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,8,0,0,0,0,0],
                [0,0,0,8,8,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,8,8,0,0,0,0,0],
                [0,0,0,0,8,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,8,0,0,0,0,0,0],
                [0,0,0,0,8,8,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,8,8,0,0,0,0,0,0],
                [0,0,0,0,0,8,8,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,8,8,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,8,8,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,8,8,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,8,8,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,8,8,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,8,8,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,8,8,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,8,8,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,8,8,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,8,8,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,8,8,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,8,8,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,8,8,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,8,8,8,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,8,8,8,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,8,8,8,8,5,5,5,5,5,5,5,5,5,5,5,5,5,8,8,8,8,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
            ],
            // T-Rex sprite (48x56 pixels) - Large Chrome dino style for player transformation
            trex: [
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,2,2,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,3,3,3,3,3,3,3,3,3,3,1,1,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0],
                [1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0],
                [1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0],
                [0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0],
                [0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0],
                [0,0,0,1,1,1,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0],
                [0,0,0,0,1,1,1,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,1,1,1,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
            ],
            // Snowman (20x36 pixels)
            snowman: [
                [0,0,0,0,0,0,0,0,5,5,5,5,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,5,5,5,5,5,5,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,5,5,5,5,5,5,5,5,0,0,0,0,0,0],
                [0,0,0,0,0,5,5,5,5,5,5,5,5,5,5,0,0,0,0,0],
                [0,0,0,0,5,5,5,5,5,5,5,5,5,5,5,5,0,0,0,0],
                [0,0,0,0,5,5,5,5,5,5,5,5,5,5,5,5,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,1,1,1,1,1,1,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,0,0],
                [0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0],
                [0,0,0,0,0,1,1,2,2,1,1,2,2,1,1,0,0,0,0,0],
                [0,0,0,0,1,1,1,2,2,1,1,2,2,1,1,1,0,0,0,0],
                [0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0],
                [0,0,0,0,1,1,1,1,3,1,1,3,1,1,1,1,0,0,0,0],
                [0,0,0,0,0,1,1,1,1,3,3,1,1,1,1,0,0,0,0,0],
                [0,0,0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,4,4,4,4,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,1,1,1,1,1,1,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,0,0],
                [0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0],
                [0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0],
                [0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0],
                [0,0,0,1,1,1,1,2,1,1,1,1,2,1,1,1,1,0,0,0],
                [0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0],
                [0,0,1,1,1,1,1,1,2,1,1,2,1,1,1,1,1,1,0,0],
                [0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0],
                [0,1,1,1,1,1,1,1,1,2,2,1,1,1,1,1,1,1,1,0],
                [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
                [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
                [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
                [0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0],
                [0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0],
                [0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0],
                [0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0],
                [0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0],
                [0,0,0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,0,0]
            ],
            // Cactus (20x36 pixels) - doubled detail
            cactus: [
                [0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,1,2,2,1,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,1,1,2,2,1,1,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,1,2,2,2,2,1,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,1,2,2,2,2,1,0,0,0,0,0,0,0],
                [0,0,1,1,0,0,0,1,2,2,2,2,1,0,0,0,1,1,0,0],
                [0,1,1,2,1,0,0,1,2,2,2,2,1,0,0,1,2,1,1,0],
                [0,1,2,2,1,0,1,1,2,2,2,2,1,1,0,1,2,2,1,0],
                [1,1,2,2,1,1,1,1,2,2,2,2,1,1,1,1,2,2,1,1],
                [1,2,2,2,2,1,1,1,2,2,2,2,1,1,1,2,2,2,2,1],
                [1,2,2,2,2,1,1,1,2,2,2,2,1,1,1,2,2,2,2,1],
                [1,2,2,2,2,1,1,1,2,2,2,2,1,1,1,2,2,2,2,1],
                [1,2,2,2,2,2,1,1,2,2,2,2,1,1,2,2,2,2,2,1],
                [0,1,2,2,2,2,1,1,2,2,2,2,1,1,2,2,2,2,1,0],
                [0,0,1,2,2,2,1,1,2,2,2,2,1,1,2,2,2,1,0,0],
                [0,0,0,1,1,1,1,1,2,2,2,2,1,1,1,1,1,0,0,0],
                [0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0],
                [0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0],
                [0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0],
                [0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0],
                [0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0],
                [0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0],
                [0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0],
                [0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0],
                [0,0,0,0,0,0,1,1,1,2,2,1,1,1,0,0,0,0,0,0],
                [0,0,0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,0,0],
                [0,0,0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,0,0]
            ],
            // Jungle palm tree (20x36 pixels) - compact version
            jungleTree: [
                [0,0,0,0,0,1,1,1,1,0,0,1,1,1,1,0,0,0,0,0],
                [0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0],
                [0,0,0,1,1,1,2,2,1,1,1,1,2,2,1,1,1,0,0,0],
                [0,0,1,1,2,2,2,2,2,1,1,2,2,2,2,2,1,1,0,0],
                [0,1,1,2,2,2,2,2,1,0,0,1,2,2,2,2,2,1,1,0],
                [1,1,2,2,2,2,2,1,0,0,0,0,1,2,2,2,2,2,1,1],
                [1,1,2,2,2,2,1,0,0,0,0,0,0,1,2,2,2,2,1,1],
                [0,1,1,1,1,1,0,0,0,0,0,0,0,0,1,1,1,1,1,0],
                [0,0,0,0,0,0,0,0,0,3,3,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,3,3,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,3,3,3,3,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,3,3,3,3,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,3,3,3,3,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,3,3,3,3,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,3,3,3,3,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,3,3,3,3,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,3,3,3,3,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,3,3,3,3,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,3,3,3,3,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,3,3,3,3,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,3,3,3,3,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,3,3,3,3,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,3,3,3,3,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,3,3,3,3,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,3,4,4,3,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,3,4,4,3,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,3,3,4,4,3,3,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,3,3,4,4,3,3,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,3,3,3,4,4,3,3,3,0,0,0,0,0,0],
                [0,0,0,0,0,0,3,3,3,4,4,3,3,3,0,0,0,0,0,0],
                [0,0,0,0,0,3,3,3,3,4,4,3,3,3,3,0,0,0,0,0],
                [0,0,0,0,0,3,3,3,3,4,4,3,3,3,3,0,0,0,0,0],
                [0,0,0,0,3,3,3,3,3,4,4,3,3,3,3,3,0,0,0,0],
                [0,0,0,0,3,3,3,3,3,4,4,3,3,3,3,3,0,0,0,0],
                [0,0,0,3,3,3,3,3,3,4,4,3,3,3,3,3,3,0,0,0],
                [0,0,0,3,3,3,3,3,3,3,3,3,3,3,3,3,3,0,0,0]
            ],
            // Ship anchor - classic nautical design (20x36 pixels)
            anchor: [
                [0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,1,1,3,3,1,1,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,1,3,0,0,3,1,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,1,1,3,3,1,1,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0],
                [0,0,0,1,1,1,1,1,1,2,2,1,1,1,1,1,1,0,0,0],
                [0,0,1,1,3,3,3,3,1,2,2,1,3,3,3,3,1,1,0,0],
                [0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,1,1,1,1,1,1,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,1,1,2,1,1,2,1,1,0,0,0,0,0,0],
                [0,0,0,0,0,1,1,2,2,1,1,2,2,1,1,0,0,0,0,0],
                [0,0,0,0,1,1,2,2,0,0,0,0,2,2,1,1,0,0,0,0],
                [0,0,0,1,1,2,2,0,0,0,0,0,0,2,2,1,1,0,0,0],
                [0,0,1,1,2,2,0,0,0,0,0,0,0,0,2,2,1,1,0,0],
                [0,1,1,2,2,0,0,0,0,0,0,0,0,0,0,2,2,1,1,0],
                [1,1,2,2,4,0,0,0,0,0,0,0,0,0,0,4,2,2,1,1],
                [1,2,2,4,4,0,0,0,0,0,0,0,0,0,0,4,4,2,2,1],
                [1,2,4,4,0,0,0,0,0,0,0,0,0,0,0,0,4,4,2,1],
                [1,2,4,4,0,0,0,0,0,0,0,0,0,0,0,0,4,4,2,1],
                [1,1,2,4,4,0,0,0,0,0,0,0,0,0,0,4,4,2,1,1],
                [0,1,2,2,4,4,0,0,0,0,0,0,0,0,4,4,2,2,1,0],
                [0,1,1,2,2,4,4,0,0,0,0,0,0,4,4,2,2,1,1,0],
                [0,0,1,1,2,2,4,4,4,0,0,4,4,4,2,2,1,1,0,0],
                [0,0,0,1,1,2,2,4,4,4,4,4,4,2,2,1,1,0,0,0],
                [0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0]
            ],
            // ====== ANIMAL OBSTACLES (5000+ points) ======
            // Crab - wide sideways crab with claws (40x36 pixels)
            crab: [
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0],
                [0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0],
                [0,0,1,1,2,2,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,2,2,1,1,0,0],
                [0,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,0],
                [0,1,2,2,2,2,2,2,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,2,2,2,2,2,2,1,0],
                [0,1,2,2,2,2,2,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,2,2,2,2,2,1,0],
                [0,0,1,2,2,2,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,2,2,2,1,0,0],
                [0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,2,2,2,2,2,2,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,2,2,2,2,2,2,2,2,2,2,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,1,1,2,2,2,3,3,2,2,3,3,2,2,2,1,1,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,1,1,2,2,2,2,3,3,2,2,3,3,2,2,2,2,1,1,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,4,4,0,0,0,0,4,4,0,0,0,0,4,4,0,0,0,0,4,4,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,4,4,0,0,0,0,4,4,0,0,0,0,0,0,4,4,0,0,0,0,4,4,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,4,4,0,0,0,0,4,4,0,0,0,0,0,0,0,0,4,4,0,0,0,0,4,4,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,4,4,0,0,0,0,4,4,0,0,0,0,0,0,0,0,0,0,4,4,0,0,0,0,4,4,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,4,4,0,0,0,0,4,4,0,0,0,0,0,0,0,0,0,0,0,0,4,4,0,0,0,0,4,4,0,0,0,0,0,0],
                [0,0,0,0,0,4,4,0,0,0,0,4,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,4,0,0,0,0,4,4,0,0,0,0,0],
                [0,0,0,0,4,4,0,0,0,0,4,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,4,0,0,0,0,4,4,0,0,0,0],
                [0,0,0,0,4,0,0,0,0,0,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,0,0,0,0,0,4,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
            ],
            // Monkey - swinging monkey with tail (40x36 pixels)
            monkey: [
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,2,2,2,2,2,2,2,2,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,2,2,2,2,2,2,2,2,2,2,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,1,1,2,2,3,3,2,2,2,2,3,3,2,2,1,1,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,1,2,2,2,4,4,2,2,2,2,4,4,2,2,2,1,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,1,1,2,3,3,3,3,3,3,3,3,3,3,3,3,2,1,1,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,1,2,2,3,3,3,3,3,3,3,3,3,3,3,3,2,2,1,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,1,2,2,2,3,3,3,5,5,5,5,3,3,3,2,2,2,1,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,1,2,2,2,3,3,3,3,3,3,3,3,2,2,2,1,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,2,2,2,2,2,2,2,2,2,2,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,0,0,1,1,1,1,1,1,0,0,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,1,2,2,2,2,1,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,1,1,2,2,2,2,2,2,1,0,1,2,2,2,2,1,0,1,2,2,2,2,2,2,1,1,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,1,2,2,2,2,2,2,2,1,0,1,2,2,2,2,1,0,1,2,2,2,2,2,2,2,1,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,1,2,2,2,2,2,2,2,1,0,1,2,2,2,2,1,0,1,2,2,2,2,2,2,2,1,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,1,2,2,2,2,2,2,1,0,0,1,2,2,2,2,1,0,0,1,2,2,2,2,2,2,1,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,1,2,2,2,2,1,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,1,1,2,2,1,1,0,0,0,1,2,2,2,2,1,0,0,0,1,1,2,2,1,1,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,1,2,2,2,2,1,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,2,2,1,1,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,2,2,1,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,2,2,1,0,0,0,0,0,0,0,0,0,0,1,1,2,1,1,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,2,2,1,0,0,0,0,0,0,0,0,0,1,1,2,2,2,1,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,2,1,1,0,0,0,0,0,0,0,0,1,1,2,2,2,1,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,2,2,2,1,1,0,0,0,0,0,0,1,1,2,2,2,1,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,2,2,2,2,2,1,1,0,0,0,0,1,1,2,2,1,1,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,2,2,6,6,2,2,2,1,0,0,0,1,1,2,1,1,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,2,6,6,6,6,2,2,1,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,6,6,6,6,1,1,1,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,6,6,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
            ],
            // Scorpion - desert scorpion with raised tail (40x36 pixels)
            scorpion: [
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,2,2,1,1,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,2,3,3,2,1,1,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,2,3,3,3,1,1,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,2,2,3,3,1,1,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0,0],
                [0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0,0,0],
                [0,0,1,1,2,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0,0,0,0],
                [0,1,1,2,2,2,1,1,0,0,0,0,0,0,0,0,1,1,1,1,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,1,2,2,2,2,2,1,0,0,0,0,0,0,1,1,1,2,2,2,2,2,2,2,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,1,2,2,2,2,1,0,0,0,0,0,1,1,2,2,2,2,2,2,2,2,2,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,1,2,2,1,0,0,0,0,1,1,2,2,2,2,4,4,2,2,4,4,2,2,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,1,1,0,0,0,0,1,1,2,2,2,2,2,4,4,2,2,4,4,2,2,2,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,5,5,0,0,5,5,0,0,0,0,0,0,0,0,5,5,0,0,5,5,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,5,5,0,0,5,5,0,0,0,0,0,0,0,0,0,0,5,5,0,0,5,5,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,5,5,0,0,5,5,0,0,0,0,0,0,0,0,0,0,0,0,5,5,0,0,5,5,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,5,5,0,0,5,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,5,0,0,5,5,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,5,5,0,0,5,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,5,0,0,5,5,0,0,0,0,0,0,0,0],
                [0,0,0,5,5,0,0,5,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,5,0,0,5,5,0,0,0,0,0,0,0],
                [0,0,5,5,0,0,5,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,5,0,0,5,5,0,0,0,0,0,0],
                [0,0,5,0,0,0,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,0,0,0,5,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
            ],
            // Penguin - arctic penguin (40x36 pixels)
            penguin: [
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,2,2,1,1,1,1,2,2,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,2,2,1,1,1,1,2,2,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,3,3,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,3,3,3,3,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,4,4,4,4,4,4,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,4,4,4,4,4,4,4,4,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,4,4,4,4,4,4,4,4,4,4,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,4,4,4,4,4,4,4,4,4,4,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,1,1,1,4,4,4,4,4,4,4,4,4,4,4,4,1,1,1,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,1,1,1,4,4,4,4,4,4,4,4,4,4,4,4,1,1,1,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,1,1,1,1,4,4,4,4,4,4,4,4,4,4,4,4,1,1,1,1,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,1,1,1,1,4,4,4,4,4,4,4,4,4,4,4,4,1,1,1,1,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,1,1,1,1,4,4,4,4,4,4,4,4,4,4,4,4,1,1,1,1,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,1,1,1,1,4,4,4,4,4,4,4,4,4,4,4,4,1,1,1,1,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,4,4,4,4,4,4,4,4,4,4,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,4,4,4,4,4,4,4,4,4,4,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,4,4,4,4,4,4,4,4,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,4,4,4,4,4,4,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,3,3,3,3,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,3,3,3,3,3,3,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,3,3,3,0,0,3,3,3,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,3,3,3,0,0,0,0,3,3,3,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,3,3,0,0,0,0,0,0,3,3,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,3,3,0,0,0,0,0,0,3,3,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,3,3,0,0,0,0,0,0,3,3,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
            ],
            // ====== TRANSFORMATIVE SKIN SPRITES ======
            // Banana Suit - full banana costume (32x48)
            bananaSuit: [
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,3,3,3,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,3,3,3,3,3,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,2,2,1,1,1,1,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,2,1,1,1,1,1,1,1,1,2,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,2,1,1,1,1,1,1,1,1,1,1,2,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,2,1,1,1,1,1,1,1,1,1,1,1,1,2,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,2,1,1,1,4,4,4,4,4,4,1,1,1,2,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,2,1,1,4,4,4,4,4,4,4,4,1,1,2,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,2,1,1,4,4,5,5,5,5,4,4,1,1,2,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,2,1,1,4,4,5,5,5,5,4,4,1,1,2,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,2,1,1,4,4,4,6,6,4,4,4,1,1,2,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,2,1,1,1,4,4,4,4,4,4,1,1,1,2,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,2,1,1,1,1,1,1,1,1,1,1,1,1,2,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,2,2,1,1,1,1,1,1,1,1,1,1,1,1,2,2,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,2,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,2,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,0,0,0,0,0,0,0],
                [0,0,0,0,0,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,0,0,0,0,0,0,0],
                [0,0,0,0,0,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,0,0,0,0,0,0,0],
                [0,0,0,0,0,2,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,2,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,2,2,1,1,1,1,1,1,1,1,1,1,1,1,2,2,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,2,1,1,1,1,1,1,1,1,1,1,1,1,2,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,2,2,1,1,1,1,1,1,1,1,1,1,2,2,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,2,1,1,1,1,1,1,1,1,1,1,2,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,2,2,1,1,1,1,1,1,1,1,2,2,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,2,1,1,1,1,1,1,1,1,2,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,2,2,1,1,0,0,1,1,2,2,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,2,1,1,0,0,1,1,2,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,7,7,7,0,0,7,7,7,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,7,7,7,0,0,7,7,7,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,7,7,7,7,0,0,7,7,7,7,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,7,7,7,7,0,0,7,7,7,7,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,7,7,7,7,0,0,7,7,7,7,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,7,7,7,0,0,0,0,7,7,7,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,7,7,7,0,0,0,0,7,7,7,0,0,0,0,0,0,0,0,0,0,0,0]
            ],
            // Ninja - black outfit with red headband (32x48)
            ninjaSprite: [
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,5,5,5,5,5,5,5,5,5,5,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,5,5,6,5,5,5,5,5,5,6,5,5,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,1,1,1,3,3,1,1,1,1,3,3,1,1,1,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,1,1,1,3,4,1,1,1,1,4,3,1,1,1,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,1,1,1,3,3,1,1,1,1,3,3,1,1,1,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,7,7,7,7,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0],
                [0,0,0,0,0,2,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,0,0,0,0,0,0,0],
                [0,0,0,0,2,2,2,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,0,0,0,0,0,0],
                [0,0,0,0,2,2,2,0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,2,2,2,0,0,0,0,0,0],
                [0,0,0,0,2,2,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,2,2,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,7,7,7,7,0,0,0,0,0,0,0,0,0,0,7,7,7,7,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,7,7,7,7,0,0,0,0,0,0,0,0,0,0,7,7,7,7,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,7,7,7,7,0,0,0,0,0,0,0,0,0,0,7,7,7,7,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,7,7,7,7,0,0,0,0,0,0,0,0,0,0,7,7,7,7,0,0,0,0,0,0,0]
            ],
            // Pirate - brown coat, red bandana, eyepatch (32x48)
            pirateSprite: [
                [0,0,0,0,0,0,0,0,0,0,0,5,5,5,5,5,5,5,5,5,5,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,5,5,5,5,5,5,5,5,5,5,5,5,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,5,5,5,5,5,5,5,5,5,5,5,5,5,5,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,5,6,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,3,3,3,3,3,3,3,3,3,3,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,3,3,3,3,3,3,3,3,3,3,3,3,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,3,3,4,4,3,3,3,3,3,3,3,3,3,3,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,3,3,4,4,3,3,3,3,4,4,4,4,3,3,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,3,3,3,3,3,3,3,3,3,3,3,3,3,3,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,3,3,3,3,8,8,8,8,3,3,3,3,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,3,3,3,3,3,3,3,3,3,3,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,3,3,3,3,3,3,3,3,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,8,8,8,8,8,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,1,1,2,2,2,2,2,1,1,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,1,1,1,2,2,2,2,2,1,1,1,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,2,1,1,1,1,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,1,1,1,1,1,2,2,2,2,2,1,1,1,1,1,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,1,1,1,1,1,1,2,2,2,2,2,1,1,1,1,1,1,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,1,1,1,1,1,1,1,2,2,2,2,2,1,1,1,1,1,1,1,0,0,0,0,0,0,0],
                [0,0,0,0,0,3,3,1,1,1,1,1,1,2,2,2,2,2,1,1,1,1,1,1,3,3,0,0,0,0,0,0],
                [0,0,0,0,3,3,3,3,1,1,1,1,8,8,8,8,8,8,1,1,1,1,3,3,3,3,0,0,0,0,0,0],
                [0,0,0,0,3,3,3,0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,3,3,3,0,0,0,0,0,0],
                [0,0,0,0,3,3,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,3,3,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,7,7,7,7,0,0,7,7,7,7,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,7,7,7,7,0,0,7,7,7,7,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,7,7,7,7,7,0,0,7,7,7,7,7,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,7,7,7,7,0,0,0,0,7,7,7,7,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,7,7,7,7,7,0,0,0,0,7,7,7,7,7,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,7,7,7,7,0,0,0,0,0,0,7,7,7,7,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,7,7,7,7,7,0,0,0,0,0,0,7,7,7,7,7,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,7,7,7,7,0,0,0,0,0,0,0,0,7,7,7,7,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,7,7,7,7,7,0,0,0,0,0,0,0,0,7,7,7,7,7,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,7,7,7,7,0,0,0,0,0,0,0,0,0,0,7,7,7,7,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,7,7,7,7,7,0,0,0,0,0,0,0,0,7,7,7,7,7,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,7,7,7,7,7,0,0,0,0,0,0,0,0,7,7,7,7,7,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,7,7,7,7,7,0,0,0,0,0,0,0,0,7,7,7,7,7,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,7,7,7,7,7,0,0,0,0,0,0,0,0,7,7,7,7,7,0,0,0,0,0,0,0]
            ],
            // Astronaut - white suit, blue visor (32x48)
            astronautSprite: [
                [0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,1,1,1,5,5,5,5,5,5,5,5,5,5,1,1,1,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,1,1,5,5,5,5,5,5,5,5,5,5,5,5,1,1,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,1,1,5,5,3,3,3,3,3,3,3,3,5,5,1,1,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,1,1,5,3,3,3,3,3,3,3,3,3,3,5,1,1,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,1,1,5,3,3,3,3,3,3,3,3,3,3,5,1,1,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,1,1,5,3,3,3,3,3,3,3,3,3,3,5,1,1,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,1,1,5,5,3,3,3,3,3,3,3,3,5,5,1,1,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,1,1,5,5,5,5,5,5,5,5,5,5,5,5,1,1,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,1,1,5,5,5,5,5,5,5,5,5,5,1,1,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,1,4,4,1,1,1,1,4,4,1,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0],
                [0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0],
                [0,0,0,0,0,2,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,0,0,0,0,0,0],
                [0,0,0,0,2,2,2,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,0,0,0,0,0,0],
                [0,0,0,0,2,2,2,0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,2,2,2,0,0,0,0,0,0],
                [0,0,0,0,2,2,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,2,2,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,7,7,7,7,0,0,0,0,0,0,0,0,0,0,7,7,7,7,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,7,7,7,7,0,0,0,0,0,0,0,0,0,0,7,7,7,7,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,7,7,7,7,0,0,0,0,0,0,0,0,0,0,7,7,7,7,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,7,7,7,7,0,0,0,0,0,0,0,0,0,0,7,7,7,7,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,7,7,7,7,0,0,0,0,0,0,0,0,0,0,7,7,7,7,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,7,7,7,7,0,0,0,0,0,0,0,0,0,0,7,7,7,7,0,0,0,0,0,0,0]
            ],
            // Robot - metallic body with antenna (32x48)
            robotSprite: [
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,7,7,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,6,6,6,6,6,6,6,6,6,6,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,6,1,1,1,1,1,1,1,1,1,1,6,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,6,1,1,1,1,1,1,1,1,1,1,1,1,6,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,6,1,4,4,4,4,1,1,4,4,4,4,1,6,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,6,1,4,4,4,4,1,1,4,4,4,4,1,6,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,6,1,1,1,1,1,1,1,1,1,1,1,1,6,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,6,1,1,1,3,3,3,3,3,3,1,1,1,6,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,6,1,1,1,1,1,1,1,1,1,1,6,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,6,6,6,6,6,6,6,6,6,6,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,7,7,7,7,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,6,6,1,1,1,1,1,6,6,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,6,1,1,1,1,1,1,1,1,1,6,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,6,1,1,1,1,1,1,1,1,1,1,1,6,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,6,1,1,1,4,4,4,4,4,4,1,1,1,1,6,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,6,1,1,1,1,4,4,4,4,4,4,1,1,1,1,1,6,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,6,1,1,1,1,1,4,4,4,4,4,4,1,1,1,1,1,1,6,0,0,0,0,0,0,0],
                [0,0,0,0,0,6,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,6,0,0,0,0,0,0],
                [0,0,0,0,0,3,3,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,3,3,0,0,0,0,0,0],
                [0,0,0,0,3,3,3,3,1,1,1,1,1,1,1,1,1,1,1,1,1,1,3,3,3,3,0,0,0,0,0,0],
                [0,0,0,0,3,3,3,0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,3,3,3,0,0,0,0,0,0],
                [0,0,0,0,3,3,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,3,3,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,6,6,6,6,6,0,0,0,0,0,0,0,0,6,6,6,6,6,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,6,6,6,6,6,0,0,0,0,0,0,0,0,6,6,6,6,6,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,6,6,6,6,6,0,0,0,0,0,0,0,0,6,6,6,6,6,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,6,6,6,6,6,0,0,0,0,0,0,0,0,6,6,6,6,6,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,6,6,6,6,6,0,0,0,0,0,0,0,0,6,6,6,6,6,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,6,6,6,6,6,0,0,0,0,0,0,0,0,6,6,6,6,6,0,0,0,0,0,0,0]
            ],
            // Turtle obstacle (20x16) - cute turtle for Turtle Time transformation
            turtleObstacle: [
                [0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,1,2,2,2,2,1,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,1,2,1,2,1,2,1,2,1,0,0,0,0,0],
                [0,0,0,0,0,1,2,2,2,2,2,2,2,2,2,1,0,0,0,0],
                [0,0,0,0,1,2,2,2,2,2,2,2,2,2,2,2,1,0,0,0],
                [0,0,0,1,2,2,2,2,2,2,2,2,2,2,2,2,2,1,0,0],
                [0,0,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,0],
                [0,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1],
                [0,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1],
                [3,3,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,3,3],
                [3,4,3,1,2,2,2,2,2,2,2,2,2,2,2,2,1,3,4,3],
                [0,3,3,3,1,1,2,2,2,2,2,2,2,2,1,1,3,3,3,0],
                [0,0,3,3,0,0,1,1,1,1,1,1,1,1,0,0,3,3,0,0],
                [0,0,0,0,0,3,3,0,0,0,0,0,0,3,3,0,0,0,0,0],
                [0,0,0,0,0,3,3,0,0,0,0,0,0,3,3,0,0,0,0,0],
                [0,0,0,0,0,3,3,0,0,0,0,0,0,3,3,0,0,0,0,0]
            ]
        };

        // Colors for each sprite
        const colors = {
            // Snow outfit - winter gear
            runnerSnow: {
                1: '#8B5A2B',  // Hair
                2: '#DEB887',  // Skin
                3: '#000000',  // Eyes
                4: '#E53935',  // Red winter jacket/hat
                5: '#1A237E',  // Navy pants
                6: '#5D4037',  // Brown snow boots
                7: '#FFFFFF',  // Pom-pom
                8: '#CD5C5C'   // Mouth/smile
            },
            // Desert outfit - cowboy
            runnerDesert: {
                1: '#8B5A2B',  // Hair
                2: '#DEB887',  // Skin
                3: '#000000',  // Eyes
                4: '#8D6E63',  // Brown cowboy hat
                5: '#F5DEB3',  // Tan shirt
                6: '#5D4037',  // Brown vest
                7: '#1565C0',  // Blue jeans
                8: '#CD5C5C',  // Mouth/smile
                9: '#4E342E'   // Cowboy boots
            },
            // Jungle outfit - Tarzan
            runnerJungle: {
                1: '#5D4037',  // Dark hair
                2: '#C8A27A',  // Tanned skin
                3: '#000000',  // Eyes
                4: '#6D4C41'   // Brown loincloth
            },
            // Ocean outfit - scuba
            runnerOcean: {
                1: '#8B5A2B',  // Hair (hidden)
                2: '#DEB887',  // Skin (hidden)
                3: '#000000',  // Eyes
                4: '#FFB300',  // Yellow helmet
                5: '#81D4FA',  // Light blue visor
                6: '#212121',  // Black wetsuit
                7: '#000000'   // Black flippers
            },
            banana: {
                1: '#FFE135',  // Bright yellow
                2: '#FFC107',  // Darker yellow edge
                3: '#4E3524',  // Brown stem
                4: '#3E2723'   // Dark brown tip
            },
            // Power-up colors
            jetpack: {
                1: '#E0E0E0',  // Silver rocket body
                2: '#42A5F5',  // Blue window/cockpit
                3: '#B71C1C',  // Red fins
                4: '#FF5722',  // Orange flame
                5: '#B3E5FC',  // Light blue bubble
                6: '#FFEB3B',  // Yellow flame core
                7: '#2E7D32'   // Green outline (good collectible)
            },
            trexPowerUp: {
                1: '#546E7A',  // Gray dino body
                2: '#37474F',  // Dark gray shadow/eye
                3: '#FFFFFF',  // White teeth
                5: '#B3E5FC',  // Light blue bubble
                7: '#2E7D32'   // Green outline (good collectible)
            },
            trex: {
                1: '#546E7A',  // Gray dino body
                2: '#37474F',  // Dark gray eye
                3: '#FFFFFF'   // White teeth
            },
            turtleObstacle: {
                1: '#00695C',  // Dark teal shell outline
                2: '#009688',  // Teal shell
                3: '#4CAF50',  // Green limbs/head
                4: '#000000'   // Eye
            },
            // New power-up colors
            bubblePowerUp: {
                1: '#FFFFFF',  // White shield border
                2: '#00BCD4',  // Cyan shield fill
                5: '#B3E5FC',  // Light blue bubble
                7: '#00BCD4'   // Cyan outline (permanent buff)
            },
            pogoPowerUp: {
                1: '#FF5722',  // Orange spring border
                2: '#FF9800',  // Lighter orange spring
                3: '#795548',  // Brown base/handle
                5: '#B3E5FC',  // Light blue bubble
                7: '#00BCD4'   // Cyan outline (permanent buff)
            },
            lionPowerUp: {
                1: '#FFC107',  // Gold mane
                2: '#8D6E63',  // Brown face
                3: '#000000',  // Black eyes
                4: '#E91E63',  // Pink nose
                5: '#B3E5FC',  // Light blue bubble
                6: '#FFFFFF',  // White teeth
                8: '#FFD700'   // Gold outline (rare)
            },
            turtlePowerUp: {
                1: '#009688',  // Teal shell outline
                2: '#00695C',  // Dark teal shell pattern
                3: '#4CAF50',  // Green head/legs
                4: '#000000',  // Black eye
                5: '#B3E5FC',  // Light blue bubble
                8: '#FFD700'   // Gold outline (time-based)
            },
            starPowerUp: {
                1: '#FFEB3B',  // Yellow star
                5: '#B3E5FC',  // Light blue bubble
                8: '#FFD700'   // Gold outline (time-based)
            },
            moneyPowerUp: {
                1: '#4CAF50',  // Green dollar sign
                5: '#C8E6C9',  // Light green bubble
                8: '#2E7D32'   // Dark green outline
            },
            laserPowerUp: {
                1: '#F44336',  // Red eye outline
                2: '#FFCDD2',  // Light pink inner eye
                3: '#E91E63',  // Pink iris
                4: '#000000',  // Black pupil
                5: '#FFEBEE',  // Very light pink bubble
                8: '#B71C1C'   // Dark red outline
            },
            bodyDoublePowerUp: {
                1: '#00ACC1',  // Cyan head (left figure)
                2: '#4DD0E1',  // Cyan body (left figure)
                3: '#80DEEA',  // Light cyan head (right ghost)
                4: '#B2EBF2',  // Light cyan body (right ghost)
                5: '#E0F7FA',  // Very light cyan bubble
                6: '#4DD0E1',  // Energy beam
                8: '#00BCD4'   // Cyan outline (permanent buff)
            },
            // Transformative skin sprites and colors
            bananaSuit: {
                1: '#FFD700',  // Bright yellow peel
                2: '#DAA520',  // Dark yellow edge
                3: '#8B4513',  // Brown stem
                4: '#DEB887',  // Skin tone (face)
                5: '#000000',  // Eyes
                6: '#CD5C5C',  // Mouth
                7: '#5D4037',  // Shoes
                8: '#FFC107'   // Mid yellow
            },
            ninjaSprite: {
                1: '#1a1a1a',  // Black ninja outfit
                2: '#2d2d2d',  // Dark gray details
                3: '#DEB887',  // Skin (eyes only)
                4: '#000000',  // Eyes
                5: '#C62828',  // Red headband
                6: '#8B0000',  // Dark red
                7: '#4a4a4a'   // Belt/shoes
            },
            pirateSprite: {
                1: '#5D4037',  // Brown coat
                2: '#F5F5F5',  // White shirt
                3: '#DEB887',  // Skin
                4: '#000000',  // Eyes/eyepatch
                5: '#C62828',  // Red bandana
                6: '#FFD700',  // Gold details
                7: '#1a1a1a',  // Black boots
                8: '#8B4513'   // Brown belt
            },
            astronautSprite: {
                1: '#ECEFF1',  // White suit
                2: '#B0BEC5',  // Gray details
                3: '#1E88E5',  // Blue visor
                4: '#FF5722',  // Orange NASA logo
                5: '#37474F',  // Dark helmet frame
                6: '#DEB887',  // Skin (behind visor)
                7: '#455A64'   // Gray boots
            },
            robotSprite: {
                1: '#607D8B',  // Blue-gray metal body
                2: '#455A64',  // Dark metal
                3: '#B0BEC5',  // Light metal
                4: '#00BCD4',  // Cyan lights/visor
                5: '#FF5252',  // Red antenna light
                6: '#37474F',  // Dark details
                7: '#78909C'   // Mid gray
            },
            snowman: {
                1: '#FFFFFF',  // White snow body
                2: '#212121',  // Black eyes/buttons
                3: '#FF5722',  // Orange carrot nose
                4: '#E53935',  // Red scarf
                5: '#212121'   // Black top hat
            },
            cactus: {
                1: '#2E7D32',  // Dark green
                2: '#4CAF50'   // Light green
            },
            jungleTree: {
                1: '#2E7D32',  // Dark green leaves
                2: '#4CAF50',  // Light green leaves
                3: '#5D4037',  // Brown trunk
                4: '#8D6E63'   // Light brown trunk detail
            },
            anchor: {
                1: '#546E7A',  // Gunmetal gray body
                2: '#37474F',  // Dark gray shadow
                3: '#78909C',  // Light gray highlight
                4: '#8D6E63'   // Rust accent on flukes
            },
            // Animal obstacle colors (5000+ points)
            crab: {
                1: '#B71C1C',  // Dark red shell edge
                2: '#E53935',  // Red shell body
                3: '#000000',  // Black eyes
                4: '#FF8A65'   // Orange legs
            },
            monkey: {
                1: '#5D4037',  // Dark brown outline
                2: '#8D6E63',  // Brown fur
                3: '#FFCCBC',  // Light skin/face
                4: '#000000',  // Black eyes
                5: '#E91E63',  // Pink mouth/tongue
                6: '#6D4C41'   // Darker brown feet
            },
            scorpion: {
                1: '#1B5E20',  // Dark green outline
                2: '#388E3C',  // Green body
                3: '#FF5722',  // Orange stinger
                4: '#000000',  // Black eyes
                5: '#2E7D32'   // Dark green legs
            },
            penguin: {
                1: '#212121',  // Black feathers
                2: '#FFFFFF',  // White eyes
                3: '#FF9800',  // Orange beak/feet
                4: '#FAFAFA'   // White belly
            }
        };

        // Land configurations with muted backgrounds for better sprite visibility
        const lands = {
            snow: {
                name: 'Snow',
                skyTop: '#A8C5D9',     // Muted steel blue
                skyBottom: '#C9D9E5',  // Muted light gray-blue
                ground: '#ECEFF1',
                groundAccent: '#FFFFFF',
                obstacle: sprites.snowman,
                obstacleColors: colors.snowman,
                animalObstacle: sprites.penguin,      // Animal at 5000+ points
                animalObstacleColors: colors.penguin,
                runner: sprites.runnerSnow,
                runnerColors: colors.runnerSnow,
                floatingTextColor: '#1A237E'  // Dark indigo - contrasts with light blue sky
            },
            desert: {
                name: 'Desert',
                skyTop: '#D4C4A0',     // Muted tan
                skyBottom: '#E8DCC8',  // Muted cream
                ground: '#E6C47A',
                groundAccent: '#F5DEB3',
                obstacle: sprites.cactus,
                obstacleColors: colors.cactus,
                animalObstacle: sprites.scorpion,     // Animal at 5000+ points
                animalObstacleColors: colors.scorpion,
                runner: sprites.runnerDesert,
                runnerColors: colors.runnerDesert,
                floatingTextColor: '#4A148C'  // Deep purple - contrasts with tan/cream sky
            },
            jungle: {
                name: 'Jungle',
                skyTop: '#5A8A5F',     // Muted forest green
                skyBottom: '#7BA67F',  // Muted sage green
                ground: '#6D4C41',
                groundAccent: '#4CAF50',
                obstacle: sprites.jungleTree,
                obstacleColors: colors.jungleTree,
                animalObstacle: sprites.monkey,       // Animal at 5000+ points
                animalObstacleColors: colors.monkey,
                runner: sprites.runnerJungle,
                runnerColors: colors.runnerJungle,
                floatingTextColor: '#FFD600'  // Bright yellow - contrasts with green sky
            },
            ocean: {
                name: 'Ocean',
                skyTop: '#2A6A8A',     // Muted deep teal
                skyBottom: '#5A9AB0',  // Muted ocean blue
                ground: '#1565C0',
                groundAccent: '#42A5F5',
                obstacle: sprites.anchor,
                obstacleColors: colors.anchor,
                animalObstacle: sprites.crab,         // Animal at 5000+ points
                animalObstacleColors: colors.crab,
                runner: sprites.runnerOcean,
                runnerColors: colors.runnerOcean,
                floatingTextColor: '#FFAB00'  // Bright amber - contrasts with dark blue sky
            }
        };

        let selectedLand = 'snow';

        // Calculate dimensions from sprites
        const PLAYER_WIDTH = sprites.runnerSnow[0].length * PLAYER_SCALE;
        const PLAYER_HEIGHT = sprites.runnerSnow.length * PLAYER_SCALE;

        // Draw sprite function
        function drawSprite(ctx, x, y, pixels, scale, colorMap) {
            for (let row = 0; row < pixels.length; row++) {
                for (let col = 0; col < pixels[row].length; col++) {
                    const colorId = pixels[row][col];
                    if (colorId) {
                        ctx.fillStyle = colorMap[colorId];
                        ctx.fillRect(
                            x + col * scale,
                            y + row * scale,
                            scale,
                            scale
                        );
                    }
                }
            }
        }

        // Draw sprite with colored outline for accessibility
        function drawSpriteWithOutline(ctx, x, y, pixels, scale, colorMap, outlineColor, outlineWidth = 1) {
            const ow = outlineWidth * scale;

            // Draw outline by rendering slightly larger rects first
            ctx.fillStyle = outlineColor;
            for (let row = 0; row < pixels.length; row++) {
                for (let col = 0; col < pixels[row].length; col++) {
                    if (pixels[row][col]) {
                        ctx.fillRect(
                            x + col * scale - ow,
                            y + row * scale - ow,
                            scale + ow * 2,
                            scale + ow * 2
                        );
                    }
                }
            }

            // Draw sprite on top
            drawSprite(ctx, x, y, pixels, scale, colorMap);
        }

        // Draw player sprite with outline - handles transformative skins
        function drawSpriteWithOutlinePlayer(ctx, x, y, pixels, scale, colorMap, outlineColor, outlineWidth, skin) {
            // Check for transformative skin with custom sprite
            if (skin?.transformative && skin?.customSprite) {
                const customPixels = sprites[skin.customSprite];
                const customColors = colors[skin.customSprite];
                if (customPixels && customColors) {
                    drawSpriteWithOutline(ctx, x, y, customPixels, scale, customColors, outlineColor, outlineWidth);
                    return;
                }
            }
            // Recolor skin: draw with land sprite and skin colors
            drawSpriteWithOutline(ctx, x, y, pixels, scale, colorMap, outlineColor, outlineWidth);
        }

        // Draw sprite - handles transformative skins (use custom sprite) vs recolor skins (use land sprite)
        function drawSpriteWithOverlay(ctx, x, y, pixels, scale, colorMap, skin) {
            // Check if this is a transformative skin with its own sprite
            if (skin?.transformative && skin?.customSprite) {
                const customPixels = sprites[skin.customSprite];
                const customColors = colors[skin.customSprite];
                if (customPixels && customColors) {
                    // Use the custom sprite and colors instead of land-based sprite
                    drawSprite(ctx, x, y, customPixels, scale, customColors);
                    return;
                }
            }

            // Recolor skin: Draw base sprite with skin colors
            drawSprite(ctx, x, y, pixels, scale, colorMap);
        }

        // Merge skin color overrides with land colors for visual customization
        function getSkinColors(landColors, skinId) {
            const skin = SKINS[skinId];
            if (!skin?.colorOverrides || Object.keys(skin.colorOverrides).length === 0) {
                return landColors; // No overrides, use land defaults
            }
            // Create merged color map
            let merged = { ...landColors, ...skin.colorOverrides };

            // Rainbow animation - cycle through hues
            if (skin.animated && skinId === 'rainbow') {
                const hue = (gameTime * 3) % 360;
                merged[4] = `hsl(${hue}, 100%, 50%)`;
                merged[5] = `hsl(${(hue + 120) % 360}, 100%, 50%)`;
                merged[6] = `hsl(${(hue + 240) % 360}, 100%, 50%)`;
            }

            return merged;
        }

        // ============================================
        // PARTICLE SYSTEM
        // ============================================
        let particles = [];

        function spawnParticle(config) {
            particles.push({
                x: config.x,
                y: config.y,
                vx: config.vx || 0,
                vy: config.vy || 0,
                color: config.color,
                size: config.size || 3,
                life: 0,
                maxLife: config.maxLife || 30,
                gravity: config.gravity || 0
            });
        }

        function updateParticles(delta = 1) {
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.x += p.vx * delta;
                p.y += p.vy * delta;
                p.vy += (p.gravity || 0) * delta;
                p.life += delta;
                if (p.life >= p.maxLife) {
                    particles.splice(i, 1);
                }
            }
        }

        function drawParticles() {
            particles.forEach(p => {
                const alpha = 1 - (p.life / p.maxLife);
                ctx.globalAlpha = alpha;
                ctx.fillStyle = p.color;

                if (p.isStar) {
                    // Draw 4-point star shape for Superstar particles
                    ctx.save();
                    ctx.translate(p.x, p.y);
                    ctx.beginPath();
                    for (let i = 0; i < 8; i++) {
                        const radius = i % 2 === 0 ? p.size : p.size * 0.4;
                        const angle = (i * Math.PI / 4);
                        const px = Math.cos(angle) * radius;
                        const py = Math.sin(angle) * radius;
                        if (i === 0) ctx.moveTo(px, py);
                        else ctx.lineTo(px, py);
                    }
                    ctx.closePath();
                    ctx.fill();
                    ctx.restore();
                } else {
                    // Default rectangle particle
                    ctx.fillRect(p.x, p.y, p.size, p.size);
                }
            });
            ctx.globalAlpha = 1;
        }

        // Spawn cyan energy dissolve particles when body double is destroyed
        function spawnBodyDoubleDeathParticles(x, y) {
            const cyanColors = ['#00BCD4', '#4DD0E1', '#80DEEA', '#B2EBF2'];
            for (let i = 0; i < 15; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = 2 + Math.random() * 4;
                particles.push({
                    x: x + (Math.random() - 0.5) * 30,
                    y: y + (Math.random() - 0.5) * 40,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    life: 0,
                    maxLife: 30 + Math.random() * 20,
                    color: cyanColors[Math.floor(Math.random() * cyanColors.length)],
                    size: 4 + Math.random() * 6,
                    gravity: 0.05
                });
            }
        }

        function updateSkinEffects(delta = 1) {
            if (gameState !== 'playing' || !player) return;

            const skin = SKINS[selectedSkin];
            if (!skin?.effect) return;

            // Only spawn every few frames to avoid too many particles
            if (Math.floor(gameTime) % 3 !== 0) return;

            switch (skin.effect) {
                case 'fire':
                    spawnParticle({
                        x: player.x + Math.random() * 20,
                        y: player.y + PLAYER_HEIGHT - 10,
                        vx: -2 - Math.random() * 2,
                        vy: -Math.random() * 2,
                        color: ['#FF4500', '#FF6347', '#FFA500'][Math.floor(Math.random() * 3)],
                        size: 4 + Math.random() * 4,
                        maxLife: 20 + Math.random() * 15
                    });
                    break;
                case 'ice':
                    spawnParticle({
                        x: player.x + Math.random() * 20,
                        y: player.y + PLAYER_HEIGHT - 5,
                        vx: -1 - Math.random(),
                        vy: -0.5 + Math.random(),
                        color: ['#87CEEB', '#ADD8E6', '#E0FFFF'][Math.floor(Math.random() * 3)],
                        size: 2 + Math.random() * 3,
                        maxLife: 25
                    });
                    break;
                case 'shadow':
                    spawnParticle({
                        x: player.x + Math.random() * 20,
                        y: player.y + Math.random() * PLAYER_HEIGHT,
                        vx: -1,
                        vy: 0,
                        color: 'rgba(0,0,0,0.5)',
                        size: 5 + Math.random() * 5,
                        maxLife: 15
                    });
                    break;
                case 'sparkle':
                    if (Math.random() < 0.3) { // Less frequent
                        spawnParticle({
                            x: player.x + Math.random() * 30,
                            y: player.y + Math.random() * 40,
                            vx: -1,
                            vy: -0.5,
                            color: ['#FFFFFF', '#B9F2FF', '#E0FFFF'][Math.floor(Math.random() * 3)],
                            size: 2 + Math.random() * 2,
                            maxLife: 20
                        });
                    }
                    break;
            }
        }

        function clearParticles() {
            particles = [];
        }

        // Jetpack thrust particles
        function spawnJetpackParticles(x, y) {
            // Fire core particles (bright, fast, inner)
            for (let i = 0; i < 4; i++) {
                particles.push({
                    x: x + (Math.random() - 0.5) * 8,
                    y: y,
                    vx: (Math.random() - 0.5) * 1.5,
                    vy: 4 + Math.random() * 3,
                    life: 0,
                    color: ['#FFEB3B', '#FFF176', '#FFFFFF'][Math.floor(Math.random() * 3)], // Yellow/white core
                    size: 4 + Math.random() * 4,
                    maxLife: 12
                });
            }
            // Fire outer particles (orange/red, medium)
            for (let i = 0; i < 3; i++) {
                particles.push({
                    x: x + (Math.random() - 0.5) * 14,
                    y: y + Math.random() * 4,
                    vx: (Math.random() - 0.5) * 2.5,
                    vy: 3 + Math.random() * 2,
                    life: 0,
                    color: ['#FF5722', '#FF9800', '#F44336'][Math.floor(Math.random() * 3)], // Orange/red flames
                    size: 5 + Math.random() * 5,
                    maxLife: 18
                });
            }
            // Smoke particles (gray, slow, dispersing)
            for (let i = 0; i < 2; i++) {
                particles.push({
                    x: x + (Math.random() - 0.5) * 20,
                    y: y + Math.random() * 8,
                    vx: (Math.random() - 0.5) * 3,
                    vy: 2 + Math.random() * 1.5,
                    life: 0,
                    color: ['#757575', '#9E9E9E', '#BDBDBD'][Math.floor(Math.random() * 3)], // Gray smoke
                    size: 6 + Math.random() * 6,
                    maxLife: 25
                });
            }
        }

        // Spawn star-shaped particles for Superstar power-up
        function spawnStarParticle(x, y) {
            const angle = Math.random() * Math.PI * 2;
            const speed = 2 + Math.random() * 3;
            const size = 4 + Math.random() * 8; // Varying sizes
            const colorIndex = Math.floor(Math.random() * RAINBOW_COLORS.length);

            particles.push({
                x: x,
                y: y,
                vx: Math.cos(angle) * speed,
                vy: Math.sin(angle) * speed,
                life: 0,
                maxLife: 25 + Math.random() * 15,
                color: RAINBOW_COLORS[colorIndex],
                size: size,
                isStar: true // Flag for star-shaped rendering
            });
        }

        // ============================================
        // FLOATING TEXT SYSTEM (score popups)
        // ============================================
        let floatingTexts = [];

        function spawnFloatingText(x, y, text) {
            floatingTexts.push({
                x: x,
                y: y,
                text: text,
                life: 0,
                maxLife: 45, // ~0.75 seconds at 60fps
                vy: -2 // Float upward
            });
        }

        function updateFloatingTexts(delta = 1) {
            for (let i = floatingTexts.length - 1; i >= 0; i--) {
                const ft = floatingTexts[i];
                ft.y += ft.vy * delta;
                ft.life += delta;
                if (ft.life >= ft.maxLife) {
                    floatingTexts.splice(i, 1);
                }
            }
        }

        function drawFloatingTexts() {
            // Get contrasting color based on current land
            const land = lands[selectedLand];
            const textColor = land?.floatingTextColor || '#FFFFFF';

            floatingTexts.forEach(ft => {
                const alpha = 1 - (ft.life / ft.maxLife);
                ctx.globalAlpha = alpha;
                ctx.fillStyle = textColor;
                ctx.font = 'bold 24px monospace';  // Larger text (score display is 28px)
                ctx.textAlign = 'center';
                ctx.fillText(ft.text, ft.x, ft.y);
            });
            ctx.globalAlpha = 1;
        }

        function clearFloatingTexts() {
            floatingTexts = [];
        }

        // ============================================
        // BACKGROUND ANNOUNCEMENT SYSTEM
        // ============================================
        let announcement = {
            text: '',
            life: 0,
            maxLife: 120, // 2 seconds at 60fps
            phase: 'none' // 'fadein', 'hold', 'fadeout', 'none'
        };
        let announcementQueue = []; // Queue for back-to-back announcements
        let lastAnnouncedLevel = -1; // Track which level we announced (-1 = none yet)
        let highestLevelReached = 0; // Track highest level for stats

        /**
         * Get the current level based on score (every 1000 points = 1 level)
         * @param {number} currentScore - The player's current score
         * @returns {number} The current level (0, 1, 2, ... infinite)
         */
        function getCurrentLevel(currentScore) {
            return Math.floor(currentScore / 1000);
        }

        /**
         * Queue an announcement to be shown
         * If no announcement is playing, starts immediately
         * @param {string} text - The text to display
         */
        function triggerAnnouncement(text) {
            if (announcement.phase === 'none') {
                // Start immediately if nothing playing
                announcement = {
                    text: text,
                    life: 0,
                    maxLife: 120, // 2 seconds total
                    phase: 'fadein'
                };
            } else {
                // Queue for later
                announcementQueue.push(text);
            }
        }

        /**
         * Queue multiple announcements to play in sequence
         * @param {string[]} texts - Array of announcement texts
         */
        function queueAnnouncements(texts) {
            texts.forEach(text => triggerAnnouncement(text));
        }

        function updateAnnouncement() {
            if (announcement.phase === 'none') {
                // Check if there's a queued announcement
                if (announcementQueue.length > 0) {
                    const nextText = announcementQueue.shift();
                    announcement = {
                        text: nextText,
                        life: 0,
                        maxLife: 120,
                        phase: 'fadein'
                    };
                }
                return;
            }

            announcement.life++;

            // Fade in for first 20 frames
            if (announcement.phase === 'fadein' && announcement.life >= 20) {
                announcement.phase = 'hold';
            }
            // Hold for middle section
            else if (announcement.phase === 'hold' && announcement.life >= announcement.maxLife - 30) {
                announcement.phase = 'fadeout';
            }
            // Fade out for last 30 frames
            else if (announcement.phase === 'fadeout' && announcement.life >= announcement.maxLife) {
                announcement.phase = 'none';
                announcement.text = '';
                // Queue processing happens at start of next call
            }
        }

        function drawAnnouncement() {
            if (announcement.phase === 'none' || !announcement.text) return;

            const land = lands[selectedLand];
            const textColor = land?.floatingTextColor || '#FFFFFF';

            // Calculate alpha based on phase
            let alpha = 0.4; // Base transparency
            if (announcement.phase === 'fadein') {
                alpha = 0.4 * (announcement.life / 20);
            } else if (announcement.phase === 'fadeout') {
                const fadeoutProgress = (announcement.life - (announcement.maxLife - 30)) / 30;
                alpha = 0.4 * (1 - fadeoutProgress);
            }

            ctx.save();
            ctx.globalAlpha = alpha;

            // Calculate font size to fit ~70% of screen width
            const targetWidth = canvas.width * 0.7;
            let fontSize = 100;
            ctx.font = `bold ${fontSize}px monospace`;
            let textWidth = ctx.measureText(announcement.text).width;

            // Adjust font size to fit
            while (textWidth > targetWidth && fontSize > 20) {
                fontSize -= 5;
                ctx.font = `bold ${fontSize}px monospace`;
                textWidth = ctx.measureText(announcement.text).width;
            }

            // Position in center of screen, slightly above middle
            const x = canvas.width / 2;
            const y = canvas.height * 0.45;

            ctx.fillStyle = textColor;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(announcement.text, x, y);

            ctx.restore();
        }

        function clearAnnouncement() {
            announcement = { text: '', life: 0, maxLife: 120, phase: 'none' };
            announcementQueue = [];
            lastAnnouncedLevel = -1;
        }

        /**
         * Check if we've reached a new level and trigger announcement
         * Levels are infinite (no cap)
         */
        function checkLevelAnnouncement() {
            const currentLevel = getCurrentLevel(score);

            // Track highest level reached for stats
            if (currentLevel > highestLevelReached) {
                highestLevelReached = currentLevel;
            }

            // Check if we've reached a new level (1 or higher)
            if (currentLevel > lastAnnouncedLevel && currentLevel >= 1) {
                triggerAnnouncement(`LEVEL ${currentLevel}`);
                lastAnnouncedLevel = currentLevel;
            }
        }

        // ============================================
        // JUMP OVER OBSTACLE TRACKING
        // ============================================
        let obstaclesJumpedOver = new Set(); // Track which obstacle groups we've cleared
        let spawnIdCounter = 0; // Unique ID for each spawn group
        let jumpBonusScore = 0; // Accumulated jump bonus points

        // ============================================
        // CONSECUTIVE OBSTACLE PREVENTION
        // ============================================
        // Prevent more than 2 consecutive spawns of same obstacle count
        let lastObstacleCount = 0; // Previous obstacle count
        let consecutiveSameCount = 0; // How many times same count spawned in a row

        // ============================================
        // POWER-UP SYSTEM - SHARED CONSTANTS
        // ============================================
        const TIME_BUFF_DURATION = 420; // 7 seconds at 60fps for all time-based buffs
        let powerUpBonusScore = 0; // Accumulated power-up bonus points
        let powerUpSpawnCounter = 0; // Track spawns to guarantee power-ups

        // ============================================
        // PERMANENT BUFFS (last entire run, max 1 each)
        // ============================================
        let bubbleShieldCount = 0;    // 0 or 1 - absorbs one hit
        let bubblePopInvincibility = 0; // Brief invincibility after bubble pops (frames)
        const BUBBLE_POP_INVINCIBILITY = 30; // ~0.5 seconds of invincibility after bubble pops
        let pogoStickCount = 0;       // 0 or 1 - increases jump height
        let lionRoarUsed = false;     // Lion already used this run
        let obstaclesShrunk = false;  // Obstacles are at 80% size (20% reduction)

        // ============================================
        // TIME-BASED BUFFS (7 seconds each)
        // ============================================
        // Jetpack - fly above obstacles
        let jetpackActive = false;
        let jetpackTimer = 0;
        let jetpackTargetY = 0;
        // Jetpack hovers at banana level - high enough to clear obstacles, low enough to collect bananas
        const JETPACK_FLY_HEIGHT = BANANA_HEIGHT_OFFSET + 10; // ~65px above ground (banana level)
        const JETPACK_RISE_SPEED = 6;

        // T-Rex/Dino - stomp through obstacles
        let trexActive = false;
        let trexTimer = 0;
        const TREX_WIDTH = 48 * PLAYER_SCALE;
        const TREX_HEIGHT = 48 * PLAYER_SCALE;

        // Turtle - halves game speed
        let turtleActive = false;
        let turtleTimer = 0;

        // Star - full invincibility with rainbow effect
        let starActive = false;
        let starTimer = 0;
        let starColorIndex = 0;
        const RAINBOW_COLORS = ['#FF0000', '#FF7F00', '#FFFF00', '#00FF00', '#0000FF', '#4B0082', '#9400D3'];

        // Money - double points earned while active (not total score)
        let moneyActive = false;
        let moneyTimer = 0;
        let moneyBonusAccumulated = 0; // Extra points earned from 2x multiplier
        const MONEY_DURATION = 420; // 7 seconds

        // Helper function to add bonus points (shows 2x text when money is active)
        // Note: The actual 2x doubling is handled by the score tracking system
        function addBonusPoints(points, x, y, showText = true) {
            powerUpBonusScore += points;
            if (moneyActive && showText) {
                spawnFloatingText(x, y, `+${points * 2} (2X!)`);
            } else if (showText) {
                spawnFloatingText(x, y, `+${points}`);
            }
        }

        // Laser - disco ball destruction beams (7 seconds)
        let laserActive = false;
        let laserTimer = 0;
        const LASER_DURATION = 420; // 7 seconds (same as other time-based buffs)
        let laserAngle = 0;  // For spinning laser effect

        // ============================================
        // SCREEN SHAKE SYSTEM
        // ============================================
        let screenShakeIntensity = 0;
        let screenShakeDecay = 0.85; // How quickly shake fades (lower = faster fade)
        let dinoShakeTimer = 0;
        const DINO_SHAKE_INTERVAL = 90; // ~1.5 seconds between periodic shakes

        function triggerScreenShake(intensity) {
            screenShakeIntensity = Math.max(screenShakeIntensity, intensity);
        }

        // ============================================
        // DINO FOOTPRINT ANIMATION
        // ============================================
        let dinoFootprints = []; // Array of {x, y, isLeft, alpha, timer}
        let dinoFootTimer = 0;
        const DINO_FOOT_INTERVAL = 25; // Spawn new footprint every ~0.4 seconds
        const DINO_FOOT_DURATION = 50; // Each footprint lasts ~0.8 seconds
        let dinoFootLeft = true; // Alternate left/right

        // ============================================
        // LION ROAR ANIMATION
        // ============================================
        let lionEmojiActive = false;
        let lionEmojiTimer = 0;
        let lionEmojiScale = 1;
        const LION_EMOJI_DURATION = 60; // 1 second animation

        // ============================================
        // TURTLE TIME ANIMATION
        // ============================================
        let turtleEmojiActive = false;
        let turtleEmojiTimer = 0;
        let turtleEmojiScale = 1;
        const TURTLE_EMOJI_DURATION = 60; // 1 second animation

        // ============================================
        // BODY DOUBLE POWER-UP
        // ============================================
        let bodyDoubleActive = false;
        let bodyDoubleY = 0;           // Vertical position (follows player with delay)
        let bodyDoubleVY = 0;          // Vertical velocity
        let bodyDoubleJumping = false; // Jump state
        const BODY_DOUBLE_OFFSET_X = 70; // How far ahead (pixels to the right)
        const BODY_DOUBLE_DELAY_FRAMES = 4; // Input delay in frames (~67ms)
        let bodyDoubleInputBuffer = []; // Stores {y, vy, jumping} for each frame

        // ============================================
        // POWER-UP SESSION TRACKING (for achievements)
        // ============================================
        let sessionBubblesCollected = 0;
        let sessionPogosCollected = 0;
        let sessionLionsCollected = 0;
        let sessionTurtlesCollected = 0;
        let sessionStarsCollected = 0;
        let sessionBubbleHitsAbsorbed = 0;
        let sessionMoneyCollected = 0;
        let sessionLasersCollected = 0;
        let sessionBodyDoublesCollected = 0;

        // ============================================
        // POWER-UP PRIORITY SYSTEM (Strongest Wins)
        // ============================================
        // Priority order: Star > Laser > Dino > Jetpack > Bubble > None
        function getActiveProtection() {
            if (starActive) return 'star';
            if (laserActive) return 'laser';
            if (trexActive) return 'dino';
            if (jetpackActive) return 'jetpack';
            if (bubbleShieldCount > 0) return 'bubble';
            return 'none';
        }

        // Game state: 'welcome', 'menu', 'playing', 'gameover', 'leaderboard', 'lobby'
        // (gameState declared early to avoid temporal dead zone)
        let gameMode = 'solo'; // 'solo' or 'multiplayer'
        let score = 0;
        let bananasCollected = 0;
        let gameTime = 0;
        let speed = INITIAL_SPEED;
        // (spawnCounter declared early to avoid temporal dead zone)
        let scrollOffset = 0;
        // (entities declared early to avoid temporal dead zone)
        let scoreSaved = false; // Track if score was saved for current game

        // Leaderboard data
        let leaderboardData = [];
        let loadingLeaderboard = false;

        // Game Over stats
        let gameOverStats = {
            globalTopScore: null,
            globalTopPlayer: null,
            biomeTopScore: null,
            biomeTopPlayer: null,
            personalBiomeBest: null,
            isNewBiomeBest: false,
            isNewGlobalBest: false,
            loading: true
        };

        // Multiplayer lobby state
        let currentLobby = null;
        let lobbyPlayers = [];
        let lobbySubscription = null;
        let isLobbyHost = false;
        let lobbyCodeInput = '';
        let lobbyJoinError = '';
        const MAX_LOBBY_PLAYERS = 7;

        // Multiplayer game state
        let multiplayerPlayers = [];  // All players' states for rendering
        let localPlayerIndex = 0;     // My position in the player order
        let localPlayerAlive = true;  // Am I still alive?
        let allPlayersStates = {};    // Track all player states by ID
        let gameChannel = null;       // Supabase realtime channel for game state

        // Legacy (will be replaced by multiplayerPlayers)
        let opponentScore = 0;
        let opponentBananas = 0;
        let gameResult = null; // 'win', 'lose', 'tie'

        // Skins system - Achievement skins (free when unlocked) and Purchasable skins
        const SKINS = {
            // =====================================
            // TIER 0: DEFAULT (Always Unlocked)
            // =====================================
            default: {
                name: 'Classic Runner',
                description: 'The original banana chaser',
                type: 'default',
                tier: 0,
                colorOverrides: {}
            },

            // =====================================
            // TIER 1: ACHIEVEMENT SKINS (Free)
            // =====================================
            golden: {
                name: 'Golden Runner',
                description: 'Collect 100 bananas total',
                type: 'achievement',
                tier: 1,
                unlockReq: { type: 'bananas', value: 100 },
                colorOverrides: { 4: '#FFD700', 5: '#FFC107', 6: '#B8860B' }
            },
            speedster: {
                name: 'Speed Demon',
                description: 'Score 5000 in one game',
                type: 'achievement',
                tier: 1,
                unlockReq: { type: 'score', value: 5000 },
                colorOverrides: { 4: '#E91E63', 5: '#FF4081', 6: '#AD1457' },
                effect: 'fire'  // FREE fire trail for achievement!
            },
            veteran: {
                name: 'Veteran',
                description: 'Play 50 games',
                type: 'achievement',
                tier: 1,
                unlockReq: { type: 'games', value: 50 },
                colorOverrides: { 4: '#4CAF50', 5: '#2E7D32', 6: '#1B5E20' }  // Green camo
            },
            champion: {
                name: 'Champion',
                description: 'Win 10 multiplayer games',
                type: 'achievement',
                tier: 1,
                unlockReq: { type: 'mp_wins', value: 10 },
                colorOverrides: { 4: '#9C27B0', 5: '#7B1FA2', 6: '#4A148C' }
            },

            // =====================================
            // TIER 2: BUDGET SHOP (25-75 bananas)
            // =====================================
            ninja: {
                name: 'Ninja',
                description: 'Silent but deadly',
                type: 'purchasable',
                tier: 2,
                price: 25,
                transformative: true,
                customSprite: 'ninjaSprite'
            },
            pirate: {
                name: 'Pirate',
                description: 'Arr, bananas ahead!',
                type: 'purchasable',
                tier: 2,
                price: 50,
                transformative: true,
                customSprite: 'pirateSprite'
            },
            astronaut: {
                name: 'Astronaut',
                description: 'One small step...',
                type: 'purchasable',
                tier: 2,
                price: 75,
                transformative: true,
                customSprite: 'astronautSprite'
            },

            // =====================================
            // TIER 3: PREMIUM SHOP (100-200 bananas)
            // =====================================
            flame: {
                name: 'Flame Runner',
                description: 'Leave fire in your wake',
                type: 'purchasable',
                tier: 3,
                price: 100,
                colorOverrides: { 4: '#FF5722', 5: '#FF8A65', 6: '#BF360C' },
                effect: 'fire'
            },
            ice: {
                name: 'Ice Runner',
                description: 'Cool as a cucumber',
                type: 'purchasable',
                tier: 3,
                price: 125,
                colorOverrides: { 4: '#4FC3F7', 5: '#81D4FA', 6: '#0288D1' },
                effect: 'ice'
            },
            neon: {
                name: 'Neon Glow',
                description: 'Light up the night',
                type: 'purchasable',
                tier: 3,
                price: 150,
                colorOverrides: { 4: '#00FF00', 5: '#39FF14', 6: '#76FF03' }
            },
            shadow: {
                name: 'Shadow',
                description: 'Embrace the darkness',
                type: 'purchasable',
                tier: 3,
                price: 175,
                colorOverrides: { 4: '#212121', 5: '#424242', 6: '#0d0d0d' },
                effect: 'shadow'
            },
            rainbow: {
                name: 'Rainbow Runner',
                description: 'All the colors!',
                type: 'purchasable',
                tier: 3,
                price: 200,
                colorOverrides: { 4: '#FF0000', 5: '#00FF00', 6: '#0000FF' },
                animated: true
            },
            banana: {
                name: 'Banana Suit',
                description: 'Become the banana!',
                type: 'purchasable',
                tier: 3,
                price: 150,
                transformative: true,
                customSprite: 'bananaSuit'
            },

            // =====================================
            // TIER 4: LEGENDARY (300-500 bananas)
            // =====================================
            robot: {
                name: 'Robot',
                description: 'Beep boop banana',
                type: 'purchasable',
                tier: 4,
                price: 300,
                transformative: true,
                customSprite: 'robotSprite'
            },
            ghost: {
                name: 'Ghost',
                description: 'Spooky runner',
                type: 'purchasable',
                tier: 4,
                price: 350,
                colorOverrides: {
                    1: '#E0E0E0', 2: '#EEEEEE',  // Pale ghost
                    4: '#F5F5F5', 5: '#FAFAFA', 6: '#E0E0E0'
                },
                transparency: 0.7  // Semi-transparent!
            },
            diamond: {
                name: 'Diamond',
                description: 'Shine bright',
                type: 'purchasable',
                tier: 4,
                price: 500,
                colorOverrides: { 4: '#B9F2FF', 5: '#E0FFFF', 6: '#AFEEEE' },
                effect: 'sparkle'
            }
        };

        // ============================================
        // COMPREHENSIVE ACHIEVEMENTS SYSTEM
        // ============================================
        // Each achievement has:
        // - name: Display name
        // - description: Kid-friendly description
        // - reward: Banana reward for unlocking
        // - requirement: { type, value } for unlock logic
        // - category: For organizing in achievements page
        const ACHIEVEMENTS = {
            // =====================================
            // GETTING STARTED (Games Played)
            // =====================================
            first_game: {
                name: 'First Steps',
                description: 'Play your very first game!',
                reward: 5,
                requirement: { type: 'total_games', value: 1 },
                category: 'games'
            },
            getting_started: {
                name: 'Getting Started',
                description: 'Play 5 games total',
                reward: 10,
                requirement: { type: 'total_games', value: 5 },
                category: 'games'
            },
            regular_player: {
                name: 'Regular Player',
                description: 'Play 10 games total',
                reward: 15,
                requirement: { type: 'total_games', value: 10 },
                category: 'games'
            },
            dedicated_runner: {
                name: 'Dedicated Runner',
                description: 'Play 25 games total',
                reward: 25,
                requirement: { type: 'total_games', value: 25 },
                category: 'games'
            },
            banana_master: {
                name: 'Banana Master',
                description: 'Play 50 games total',
                reward: 50,
                requirement: { type: 'total_games', value: 50 },
                category: 'games'
            },
            true_champion: {
                name: 'True Champion',
                description: 'Play 100 games total!',
                reward: 100,
                requirement: { type: 'total_games', value: 100 },
                category: 'games'
            },

            // =====================================
            // SCORE ACHIEVEMENTS
            // =====================================
            first_hundred: {
                name: 'First Hundred',
                description: 'Score 100 points in one game',
                reward: 5,
                requirement: { type: 'high_score', value: 100 },
                category: 'score'
            },
            making_progress: {
                name: 'Making Progress',
                description: 'Score 500 points in one game',
                reward: 10,
                requirement: { type: 'high_score', value: 500 },
                category: 'score'
            },
            breaking_through: {
                name: 'Breaking Through',
                description: 'Score 1000 points in one game',
                reward: 15,
                requirement: { type: 'high_score', value: 1000 },
                category: 'score'
            },
            skilled_runner: {
                name: 'Skilled Runner',
                description: 'Score 2500 points in one game',
                reward: 25,
                requirement: { type: 'high_score', value: 2500 },
                category: 'score'
            },
            expert_runner: {
                name: 'Expert Runner',
                description: 'Score 5000 points in one game',
                reward: 50,
                requirement: { type: 'high_score', value: 5000 },
                category: 'score'
            },
            master_runner: {
                name: 'Master Runner',
                description: 'Score 10000 points in one game!',
                reward: 100,
                requirement: { type: 'high_score', value: 10000 },
                category: 'score'
            },
            legendary_runner: {
                name: 'Legendary Runner',
                description: 'Score 25000 points in one game!',
                reward: 250,
                requirement: { type: 'high_score', value: 25000 },
                category: 'score'
            },

            // =====================================
            // BANANA COLLECTION
            // =====================================
            first_banana: {
                name: 'First Banana',
                description: 'Collect your first banana!',
                reward: 1,
                requirement: { type: 'total_bananas', value: 1 },
                category: 'bananas'
            },
            banana_bunch: {
                name: 'Banana Bunch',
                description: 'Collect 10 bananas total',
                reward: 5,
                requirement: { type: 'total_bananas', value: 10 },
                category: 'bananas'
            },
            banana_collector: {
                name: 'Banana Collector',
                description: 'Collect 50 bananas total',
                reward: 15,
                requirement: { type: 'total_bananas', value: 50 },
                category: 'bananas'
            },
            banana_hoarder: {
                name: 'Banana Hoarder',
                description: 'Collect 100 bananas total',
                reward: 25,
                requirement: { type: 'total_bananas', value: 100 },
                category: 'bananas'
            },
            banana_baron: {
                name: 'Banana Baron',
                description: 'Collect 500 bananas total',
                reward: 75,
                requirement: { type: 'total_bananas', value: 500 },
                category: 'bananas'
            },
            banana_billionaire: {
                name: 'Banana Billionaire',
                description: 'Collect 1000 bananas total!',
                reward: 150,
                requirement: { type: 'total_bananas', value: 1000 },
                category: 'bananas'
            },

            // =====================================
            // POWER-UP ACHIEVEMENTS (Jetpack)
            // =====================================
            first_flight: {
                name: 'First Flight',
                description: 'Use a jetpack for the first time!',
                reward: 10,
                requirement: { type: 'jetpacks_collected', value: 1 },
                category: 'powerups'
            },
            sky_high: {
                name: 'Sky High',
                description: 'Use 10 jetpacks total',
                reward: 25,
                requirement: { type: 'jetpacks_collected', value: 10 },
                category: 'powerups'
            },
            rocket_man: {
                name: 'Rocket Man',
                description: 'Use 25 jetpacks total',
                reward: 50,
                requirement: { type: 'jetpacks_collected', value: 25 },
                category: 'powerups'
            },

            // =====================================
            // POWER-UP ACHIEVEMENTS (T-Rex)
            // =====================================
            first_stomp: {
                name: 'First Stomp',
                description: 'Use a Dino Stomp for the first time!',
                reward: 10,
                requirement: { type: 'dino_stomps_collected', value: 1 },
                category: 'powerups'
            },
            dino_power: {
                name: 'Dino Power',
                description: 'Use 10 Dino Stomps total',
                reward: 25,
                requirement: { type: 'dino_stomps_collected', value: 10 },
                category: 'powerups'
            },
            trex_king: {
                name: 'T-Rex King',
                description: 'Use 25 Dino Stomps total!',
                reward: 50,
                requirement: { type: 'dino_stomps_collected', value: 25 },
                category: 'powerups'
            },

            // =====================================
            // POWER-UP ACHIEVEMENTS (Bubble Shield)
            // =====================================
            bubble_first: {
                name: 'Protected',
                description: 'Collect your first Bubble Shield',
                reward: 10,
                requirement: { type: 'bubbles_collected', value: 1 },
                category: 'powerups'
            },
            bubble_collector: {
                name: 'Bubble Master',
                description: 'Collect 10 Bubble Shields (total)',
                reward: 25,
                requirement: { type: 'bubbles_collected', value: 10 },
                category: 'powerups'
            },
            bubble_savior: {
                name: 'Life Saver',
                description: 'Have bubbles absorb 5 hits (total)',
                reward: 50,
                requirement: { type: 'bubble_hits_absorbed', value: 5 },
                category: 'powerups'
            },

            // =====================================
            // POWER-UP ACHIEVEMENTS (Pogo Stick)
            // =====================================
            pogo_first: {
                name: 'Bouncy!',
                description: 'Collect your first Pogo Stick',
                reward: 10,
                requirement: { type: 'pogos_collected', value: 1 },
                category: 'powerups'
            },
            pogo_collector: {
                name: 'Spring Loaded',
                description: 'Collect 10 Pogo Sticks (total)',
                reward: 25,
                requirement: { type: 'pogos_collected', value: 10 },
                category: 'powerups'
            },
            pogo_master: {
                name: 'Pogo Pro',
                description: 'Collect 25 Pogo Sticks (total)',
                reward: 50,
                requirement: { type: 'pogos_collected', value: 25 },
                category: 'powerups'
            },

            // =====================================
            // POWER-UP ACHIEVEMENTS (Lion Roar)
            // =====================================
            lion_first: {
                name: 'King of Jungle',
                description: 'Use Lion Roar for the first time',
                reward: 15,
                requirement: { type: 'lions_collected', value: 1 },
                category: 'powerups'
            },
            lion_collector: {
                name: 'Mighty Roar',
                description: 'Use Lion Roar 10 times',
                reward: 35,
                requirement: { type: 'lions_collected', value: 10 },
                category: 'powerups'
            },

            // =====================================
            // POWER-UP ACHIEVEMENTS (Turtle)
            // =====================================
            turtle_first: {
                name: 'Slow Down',
                description: 'Collect your first Turtle',
                reward: 10,
                requirement: { type: 'turtles_collected', value: 1 },
                category: 'powerups'
            },
            turtle_collector: {
                name: 'Slow and Steady',
                description: 'Collect 10 Turtles',
                reward: 25,
                requirement: { type: 'turtles_collected', value: 10 },
                category: 'powerups'
            },
            turtle_master: {
                name: 'Time Bender',
                description: 'Collect 25 Turtles',
                reward: 50,
                requirement: { type: 'turtles_collected', value: 25 },
                category: 'powerups'
            },

            // =====================================
            // POWER-UP ACHIEVEMENTS (Star)
            // =====================================
            star_first: {
                name: 'Superstar',
                description: 'Collect your first Star',
                reward: 10,
                requirement: { type: 'stars_collected', value: 1 },
                category: 'powerups'
            },
            star_collector: {
                name: 'Star Power',
                description: 'Collect 10 Stars',
                reward: 25,
                requirement: { type: 'stars_collected', value: 10 },
                category: 'powerups'
            },
            star_master: {
                name: 'Invincible',
                description: 'Collect 25 Stars',
                reward: 50,
                requirement: { type: 'stars_collected', value: 25 },
                category: 'powerups'
            },

            // =====================================
            // LEVEL ACHIEVEMENTS
            // =====================================
            level_one: {
                name: 'Level One',
                description: 'Reach Level 1 (score 1000)',
                reward: 10,
                requirement: { type: 'highest_level_reached', value: 1 },
                category: 'levels'
            },
            level_five: {
                name: 'Level Five',
                description: 'Reach Level 5 (score 5000)',
                reward: 35,
                requirement: { type: 'highest_level_reached', value: 5 },
                category: 'levels'
            },
            level_ten: {
                name: 'Level Ten',
                description: 'Reach Level 10 (score 10000)!',
                reward: 75,
                requirement: { type: 'highest_level_reached', value: 10 },
                category: 'levels'
            },
            level_master: {
                name: 'Level Master',
                description: 'Reach Level 25 (score 25000)!',
                reward: 200,
                requirement: { type: 'highest_level_reached', value: 25 },
                category: 'levels'
            },

            // =====================================
            // LAND/BIOME EXPLORATION
            // =====================================
            snow_explorer: {
                name: 'Snow Explorer',
                description: 'Play a game in Snow Land',
                reward: 5,
                requirement: { type: 'snow_games_played', value: 1 },
                category: 'lands'
            },
            desert_explorer: {
                name: 'Desert Explorer',
                description: 'Play a game in Desert Land',
                reward: 5,
                requirement: { type: 'desert_games_played', value: 1 },
                category: 'lands'
            },
            jungle_explorer: {
                name: 'Jungle Explorer',
                description: 'Play a game in Jungle Land',
                reward: 5,
                requirement: { type: 'jungle_games_played', value: 1 },
                category: 'lands'
            },
            ocean_explorer: {
                name: 'Ocean Explorer',
                description: 'Play a game in Ocean Land',
                reward: 5,
                requirement: { type: 'ocean_games_played', value: 1 },
                category: 'lands'
            },
            world_traveler: {
                name: 'World Traveler',
                description: 'Play on all 4 different lands!',
                reward: 25,
                requirement: { type: 'all_lands_played', value: true },
                category: 'lands'
            },
            snow_master: {
                name: 'Snow Master',
                description: 'Play 10 games in Snow Land',
                reward: 20,
                requirement: { type: 'snow_games_played', value: 10 },
                category: 'lands'
            },
            desert_master: {
                name: 'Desert Master',
                description: 'Play 10 games in Desert Land',
                reward: 20,
                requirement: { type: 'desert_games_played', value: 10 },
                category: 'lands'
            },
            jungle_master: {
                name: 'Jungle Master',
                description: 'Play 10 games in Jungle Land',
                reward: 20,
                requirement: { type: 'jungle_games_played', value: 10 },
                category: 'lands'
            },
            ocean_master: {
                name: 'Ocean Master',
                description: 'Play 10 games in Ocean Land',
                reward: 20,
                requirement: { type: 'ocean_games_played', value: 10 },
                category: 'lands'
            },

            // =====================================
            // TIME PLAYED
            // =====================================
            warming_up: {
                name: 'Warming Up',
                description: 'Play for 5 minutes total',
                reward: 10,
                requirement: { type: 'total_time_played', value: 300 },
                category: 'time'
            },
            getting_comfortable: {
                name: 'Getting Comfortable',
                description: 'Play for 15 minutes total',
                reward: 25,
                requirement: { type: 'total_time_played', value: 900 },
                category: 'time'
            },
            time_flies: {
                name: 'Time Flies',
                description: 'Play for 30 minutes total',
                reward: 50,
                requirement: { type: 'total_time_played', value: 1800 },
                category: 'time'
            },
            dedicated_player: {
                name: 'Dedicated Player',
                description: 'Play for 1 hour total!',
                reward: 100,
                requirement: { type: 'total_time_played', value: 3600 },
                category: 'time'
            },
            hardcore_gamer: {
                name: 'Hardcore Gamer',
                description: 'Play for 2 hours total!',
                reward: 200,
                requirement: { type: 'total_time_played', value: 7200 },
                category: 'time'
            },

            // =====================================
            // LEADERBOARD
            // =====================================
            top_banana: {
                name: 'Top Banana',
                description: 'Reach #1 on the leaderboard!',
                reward: 100,
                requirement: { type: 'times_reached_rank_one', value: 1 },
                category: 'leaderboard'
            },

            // =====================================
            // SHOP/PURCHASES
            // =====================================
            first_purchase: {
                name: 'First Purchase',
                description: 'Buy your first item from the shop!',
                reward: 10,
                requirement: { type: 'total_purchases', value: 1 },
                category: 'shop'
            },
            collector: {
                name: 'Collector',
                description: 'Buy 5 items from the shop',
                reward: 25,
                requirement: { type: 'total_purchases', value: 5 },
                category: 'shop'
            },
            shopaholic: {
                name: 'Shopaholic',
                description: 'Buy 10 items from the shop!',
                reward: 75,
                requirement: { type: 'total_purchases', value: 10 },
                category: 'shop'
            },

            // =====================================
            // MULTIPLAYER
            // =====================================
            social_butterfly: {
                name: 'Social Butterfly',
                description: 'Play your first multiplayer game!',
                reward: 15,
                requirement: { type: 'multiplayer_games', value: 1 },
                category: 'multiplayer'
            },
            first_win: {
                name: 'Victory!',
                description: 'Win your first multiplayer game!',
                reward: 25,
                requirement: { type: 'multiplayer_wins', value: 1 },
                category: 'multiplayer'
            },
            champion: {
                name: 'Champion',
                description: 'Win 10 multiplayer games!',
                reward: 100,
                requirement: { type: 'multiplayer_wins', value: 10 },
                category: 'multiplayer'
            }
        };

        // Achievement categories for organizing the achievements page
        const ACHIEVEMENT_CATEGORIES = {
            games: { name: 'Games Played', order: 1 },
            score: { name: 'Score', order: 2 },
            bananas: { name: 'Bananas', order: 3 },
            levels: { name: 'Levels', order: 4 },
            powerups: { name: 'Power-Ups', order: 5 },
            lands: { name: 'Lands', order: 6 },
            time: { name: 'Time Played', order: 7 },
            leaderboard: { name: 'Leaderboard', order: 8 },
            shop: { name: 'Shop', order: 9 },
            multiplayer: { name: 'Multiplayer', order: 10 }
        };

        let unlockedSkins = ['default'];
        let unlockedAchievements = [];
        let selectedSkin = 'default';
        let spendableBananas = 0;  // Currency for shop purchases
        let landsPlayed = new Set();

        // ============================================
        // SESSION STATS TRACKING
        // ============================================
        // These track stats for the current game session
        let sessionJetpacksCollected = 0;
        let sessionDinoStompsCollected = 0;
        let sessionGameDuration = 0; // in seconds

        // ============================================
        // LIFETIME PLAYER STATS (synced with database)
        // ============================================
        // These aggregate stats are loaded from and saved to the database
        let playerStats = {
            // Core stats
            total_games: 0,
            high_score: 0,
            total_score: 0,
            total_bananas: 0,
            spendable_bananas: 0,
            total_time_played: 0, // in seconds

            // Power-up stats
            jetpacks_collected: 0,
            dino_stomps_collected: 0,

            // Land-specific stats
            snow_games_played: 0,
            desert_games_played: 0,
            jungle_games_played: 0,
            ocean_games_played: 0,
            snow_best_score: 0,
            desert_best_score: 0,
            jungle_best_score: 0,
            ocean_best_score: 0,

            // Milestones
            first_game_at: null,
            last_game_at: null,
            highest_level_reached: 0,
            times_reached_rank_one: 0,

            // Purchase stats
            total_purchases: 0,
            total_spent: 0,

            // Multiplayer stats (for achievements)
            multiplayer_games: 0,
            multiplayer_wins: 0
        };

        // Shop scroll state
        let shopScrollY = 0;          // Current scroll offset
        let shopScrollMax = 0;        // Maximum scroll value (content - viewport)
        let shopScrollVel = 0;        // Momentum velocity
        let shopDragging = false;     // Is user currently dragging
        let shopDragStartY = 0;       // Y position where drag started
        let shopLastY = 0;            // Last Y for velocity calculation
        let shopLastTime = 0;         // Last time for velocity calculation
        let shopDragDistance = 0;     // Total distance moved (for tap vs scroll detection)

        // Achievements scroll state
        let achievementsScrollY = 0;
        let achievementsScrollMax = 0;
        let achievementsScrollVel = 0;
        let achievementsDragging = false;
        let achievementsDragStartY = 0;
        let achievementsLastY = 0;
        let achievementsLastTime = 0;
        let achievementsDragDistance = 0;

        // Achievement check state
        let isCheckingAchievements = false;
        let lastAchievementCheckResult = null; // { checked, unlocked, newRewards }

        // Jump buffering - stores timestamp of last jump attempt
        // JUMP_BUFFER_MS imported from config.js
        let jumpBufferTime = 0;

        // Variable jump height - track if jump button is held
        let jumpHeld = false;
        const JUMP_RELEASE_MULTIPLIER = 0.4;  // Velocity multiplier when releasing early
        const FALL_GRAVITY_MULTIPLIER = 1.5;  // Extra gravity when falling or released

        // Dynamic jump velocity based on screen height
        // Ensures player doesn't bonk head on ceiling in landscape mobile
        const BASE_JUMP_VELOCITY = -18;
        const MIN_CEILING_MARGIN = 30;  // Minimum space from top of screen

        function getJumpVelocity() {
            // Calculate available jump space (from ground to ceiling margin)
            const groundLevel = getGroundLevel();
            const availableHeight = groundLevel - MIN_CEILING_MARGIN - PLAYER_HEIGHT;

            // For a standard 600px height, available is about 500px
            // Scale jump velocity if screen is shorter
            const standardHeight = 500;
            const heightRatio = Math.min(1, availableHeight / standardHeight);

            // Scale velocity (sqrt for more natural feel - half height = ~70% velocity)
            let velocity = BASE_JUMP_VELOCITY * Math.sqrt(heightRatio);

            // POGO STICK BOOST: 15% more jump height when active
            if (pogoStickCount > 0) {
                velocity *= 1.15;
            }

            return velocity;
        }

        // Land selection buttons (will be calculated in draw)
        let landButtons = [];
        // Menu action buttons (Solo, Multiplayer, Leaderboard, Login)
        let menuButtons = [];

        // Player (declared early to avoid temporal dead zone, assigned here)
        player = {
            x: 100,
            y: getGroundLevel() - PLAYER_HEIGHT,
            vy: 0,
            jumping: false,
            get groundY() { return getGroundLevel() - PLAYER_HEIGHT; },
            scale: PLAYER_SCALE
        };

        // Check if a point is inside a button
        function pointInButton(x, y, btn) {
            return x >= btn.x && x <= btn.x + btn.w && y >= btn.y && y <= btn.y + btn.h;
        }

        // Handle click/tap for land selection and menu buttons
        function handleClick(clientX, clientY) {
            const rect = canvas.getBoundingClientRect();
            const x = (clientX - rect.left) * (canvas.width / rect.width);
            const y = (clientY - rect.top) * (canvas.height / rect.height);

            // Check back button first (top right)
            if (backButton && pointInButton(x, y, backButton)) {
                backButton.action();
                backButton = null; // Clear after use
                return true;
            }

            // Check design system clickable areas first
            for (const area of clickableAreas) {
                if (pointInBounds(x, y, area)) {
                    handleMenuAction(area.action);
                    return true;
                }
            }

            // Check legacy menu action buttons
            for (const btn of menuButtons) {
                if (pointInButton(x, y, btn)) {
                    handleMenuAction(btn.action);
                    return true;
                }
            }

            // Check land buttons
            for (const btn of landButtons) {
                if (pointInButton(x, y, btn)) {
                    selectedLand = btn.land;
                    if (gameState === 'gameover') {
                        startGame();
                    }
                    return true;
                }
            }
            return false;
        }

        // Handle menu button actions
        function handleMenuAction(action) {
            switch (action) {
                case 'solo':
                    gameMode = 'solo';
                    startGame();
                    break;
                case 'multiplayer':
                    if (!currentUser) {
                        showAuthModal();
                    } else {
                        gameState = 'multiplayer-menu';
                    }
                    break;
                case 'create_lobby':
                    createNewLobby();
                    break;
                case 'show_join':
                    lobbyCodeInput = '';
                    lobbyJoinError = '';
                    gameState = 'join-lobby';
                    break;
                case 'join_with_code':
                    joinLobbyWithCode();
                    break;
                case 'start_game':
                    hostStartGame();
                    break;
                case 'leaderboard':
                    showLeaderboard();
                    break;
                case 'shop':
                    gameState = 'shop';
                    shopScrollY = 0;  // Reset scroll when entering shop
                    shopScrollVel = 0;
                    break;
                case 'achievements':
                    gameState = 'achievements';
                    achievementsScrollY = 0;  // Reset scroll when entering achievements
                    achievementsScrollVel = 0;
                    lastAchievementCheckResult = null; // Clear previous check result
                    break;
                case 'check_achievements':
                    if (!isCheckingAchievements && currentUser) {
                        isCheckingAchievements = true;
                        lastAchievementCheckResult = null;
                        checkAllAchievementsRetroactive().then(result => {
                            lastAchievementCheckResult = result;
                            isCheckingAchievements = false;
                        }).catch(err => {
                            console.error('Error checking achievements:', err);
                            isCheckingAchievements = false;
                        });
                    }
                    break;
                case 'login':
                    showAuthModal();
                    break;
                case 'back':
                    if (gameState === 'join-lobby' || gameState === 'multiplayer-menu' || gameState === 'shop' || gameState === 'achievements' || gameState === 'leaderboard') {
                        gameState = 'menu';
                    } else {
                        gameState = 'menu';
                    }
                    break;
                case 'back_to_mp_menu':
                    gameState = 'multiplayer-menu';
                    break;
                case 'leave_lobby':
                    leaveLobby();
                    break;
                case 'play_again':
                    hostPlayAgain();
                    break;
                case 'leave_results':
                    leaveMultiplayerResults();
                    break;
                case 'focus_code_input':
                    // Focus the hidden input to trigger native keyboard
                    const hiddenInput = document.getElementById('lobbyCodeInput');
                    if (hiddenInput) {
                        hiddenInput.value = lobbyCodeInput;
                        hiddenInput.focus();
                        hiddenInput.select();
                    }
                    break;
                default:
                    // Handle shop skin actions
                    if (action.startsWith('equip_')) {
                        const skinId = action.replace('equip_', '');
                        equipSkin(skinId);
                    } else if (action.startsWith('buy_')) {
                        const skinId = action.replace('buy_', '');
                        purchaseSkin(skinId);
                    }
                    // Handle virtual keyboard keys for lobby code input
                    else if (action.startsWith('key_')) {
                        const key = action.substring(4);
                        if (key === 'backspace') {
                            lobbyCodeInput = lobbyCodeInput.slice(0, -1);
                            lobbyJoinError = '';
                        } else if (lobbyCodeInput.length < 6) {
                            lobbyCodeInput += key.toUpperCase();
                            lobbyJoinError = '';
                        }
                    }
                    break;
            }
        }

        // Show leaderboard
        async function showLeaderboard() {
            gameState = 'leaderboard';
            loadingLeaderboard = true;
            leaderboardData = await getLeaderboard(null, 10);
            loadingLeaderboard = false;
        }

        // Input handling
        function jump() {
            if (gameState === 'playing') {
                // Ghosts can't jump in multiplayer
                if (gameMode === 'multiplayer' && !localPlayerAlive) {
                    return;
                }

                // If jetpack is active, exit jetpack and jump out (like T-Rex)
                if (jetpackActive) {
                    // Exit jetpack and jump out
                    jetpackActive = false;
                    jetpackTimer = 0;
                    player.vy = getJumpVelocity();
                    player.jumping = true;
                    jumpHeld = true;
                    jumpBufferTime = 0;
                    return;
                }

                // If T-Rex is active, exit T-Rex mode and jump
                if (trexActive) {
                    // Exit T-Rex and jump out
                    trexActive = false;
                    trexTimer = 0;
                    player.vy = getJumpVelocity();
                    player.jumping = true;
                    jumpHeld = true;
                    jumpBufferTime = 0;
                    return;
                }

                // Normal jump when not using power-ups
                if (!jetpackActive && !trexActive && !player.jumping) {
                    // On ground - jump immediately with screen-scaled velocity
                    player.vy = getJumpVelocity();
                    player.jumping = true;
                    jumpHeld = true;
                    jumpBufferTime = 0;
                } else if (!jetpackActive && !trexActive) {
                    // In air - buffer the jump request
                    jumpBufferTime = Date.now();
                }
            }
        }

        // Release jump - called when button/touch is released
        function releaseJump() {
            if (jumpHeld && player.jumping && player.vy < 0) {
                // Still rising - cut the velocity for a short hop
                player.vy *= JUMP_RELEASE_MULTIPLIER;
            }
            jumpHeld = false;
        }

        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space') {
                e.preventDefault();
                if (gameState === 'playing') {
                    jump();
                } else if (gameState === 'gameover') {
                    startGame();
                } else if (gameState === 'leaderboard' || gameState === 'shop') {
                    gameState = 'menu';
                }
            }
            if (e.code === 'Escape') {
                if (gameState === 'leaderboard' || gameState === 'shop' || gameState === 'achievements') {
                    gameState = 'menu';
                }
            }
        });

        // Release jump on keyup for variable jump height
        document.addEventListener('keyup', (e) => {
            if (e.code === 'Space') {
                releaseJump();
            }
        });

        // Menu states where clicks are handled as buttons
        const MENU_STATES = ['welcome', 'menu', 'gameover', 'leaderboard', 'lobby', 'multiplayer-menu', 'join-lobby', 'multiplayer-results', 'shop', 'achievements'];

        function isMenuState() {
            return MENU_STATES.includes(gameState);
        }

        // Touch support for mobile
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const touch = e.touches[0];

            // Shop/Achievements scroll handling
            if (gameState === 'shop') {
                const rect = canvas.getBoundingClientRect();
                const y = (touch.clientY - rect.top) * (canvas.height / rect.height);
                shopDragging = true;
                shopDragStartY = y;
                shopLastY = y;
                shopLastTime = Date.now();
                shopScrollVel = 0;
                shopDragDistance = 0;
                return;
            }
            if (gameState === 'achievements') {
                const rect = canvas.getBoundingClientRect();
                const y = (touch.clientY - rect.top) * (canvas.height / rect.height);
                achievementsDragging = true;
                achievementsDragStartY = y;
                achievementsLastY = y;
                achievementsLastTime = Date.now();
                achievementsScrollVel = 0;
                achievementsDragDistance = 0;
                return;
            }

            if (isMenuState()) {
                handleClick(touch.clientX, touch.clientY);
            } else {
                jump();
            }
        });

        // Touch move for shop/achievements scrolling
        canvas.addEventListener('touchmove', (e) => {
            if (gameState === 'shop' && shopDragging) {
                e.preventDefault();
                const touch = e.touches[0];
                const rect = canvas.getBoundingClientRect();
                const y = (touch.clientY - rect.top) * (canvas.height / rect.height);

                const delta = shopLastY - y;
                shopScrollY = Math.max(0, Math.min(shopScrollMax, shopScrollY + delta));
                shopDragDistance += Math.abs(delta);

                const now = Date.now();
                const dt = now - shopLastTime;
                if (dt > 0) {
                    shopScrollVel = delta / dt * 16;
                }
                shopLastY = y;
                shopLastTime = now;
            }
            if (gameState === 'achievements' && achievementsDragging) {
                e.preventDefault();
                const touch = e.touches[0];
                const rect = canvas.getBoundingClientRect();
                const y = (touch.clientY - rect.top) * (canvas.height / rect.height);

                const delta = achievementsLastY - y;
                achievementsScrollY = Math.max(0, Math.min(achievementsScrollMax, achievementsScrollY + delta));
                achievementsDragDistance += Math.abs(delta);

                const now = Date.now();
                const dt = now - achievementsLastTime;
                if (dt > 0) {
                    achievementsScrollVel = delta / dt * 16;
                }
                achievementsLastY = y;
                achievementsLastTime = now;
            }
        }, { passive: false });

        // Release jump on touch end for variable jump height
        canvas.addEventListener('touchend', (e) => {
            e.preventDefault();

            // Shop: end drag, check for tap (click)
            if (gameState === 'shop') {
                const wasDragging = shopDragging;
                shopDragging = false;

                if (wasDragging && shopDragDistance < 10 && e.changedTouches.length > 0) {
                    const touch = e.changedTouches[0];
                    handleClick(touch.clientX, touch.clientY);
                }
                return;
            }

            // Achievements: end drag, check for tap (click)
            if (gameState === 'achievements') {
                const wasDragging = achievementsDragging;
                achievementsDragging = false;

                if (wasDragging && achievementsDragDistance < 10 && e.changedTouches.length > 0) {
                    const touch = e.changedTouches[0];
                    handleClick(touch.clientX, touch.clientY);
                }
                return;
            }

            releaseJump();
        });

        canvas.addEventListener('click', (e) => {
            if (isMenuState()) {
                if (!handleClick(e.clientX, e.clientY)) {
                    if (gameState === 'gameover') {
                        startGame();
                    }
                }
            } else {
                jump();
            }
        });

        // Mouse up for variable jump height (when using click instead of touch)
        canvas.addEventListener('mouseup', (e) => {
            releaseJump();
        });

        // Mouse wheel for shop/achievements scrolling
        canvas.addEventListener('wheel', (e) => {
            if (gameState === 'shop') {
                e.preventDefault();
                shopScrollY = Math.max(0, Math.min(shopScrollMax, shopScrollY + e.deltaY * 0.5));
            }
            if (gameState === 'achievements') {
                e.preventDefault();
                achievementsScrollY = Math.max(0, Math.min(achievementsScrollMax, achievementsScrollY + e.deltaY * 0.5));
            }
        }, { passive: false });

        // Hidden input for native keyboard support on join-lobby screen
        const hiddenCodeInput = document.getElementById('lobbyCodeInput');
        if (hiddenCodeInput) {
            hiddenCodeInput.addEventListener('input', (e) => {
                // Filter to only letters and uppercase
                const filtered = e.target.value.replace(/[^A-Za-z]/g, '').toUpperCase().slice(0, 6);
                lobbyCodeInput = filtered;
                e.target.value = filtered;
                lobbyJoinError = '';
            });

            hiddenCodeInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' && lobbyCodeInput.length === 6) {
                    joinLobbyWithCode();
                }
            });
        }

        // Global keyboard support for typing lobby codes
        document.addEventListener('keydown', (e) => {
            if (gameState === 'join-lobby') {
                const key = e.key.toUpperCase();
                if (key === 'BACKSPACE') {
                    lobbyCodeInput = lobbyCodeInput.slice(0, -1);
                    lobbyJoinError = '';
                    e.preventDefault();
                } else if (key === 'ENTER' && lobbyCodeInput.length === 6) {
                    joinLobbyWithCode();
                    e.preventDefault();
                } else if (/^[A-Z]$/.test(key) && lobbyCodeInput.length < 6) {
                    lobbyCodeInput += key;
                    lobbyJoinError = '';
                    e.preventDefault();
                }
            }
        });

        // Spawn entity - uses seeded random for multiplayer synchronization
        // Progressive difficulty based on score thresholds:
        // 0-1999: Single obstacles only, single banana
        // 2000-2999: Single or double obstacles, single banana
        // 3000-3999: 1-3 obstacles, single banana
        // 4000-4999: Animals appear (50% chance), single banana
        // 5000+: Banana bundles (50% chance, worth 300), animals continue
        // Power-ups: Jetpack appears rarely (~once per 3000 point run)
        function spawn() {
            const land = lands[selectedLand];
            jetpackSpawnCounter++;

            // Check for power-up spawn (rare - rewards skill/survival)
            // Starts having a chance after 15 spawns, increases slowly
            // Level bonus: +1% chance per level (rewards surviving longer)
            const currentLevel = getCurrentLevel(score);
            const levelBonus = currentLevel * 0.01; // +1% per level
            const baseChance = Math.max(0, (jetpackSpawnCounter - 15) * 0.02); // 0% at 15, 20% at 25, 40% at 35
            const powerUpChance = Math.min(0.5, baseChance + levelBonus); // Cap at 50%
            const shouldSpawnPowerUp = getRandom() < powerUpChance;

            if (shouldSpawnPowerUp) {
                // TWO-POOL SYSTEM:
                // Pool A (35%): Permanent Buffs - Bubble, Pogo, Lion
                // Pool B (65%): Time-Based Buffs - Jetpack, Dino, Turtle, Star
                const poolRoll = getRandom();
                let powerUpType = null;
                let powerUpSprite = null;
                let powerUpColors = null;

                if (poolRoll < 0.35) {
                    // POOL A: Permanent Buffs (Bubble 30%, Pogo 30%, Lion 20%, BodyDouble 20%)
                    // Only spawn if not already active (no stacking)
                    const poolARoll = getRandom();
                    if (poolARoll < 0.30 && bubbleShieldCount === 0) {
                        powerUpType = 'bubble';
                        powerUpSprite = sprites.bubblePowerUp;
                        powerUpColors = colors.bubblePowerUp;
                    } else if (poolARoll < 0.60 && pogoStickCount === 0) {
                        powerUpType = 'pogo';
                        powerUpSprite = sprites.pogoPowerUp;
                        powerUpColors = colors.pogoPowerUp;
                    } else if (poolARoll < 0.80 && !lionRoarUsed) {
                        // Lion only spawns if not used this run
                        powerUpType = 'lion';
                        powerUpSprite = sprites.lionPowerUp;
                        powerUpColors = colors.lionPowerUp;
                    } else if (!bodyDoubleActive) {
                        // Body Double only spawns if not already active
                        powerUpType = 'bodyDouble';
                        powerUpSprite = sprites.bodyDoublePowerUp;
                        powerUpColors = colors.bodyDoublePowerUp;
                    }
                    // If all Pool A options unavailable, skip spawn
                } else {
                    // POOL B: Time-Based Buffs (Jetpack 20%, Dino 20%, Turtle 15%, Star 15%, Money 15%, Laser 15%)
                    // First determine intended type, then check if it can spawn
                    const poolBRoll = getRandom();
                    let intendedType = null;

                    if (poolBRoll < 0.20) {
                        intendedType = 'jetpack';
                    } else if (poolBRoll < 0.40) {
                        intendedType = 'trex';
                    } else if (poolBRoll < 0.55) {
                        intendedType = 'turtle';
                    } else if (poolBRoll < 0.70) {
                        intendedType = 'star';
                    } else if (poolBRoll < 0.85) {
                        intendedType = 'money';
                    } else {
                        intendedType = 'laser';
                    }

                    // Check if intended type can spawn (not already active)
                    if (intendedType === 'jetpack' && !jetpackActive) {
                        powerUpType = 'jetpack';
                        powerUpSprite = sprites.jetpack;
                        powerUpColors = colors.jetpack;
                    } else if (intendedType === 'trex' && !trexActive) {
                        powerUpType = 'trex';
                        powerUpSprite = sprites.trexPowerUp;
                        powerUpColors = colors.trexPowerUp;
                    } else if (intendedType === 'turtle' && !turtleActive) {
                        powerUpType = 'turtle';
                        powerUpSprite = sprites.turtlePowerUp;
                        powerUpColors = colors.turtlePowerUp;
                    } else if (intendedType === 'star' && !starActive) {
                        powerUpType = 'star';
                        powerUpSprite = sprites.starPowerUp;
                        powerUpColors = colors.starPowerUp;
                    } else if (intendedType === 'money' && !moneyActive) {
                        powerUpType = 'money';
                        powerUpSprite = sprites.moneyPowerUp;
                        powerUpColors = colors.moneyPowerUp;
                    } else if (intendedType === 'laser' && !laserActive) {
                        powerUpType = 'laser';
                        powerUpSprite = sprites.laserPowerUp;
                        powerUpColors = colors.laserPowerUp;
                    }
                    // If intended type is active, don't spawn anything from Pool B
                    // (power-up spawn opportunity is simply skipped)
                }

                if (powerUpType && powerUpSprite && powerUpColors && powerUpSprite.length > 0 && powerUpSprite[0]) {
                    const scale = ENTITY_SCALE;
                    const h = powerUpSprite.length * scale;
                    entities.push({
                        x: canvas.width + 20,
                        y: getGroundLevel() - h - BANANA_HEIGHT_OFFSET - 20, // Float a bit higher
                        pixels: powerUpSprite,
                        scale: scale,
                        colors: powerUpColors,
                        type: 'powerup',
                        powerupType: powerUpType,
                        vx: 0
                    });
                    jetpackSpawnCounter = 0; // Reset counter after spawning
                    return; // Don't spawn anything else this cycle
                }
            }

            const isBanana = getRandom() < 0.35;

            if (isBanana) {
                // At 5000+, 50% chance of banana bundle (worth 300)
                const useBundle = score >= 5000 && getRandom() < 0.5;

                if (useBundle) {
                    // Spawn banana bundle (double value)
                    const pixels = sprites.bananaBundle;
                    const scale = ENTITY_SCALE;
                    const h = pixels.length * scale;
                    entities.push({
                        x: canvas.width + 20,
                        y: getGroundLevel() - h - BANANA_HEIGHT_OFFSET,
                        pixels: pixels,
                        scale: scale,
                        colors: colors.banana, // Same colors as single banana
                        type: 'banana',
                        isBundle: true,
                        bananaValue: 2, // Worth 2 bananas (300 points)
                        vx: 0
                    });
                } else {
                    // Spawn single banana
                    const pixels = sprites.banana;
                    const scale = ENTITY_SCALE;
                    const h = pixels.length * scale;
                    entities.push({
                        x: canvas.width + 20,
                        y: getGroundLevel() - h - BANANA_HEIGHT_OFFSET,
                        pixels: pixels,
                        scale: scale,
                        colors: colors.banana,
                        type: 'banana',
                        isBundle: false,
                        bananaValue: 1, // Worth 1 banana (150 points)
                        vx: 0
                    });
                }
            } else {
                // Obstacle spawning with progressive difficulty
                // Animals only appear after level 5 (5000+ points, 50% chance)
                // But don't allow if we've already had 2 consecutive "2-count" obstacles
                const wouldBeThirdConsecutive = lastObstacleCount === 2 && consecutiveSameCount >= 1;
                const useAnimal = score >= 5000 && getRandom() < 0.5 && land.animalObstacle && !wouldBeThirdConsecutive;

                if (useAnimal) {
                    // Animal obstacles are double-wide, spawn as single unit
                    // TURTLE TIME: Use turtle sprite if active, otherwise animal
                    const pixels = turtleActive ? sprites.turtleObstacle : land.animalObstacle;
                    const animalColors = turtleActive ? colors.turtleObstacle : land.animalObstacleColors;
                    // LION ROAR: Shrink obstacles to 80% if active (20% reduction)
                    const scale = obstaclesShrunk ? ENTITY_SCALE * 0.8 : ENTITY_SCALE;
                    const h = pixels.length * scale;
                    const currentSpawnId = spawnIdCounter++;

                    // Update consecutive tracking (animals count as 2)
                    if (lastObstacleCount === 2) {
                        consecutiveSameCount++;
                    } else {
                        consecutiveSameCount = 0;
                    }
                    lastObstacleCount = 2;

                    entities.push({
                        x: canvas.width + 20,
                        y: getGroundLevel() - h,
                        pixels: pixels,
                        scale: scale,
                        colors: animalColors,
                        type: 'obstacle',
                        isAnimal: true,
                        obstacleCount: 2, // Worth 2 obstacles for jump bonus
                        spawnId: currentSpawnId,
                        vx: 0
                    });
                } else {
                    // Determine max obstacles based on score (progressive difficulty)
                    // Level 1 (1000-1999): 1 max
                    // Level 2 (2000-2999): 2 max
                    // Level 3 (3000-3999): 3 max
                    // Level 4 (4000-4999): 4 max
                    // Level 5 (5000-5999): 5 max (5 has half chance)
                    // Level 6+ (6000+): 6 max (5 & 6 have half chance)
                    let maxObstacles;
                    if (score < 2000) {
                        maxObstacles = 1; // Only single obstacles
                    } else if (score < 3000) {
                        maxObstacles = 2; // Single or double
                    } else if (score < 4000) {
                        maxObstacles = 3; // Range 1-3
                    } else if (score < 5000) {
                        maxObstacles = 4; // Range 1-4
                    } else if (score < 6000) {
                        maxObstacles = 5; // Range 1-5 (5 has half chance)
                    } else {
                        maxObstacles = 6; // Range 1-6 (5 & 6 have half chance)
                    }

                    // Random obstacle count up to max
                    // For maxObstacles=5 or 6, use weighted random: lower counts have double weight
                    let obstacleCount;
                    if (maxObstacles === 6) {
                        // Weighted: 1,2,3,4 each have weight 2, 5 and 6 each have weight 1 (total 10)
                        const rand = getRandom() * 10;
                        if (rand < 2) obstacleCount = 1;
                        else if (rand < 4) obstacleCount = 2;
                        else if (rand < 6) obstacleCount = 3;
                        else if (rand < 8) obstacleCount = 4;
                        else if (rand < 9) obstacleCount = 5; // ~10% chance
                        else obstacleCount = 6; // ~10% chance
                    } else if (maxObstacles === 5) {
                        // Weighted: 1,2,3,4 each have weight 2, 5 has weight 1 (total 9)
                        const rand = getRandom() * 9;
                        if (rand < 2) obstacleCount = 1;
                        else if (rand < 4) obstacleCount = 2;
                        else if (rand < 6) obstacleCount = 3;
                        else if (rand < 8) obstacleCount = 4;
                        else obstacleCount = 5; // ~11% chance vs ~22% for others
                    } else {
                        obstacleCount = Math.floor(getRandom() * maxObstacles) + 1;
                    }

                    // Prevent 3+ consecutive spawns of same obstacle count
                    if (obstacleCount === lastObstacleCount && consecutiveSameCount >= 1 && maxObstacles > 1) {
                        // Force a different count - pick randomly from remaining options
                        const options = [];
                        for (let c = 1; c <= maxObstacles; c++) {
                            if (c !== lastObstacleCount) options.push(c);
                        }
                        if (options.length > 0) {
                            obstacleCount = options[Math.floor(getRandom() * options.length)];
                        }
                    }

                    // Update consecutive tracking
                    if (obstacleCount === lastObstacleCount) {
                        consecutiveSameCount++;
                    } else {
                        consecutiveSameCount = 0;
                    }
                    lastObstacleCount = obstacleCount;
                    // TURTLE TIME: Use turtle sprite if active, otherwise land obstacle
                    const pixels = turtleActive ? sprites.turtleObstacle : land.obstacle;
                    const obstacleColors = turtleActive ? colors.turtleObstacle : land.obstacleColors;
                    // LION ROAR: Shrink obstacles to 80% if active (20% reduction)
                    const scale = obstaclesShrunk ? ENTITY_SCALE * 0.8 : ENTITY_SCALE;
                    const w = pixels[0].length * scale;
                    const h = pixels.length * scale;
                    const gap = 4; // Small gap between obstacles
                    const currentSpawnId = spawnIdCounter++;

                    for (let i = 0; i < obstacleCount; i++) {
                        entities.push({
                            x: canvas.width + 20 + (i * (w + gap)),
                            y: getGroundLevel() - h,
                            pixels: pixels,
                            scale: scale,
                            colors: obstacleColors,
                            type: 'obstacle',
                            isAnimal: false,
                            obstacleCount: obstacleCount, // Track how many in this group
                            groupIndex: i, // Which one in the group
                            spawnId: currentSpawnId, // Same ID for all in group
                            vx: 0
                        });
                    }
                }
            }
        }

        // Next spawn threshold (calculated deterministically for multiplayer sync)
        let nextSpawnThreshold = 400;

        // Start/restart game
        function startGame() {
            gameState = 'playing';
            score = 0;
            bananasCollected = 0;
            gameTime = 0;
            speed = INITIAL_SPEED;
            spawnCounter = 0;
            scrollOffset = 0;
            entities = [];
            clearParticles(); // Clear any leftover particles
            clearFloatingTexts(); // Clear floating score texts
            obstaclesJumpedOver = new Set(); // Reset jump tracking
            spawnIdCounter = 0; // Reset spawn ID counter
            jumpBonusScore = 0; // Reset jump bonus
            lastObstacleCount = 0; // Reset consecutive obstacle tracking
            consecutiveSameCount = 0;
            // Reset jetpack state
            jetpackActive = false;
            jetpackTimer = 0;
            jetpackSpawnCounter = 0;
            powerUpBonusScore = 0;
            // Reset T-Rex state
            trexActive = false;
            trexTimer = 0;
            // Reset screen shake state
            screenShakeIntensity = 0;
            dinoShakeTimer = 0;
            // Reset dino footprint animation
            dinoFootprints = [];
            dinoFootTimer = 0;
            dinoFootLeft = true;
            // Reset lion emoji animation
            lionEmojiActive = false;
            lionEmojiTimer = 0;
            lionEmojiScale = 1;
            // Reset turtle emoji animation
            turtleEmojiActive = false;
            turtleEmojiTimer = 0;
            turtleEmojiScale = 1;
            // Reset body double state
            bodyDoubleActive = false;
            bodyDoubleY = 0;
            bodyDoubleVY = 0;
            bodyDoubleJumping = false;
            bodyDoubleInputBuffer = [];
            // Reset new power-up states (Permanent Buffs)
            bubbleShieldCount = 0;
            bubblePopInvincibility = 0;
            pogoStickCount = 0;
            lionRoarUsed = false;
            obstaclesShrunk = false;
            // Reset new power-up states (Time-Based Buffs)
            turtleActive = false;
            turtleTimer = 0;
            starActive = false;
            starTimer = 0;
            starColorIndex = 0;
            moneyActive = false;
            moneyTimer = 0;
            moneyBonusAccumulated = 0;
            laserActive = false;
            laserTimer = 0;
            laserAngle = 0;
            // Reset session stats
            sessionJetpacksCollected = 0;
            sessionDinoStompsCollected = 0;
            sessionBubblesCollected = 0;
            sessionPogosCollected = 0;
            sessionLionsCollected = 0;
            sessionTurtlesCollected = 0;
            sessionStarsCollected = 0;
            sessionBubbleHitsAbsorbed = 0;
            sessionMoneyCollected = 0;
            sessionLasersCollected = 0;
            sessionBodyDoublesCollected = 0;
            sessionGameDuration = 0;
            player.y = player.groundY;
            player.vy = 0;
            player.jumping = false;
            jumpBufferTime = 0;
            jumpHeld = false;
            scoreSaved = false;
            // Reset announcement state
            clearAnnouncement();
            highestLevelReached = 0; // Reset highest level for this game
            // Show "[LAND] STAGE" then "LEVEL ZERO" at game start
            const land = lands[selectedLand];
            if (land && land.name) {
                queueAnnouncements([
                    `${land.name.toUpperCase()} STAGE`,
                    'LEVEL ZERO'
                ]);
                lastAnnouncedLevel = 0; // Mark level 0 as announced
            }
            // Calculate first spawn threshold deterministically
            nextSpawnThreshold = 280 + getRandom() * 220;
        }

        // Update game logic
        function update(delta = 1) {
            if (gameState !== 'playing') return;

            // TURTLE SLOW-MO: Game runs at half speed, but timers run at normal speed
            const gameDelta = turtleActive ? delta * 0.5 : delta;

            gameTime += gameDelta; // Game time slowed by turtle
            speed += SPEED_INCREMENT * gameDelta; // Speed increase slowed by turtle
            spawnCounter += speed * gameDelta; // Spawn counter slowed by turtle

            // Update announcements
            updateAnnouncement();
            checkLevelAnnouncement();

            // Spawn logic (deterministic spacing for multiplayer sync)
            if (spawnCounter > nextSpawnThreshold) {
                spawn();
                spawnCounter = 0;
                // Calculate next threshold using seeded random
                nextSpawnThreshold = 280 + getRandom() * 220;
            }

            // Jetpack flight mechanics (overrides normal physics when active)
            // Hovers at banana-collection height the entire duration
            if (jetpackActive) {
                jetpackTimer -= delta; // Timer runs at normal speed (not affected by turtle)

                // Rise to target height if not there yet
                if (player.y > jetpackTargetY) {
                    player.y -= JETPACK_RISE_SPEED * gameDelta;
                    if (player.y < jetpackTargetY) {
                        player.y = jetpackTargetY;
                    }
                } else {
                    // Hold at target height (banana collection level)
                    player.y = jetpackTargetY;
                }

                // Spawn thrust particles
                if (Math.floor(gameTime) % 3 === 0) {
                    spawnJetpackParticles(player.x + PLAYER_WIDTH / 2, player.y + PLAYER_HEIGHT);
                }

                // Check if jetpack time is up
                if (jetpackTimer <= 0) {
                    // End jetpack - drop back to ground
                    jetpackActive = false;
                    player.jumping = true;
                    player.vy = 2; // Start falling
                }
            } else if (trexActive) {
                // T-Rex mechanics - stay on ground and STOMP through obstacles
                trexTimer -= delta; // Timer runs at normal speed (not affected by turtle)
                dinoShakeTimer += delta;

                // Periodic stomp screen shakes (every ~1.5s) - STRONGER shake
                if (dinoShakeTimer >= DINO_SHAKE_INTERVAL) {
                    dinoShakeTimer = 0;
                    // Fade intensity in final 2 seconds (120 frames)
                    const fadeMultiplier = trexTimer > 120 ? 1.0 : trexTimer / 120;
                    if (fadeMultiplier > 0.1) {
                        triggerScreenShake(12 * fadeMultiplier); // Stronger shake
                    }
                }

                // Keep player locked to ground
                player.y = player.groundY;
                player.vy = 0;
                player.jumping = false;

                // Spawn dust particles occasionally (stomp effect)
                if (Math.floor(gameTime) % 8 === 0) {
                    for (let i = 0; i < 2; i++) {
                        particles.push({
                            x: player.x + PLAYER_WIDTH / 2 + (Math.random() - 0.5) * 40,
                            y: player.groundY + PLAYER_HEIGHT - 5,
                            vx: (Math.random() - 0.5) * 3,
                            vy: -1 - Math.random() * 2,
                            life: 0,
                            color: ['#8D6E63', '#A1887F', '#BCAAA4'][Math.floor(Math.random() * 3)], // Brown dust
                            size: 4 + Math.random() * 4,
                            maxLife: 20
                        });
                    }
                }

                // Spawn alternating dino footprints above player's head
                dinoFootTimer += delta;
                if (dinoFootTimer >= DINO_FOOT_INTERVAL) {
                    dinoFootTimer = 0;
                    // Spawn footprint above player's head, offset left or right
                    const offsetX = dinoFootLeft ? -20 : 20;
                    dinoFootprints.push({
                        x: player.x + PLAYER_WIDTH / 2 + offsetX,
                        y: player.y - 60, // Above player's head
                        isLeft: dinoFootLeft,
                        timer: DINO_FOOT_DURATION
                    });
                    dinoFootLeft = !dinoFootLeft; // Alternate
                }

                // Update existing footprints (fade out)
                for (let i = dinoFootprints.length - 1; i >= 0; i--) {
                    dinoFootprints[i].timer -= delta;
                    if (dinoFootprints[i].timer <= 0) {
                        dinoFootprints.splice(i, 1);
                    }
                }

                // Check if T-Rex time is up
                if (trexTimer <= 0) {
                    // End T-Rex mode - transform back to normal
                    trexActive = false;
                    dinoShakeTimer = 0;
                    dinoFootprints = []; // Clear footprints
                    dinoFootTimer = 0;
                }
            }

            // Update Turtle timer (slow-mo effect - timer counts down at normal speed)
            if (turtleActive) {
                turtleTimer -= delta; // Timer runs at normal speed
                if (turtleTimer <= 0) {
                    turtleActive = false;
                }
            }

            // Update Star timer (invincibility)
            if (starActive) {
                starTimer -= delta;
                starColorIndex = (starColorIndex + 0.3) % RAINBOW_COLORS.length; // Cycle rainbow colors

                // Spawn star particles periodically (shooting out from player)
                if (Math.floor(gameTime) % 4 === 0) {
                    spawnStarParticle(player.x + PLAYER_WIDTH / 2, player.y + PLAYER_HEIGHT / 2);
                }

                if (starTimer <= 0) {
                    starActive = false;
                }
            }

            // Update Money timer (double points)
            if (moneyActive) {
                moneyTimer -= delta;
                if (moneyTimer <= 0) {
                    moneyActive = false;
                }
            }

            // Update Lion emoji animation (grows and fades)
            if (lionEmojiActive) {
                lionEmojiTimer -= delta;
                // Grow from 1x to 3x over duration
                lionEmojiScale = 1 + (1 - lionEmojiTimer / LION_EMOJI_DURATION) * 2;
                if (lionEmojiTimer <= 0) {
                    lionEmojiActive = false;
                }
            }

            // Update Turtle emoji animation (grows and fades)
            if (turtleEmojiActive) {
                turtleEmojiTimer -= delta;
                // Grow from 1x to 3x over duration
                turtleEmojiScale = 1 + (1 - turtleEmojiTimer / TURTLE_EMOJI_DURATION) * 2;
                if (turtleEmojiTimer <= 0) {
                    turtleEmojiActive = false;
                }
            }

            // Update Laser timer (disco ball destruction) and spin the laser angle
            if (laserActive) {
                laserTimer -= delta;
                laserAngle += 0.15; // Spin the laser beams
                if (laserTimer <= 0) {
                    laserActive = false;
                }
            }

            // Update bubble pop invincibility timer (protects against grouped obstacles)
            if (bubblePopInvincibility > 0) {
                bubblePopInvincibility -= delta;
            }

            if (!jetpackActive && !trexActive && player.jumping) {
                // Normal player physics with variable jump height
                // Base gravity
                let gravity = 0.8;

                // Apply extra gravity when:
                // - Falling (vy > 0), OR
                // - Rising but button released (for snappy short hops)
                if (player.vy > 0 || !jumpHeld) {
                    gravity *= FALL_GRAVITY_MULTIPLIER;
                }

                player.vy += gravity * gameDelta;
                player.y += player.vy * gameDelta;

                // Ceiling collision - prevent going above minimum margin
                if (player.y < MIN_CEILING_MARGIN) {
                    player.y = MIN_CEILING_MARGIN;
                    player.vy = 0;  // Stop upward momentum, start falling
                }

                // Ground collision
                if (player.y >= player.groundY) {
                    player.y = player.groundY;
                    player.jumping = false;
                    player.vy = 0;
                    jumpHeld = false;  // Reset held state on landing

                    // Check for buffered jump - if player pressed jump recently, jump again
                    if (jumpBufferTime > 0 && (Date.now() - jumpBufferTime) < JUMP_BUFFER_MS) {
                        player.vy = getJumpVelocity();
                        player.jumping = true;
                        jumpHeld = true;  // Assume held for buffered jump
                        jumpBufferTime = 0;
                    }
                }
            }

            // Update Body Double (follows player with delay)
            if (bodyDoubleActive) {
                // Push current player state to buffer
                bodyDoubleInputBuffer.push({
                    y: player.y,
                    vy: player.vy,
                    jumping: player.jumping
                });

                // Pop delayed state from buffer (FIFO)
                if (bodyDoubleInputBuffer.length > BODY_DOUBLE_DELAY_FRAMES) {
                    const delayedState = bodyDoubleInputBuffer.shift();
                    bodyDoubleY = delayedState.y;
                    bodyDoubleVY = delayedState.vy;
                    bodyDoubleJumping = delayedState.jumping;
                }
            }

            // Update entities
            for (let i = entities.length - 1; i >= 0; i--) {
                const ent = entities[i];

                // Safety check - remove any malformed entities
                if (!ent || !ent.pixels || !ent.pixels[0]) {
                    entities.splice(i, 1);
                    continue;
                }

                ent.x -= speed * gameDelta; // Use gameDelta for turtle slow-mo

                // LASER BEAM collision - destroy ALL entities (obstacles, bananas, powerups)
                // The laser is a "mass destruction" power-up - destroys everything the beams touch
                if (laserActive) {
                    const playerCenterX = player.x + PLAYER_WIDTH / 2;
                    const playerCenterY = player.y + PLAYER_HEIGHT / 2;
                    const entCenterX = ent.x + (ent.pixels[0].length * ent.scale) / 2;
                    const entCenterY = ent.y + (ent.pixels.length * ent.scale) / 2;
                    const beamLength = 300; // Extended range for better coverage
                    const beamCount = 8;

                    // Check if entity is within beam range
                    const distToEntity = Math.sqrt(Math.pow(entCenterX - playerCenterX, 2) + Math.pow(entCenterY - playerCenterY, 2));
                    if (distToEntity < beamLength) {
                        // Calculate angle to entity
                        const angleToEntity = Math.atan2(entCenterY - playerCenterY, entCenterX - playerCenterX);

                        // Check if any beam is pointing at the entity (within tolerance)
                        let laserDestroyed = false;
                        for (let b = 0; b < beamCount; b++) {
                            const beamAngle = laserAngle + (b * Math.PI * 2 / beamCount);
                            // Normalize angles for comparison
                            let angleDiff = Math.abs(((beamAngle % (Math.PI * 2)) + Math.PI * 2) % (Math.PI * 2) -
                                                     ((angleToEntity % (Math.PI * 2)) + Math.PI * 2) % (Math.PI * 2));
                            if (angleDiff > Math.PI) angleDiff = Math.PI * 2 - angleDiff;

                            // If beam angle matches entity angle (with generous tolerance), destroy it
                            // 8 beams at 45Â° apart, with 0.6 rad (34Â°) tolerance = nearly full coverage
                            if (angleDiff < 0.6) {
                                // Award points based on entity type
                                if (ent.type === 'obstacle') {
                                    addBonusPoints(15, entCenterX, entCenterY - 20);
                                } else if (ent.type === 'banana') {
                                    // Bananas give 150 per banana (300 for bundle)
                                    const bananaValue = ent.bananaValue || 1;
                                    const points = bananaValue * 150;
                                    bananasCollected += bananaValue; // Count as collected!
                                    addBonusPoints(points, entCenterX, entCenterY - 20);
                                } else if (ent.type === 'powerup') {
                                    // Power-ups give their normal collection bonus (but NO effect activation)
                                    const powerupPoints = {
                                        'jetpack': 100, 'trex': 100, 'turtle': 100,
                                        'star': 150, 'money': 100, 'laser': 125,
                                        'bubble': 75, 'pogo': 75, 'lion': 100
                                    };
                                    const points = powerupPoints[ent.powerupType] || 50;
                                    addBonusPoints(points, entCenterX, entCenterY - 20);
                                }
                                entities.splice(i, 1);
                                laserDestroyed = true;
                                break; // Exit beam loop
                            }
                        }
                        if (laserDestroyed) continue; // Move to next entity in outer loop
                    }
                }

                // Remove off-screen entities
                const entW = ent.pixels[0].length * ent.scale;
                if (ent.x + entW < -50) {
                    entities.splice(i, 1);
                    continue;
                }

                // Collision detection - skip if player is a ghost in multiplayer
                if (gameMode === 'multiplayer' && !localPlayerAlive) {
                    continue;  // Ghost mode - no collisions
                }

                const pRight = player.x + PLAYER_WIDTH;
                const pBottom = player.y + PLAYER_HEIGHT;
                const eRight = ent.x + (ent.pixels[0].length * ent.scale);
                const eBottom = ent.y + (ent.pixels.length * ent.scale);

                if (player.x < eRight &&
                    pRight > ent.x &&
                    player.y < eBottom &&
                    pBottom > ent.y) {

                    if (ent.type === 'obstacle') {
                        // Priority system: Strongest protection wins
                        // 1. Star - destroys obstacles on contact
                        // 2. Dino - stomps through obstacles
                        // 3. Jetpack - flying above (avoids ground obstacles)
                        // 4. Bubble - absorbs hit, then pops
                        // 5. Normal - death
                        const protection = getActiveProtection();

                        if (protection === 'star') {
                            // Star: Destroy obstacle on contact
                            entities.splice(i, 1);
                            addBonusPoints(25, ent.x + 20, ent.y - 10);
                            continue;
                        } else if (protection === 'laser') {
                            // Laser: Destroy obstacle on contact
                            entities.splice(i, 1);
                            addBonusPoints(20, ent.x + 20, ent.y - 10);
                            continue;
                        } else if (protection === 'dino') {
                            // T-Rex: STOMP and destroy obstacles with screen shake!
                            entities.splice(i, 1);
                            addBonusPoints(20, ent.x + 20, ent.y - 10);
                            triggerScreenShake(18); // STRONGER stomp shake on each obstacle
                            continue;
                        } else if (protection === 'jetpack') {
                            // Jetpack: Flying above obstacles (already handled by jetpackActive)
                            continue;
                        } else if (protection === 'bubble') {
                            // Bubble: Absorb hit and pop one bubble
                            bubbleShieldCount--;
                            sessionBubbleHitsAbsorbed++;

                            // Start brief invincibility to protect against grouped obstacles
                            bubblePopInvincibility = BUBBLE_POP_INVINCIBILITY;

                            // Announce bubble pop
                            triggerAnnouncement('BUBBLE POP');

                            // Remove the obstacle that hit us
                            entities.splice(i, 1);
                            continue;
                        }

                        // Check for bubble pop invincibility (protects against grouped obstacles)
                        if (bubblePopInvincibility > 0) {
                            // Still briefly invincible after bubble pop, destroy this obstacle too
                            entities.splice(i, 1);
                            continue;
                        }

                        // No protection: Death
                        if (gameMode === 'multiplayer') {
                            // In multiplayer: become a ghost, don't end game
                            localPlayerAlive = false;

                            // Update local player state
                            if (allPlayersStates[currentUser?.id]) {
                                allPlayersStates[currentUser.id].isAlive = false;
                                allPlayersStates[currentUser.id].score = score;
                                allPlayersStates[currentUser.id].bananas = bananasCollected;
                            }

                            // Broadcast death immediately
                            broadcastPlayerState();

                            // Check if all players dead
                            checkRoundOver();
                        } else {
                            // Solo mode: game over as before
                            gameState = 'gameover';

                            // Fetch game over stats (before saving so we compare against previous bests)
                            fetchGameOverStats(score, selectedLand);

                            // Save score if logged in and not already saved
                            if (!scoreSaved && currentUser) {
                                scoreSaved = true;
                                const gameTimeSeconds = Math.floor(gameTime / 60);

                                // Wait for score to save, then check achievements
                                saveScore(score, bananasCollected, selectedLand).then(() => {
                                    checkAchievements(score, bananasCollected, gameTimeSeconds, false, false);
                                });
                            }
                        }
                    } else if (ent.type === 'banana') {
                        // Banana collection - only if alive
                        if (gameMode !== 'multiplayer' || localPlayerAlive) {
                            // Get banana value (1 for single, 2 for bundle)
                            const bananaValue = ent.bananaValue || 1;
                            bananasCollected += bananaValue;
                            // Show floating text (+150 for single, +300 for bundle)
                            const pointsGained = bananaValue * 150;

                            // Show 2x text when money active (actual doubling handled by score tracking)
                            if (moneyActive) {
                                spawnFloatingText(player.x + PLAYER_WIDTH / 2, player.y - 10, `+${pointsGained * 2} (2X!)`);
                            } else {
                                spawnFloatingText(player.x + PLAYER_WIDTH / 2, player.y - 10, `+${pointsGained}`);
                            }

                            // Debug log for multiplayer
                            if (gameMode === 'multiplayer') {
                                console.log(`[Banana] Collected! Value: ${bananaValue}, Total: ${bananasCollected}, Score: ${score}`);
                            }
                            entities.splice(i, 1);
                            continue;
                        }
                    } else if (ent.type === 'powerup') {
                        // Power-up collection
                        if (gameMode !== 'multiplayer' || localPlayerAlive) {
                            // ========== TIME-BASED BUFFS ==========
                            if (ent.powerupType === 'jetpack' && !jetpackActive && !trexActive) {
                                // Activate jetpack - hovers at banana collection height
                                jetpackActive = true;
                                jetpackTimer = TIME_BUFF_DURATION; // 7 seconds (420 frames)
                                jetpackTargetY = player.groundY - JETPACK_FLY_HEIGHT;
                                player.jumping = false; // Cancel any current jump
                                player.vy = 0;

                                // Track jetpack collection
                                sessionJetpacksCollected++;

                                // Award bonus points
                                addBonusPoints(100, player.x + PLAYER_WIDTH / 2, player.y - 10);

                                // Announce power-up
                                triggerAnnouncement('JETPACK');

                                entities.splice(i, 1);
                                continue;
                            } else if (ent.powerupType === 'trex' && !trexActive && !jetpackActive) {
                                // Activate T-Rex!
                                trexActive = true;
                                trexTimer = TIME_BUFF_DURATION; // 7 seconds (420 frames)
                                player.jumping = false; // Cancel any current jump
                                player.y = player.groundY; // Lock to ground
                                player.vy = 0;

                                // Track dino stomp collection
                                sessionDinoStompsCollected++;

                                // Award bonus points
                                addBonusPoints(100, player.x + PLAYER_WIDTH / 2, player.y - 10);

                                // Announce power-up
                                triggerAnnouncement('DINO-STOMP');

                                entities.splice(i, 1);
                                continue;
                            } else if (ent.powerupType === 'turtle' && !turtleActive) {
                                // Activate Turtle Time!
                                turtleActive = true;
                                turtleTimer = TIME_BUFF_DURATION; // 7 seconds

                                // Trigger turtle emoji animation
                                turtleEmojiActive = true;
                                turtleEmojiTimer = TURTLE_EMOJI_DURATION;
                                turtleEmojiScale = 1;

                                // Transform ALL existing obstacles into turtles!
                                entities.forEach(entity => {
                                    if (entity.type === 'obstacle') {
                                        entity.pixels = sprites.turtleObstacle;
                                        entity.colors = colors.turtleObstacle;
                                    }
                                });

                                // Track turtle collection
                                sessionTurtlesCollected++;

                                // Award bonus points
                                addBonusPoints(100, player.x + PLAYER_WIDTH / 2, player.y - 10);

                                // Announce power-up
                                triggerAnnouncement('TURTLE TIME');

                                entities.splice(i, 1);
                                continue;
                            } else if (ent.powerupType === 'star' && !starActive) {
                                // Activate Star Invincibility!
                                starActive = true;
                                starTimer = TIME_BUFF_DURATION; // 7 seconds
                                starColorIndex = 0;

                                // Track star collection
                                sessionStarsCollected++;

                                // Award bonus points
                                addBonusPoints(150, player.x + PLAYER_WIDTH / 2, player.y - 10);

                                // Announce power-up
                                triggerAnnouncement('SUPERSTAR');

                                entities.splice(i, 1);
                                continue;
                            } else if (ent.powerupType === 'money' && !moneyActive) {
                                // Activate Double Points!
                                moneyActive = true;
                                moneyTimer = MONEY_DURATION; // 7 seconds
                                moneyBonusAccumulated = 0; // Reset bonus tracker

                                // Track money collection
                                sessionMoneyCollected++;

                                // Award bonus points (2x kicks in immediately, so show 200)
                                powerUpBonusScore += 100;
                                spawnFloatingText(player.x + PLAYER_WIDTH / 2, player.y - 10, '+200 (2X!)');

                                // Announce power-up
                                triggerAnnouncement('2X POINTS!');

                                entities.splice(i, 1);
                                continue;
                            } else if (ent.powerupType === 'laser' && !laserActive) {
                                // Activate Laser Eyes!
                                laserActive = true;
                                laserTimer = LASER_DURATION; // 7 seconds
                                laserAngle = 0;

                                // Track laser collection
                                sessionLasersCollected++;

                                // Award bonus points
                                addBonusPoints(125, player.x + PLAYER_WIDTH / 2, player.y - 10);

                                // Announce power-up
                                triggerAnnouncement('LASER EYES');

                                entities.splice(i, 1);
                                continue;
                            }
                            // ========== PERMANENT BUFFS (NO STACKING) ==========
                            else if (ent.powerupType === 'bubble' && bubbleShieldCount === 0) {
                                // Add a Bubble Shield (only 1 at a time)
                                bubbleShieldCount = 1;
                                sessionBubblesCollected++;

                                // Award bonus points
                                addBonusPoints(75, player.x + PLAYER_WIDTH / 2, player.y - 10);

                                // Announce power-up
                                triggerAnnouncement('BUBBLE SHIELD');

                                entities.splice(i, 1);
                                continue;
                            } else if (ent.powerupType === 'pogo' && pogoStickCount === 0) {
                                // Add a Pogo Stick (only 1 at a time)
                                pogoStickCount = 1;
                                sessionPogosCollected++;

                                // Award bonus points
                                addBonusPoints(75, player.x + PLAYER_WIDTH / 2, player.y - 10);

                                // Announce power-up
                                triggerAnnouncement('POGO STICK');

                                entities.splice(i, 1);
                                continue;
                            } else if (ent.powerupType === 'lion' && !lionRoarUsed) {
                                // Activate Lion Roar (once per run only)
                                lionRoarUsed = true;
                                obstaclesShrunk = true;
                                sessionLionsCollected++;

                                // Shrink ALL existing obstacles immediately (20% reduction)
                                for (let j = 0; j < entities.length; j++) {
                                    if (entities[j].type === 'obstacle') {
                                        entities[j].scale *= 0.8;
                                    }
                                }

                                // Trigger lion emoji animation (grows and fades)
                                lionEmojiActive = true;
                                lionEmojiTimer = LION_EMOJI_DURATION;
                                lionEmojiScale = 1;

                                // Award bonus points
                                addBonusPoints(200, player.x + PLAYER_WIDTH / 2, player.y - 10);

                                // Announce power-up
                                triggerAnnouncement('LION ROAR');

                                entities.splice(i, 1);
                                continue;
                            } else if (ent.powerupType === 'bodyDouble' && !bodyDoubleActive) {
                                // Activate Body Double!
                                bodyDoubleActive = true;

                                // Initialize double at player's current position
                                bodyDoubleY = player.y;
                                bodyDoubleVY = player.vy;
                                bodyDoubleJumping = player.jumping;

                                // Initialize input buffer with current state
                                bodyDoubleInputBuffer = [];
                                for (let f = 0; f < BODY_DOUBLE_DELAY_FRAMES; f++) {
                                    bodyDoubleInputBuffer.push({
                                        y: player.y,
                                        vy: player.vy,
                                        jumping: player.jumping
                                    });
                                }

                                // Track collection
                                sessionBodyDoublesCollected++;

                                // Award bonus points
                                addBonusPoints(100, player.x + PLAYER_WIDTH / 2, player.y - 10);

                                // Announce power-up
                                triggerAnnouncement('BODY DOUBLE');

                                entities.splice(i, 1);
                                continue;
                            }
                        }
                    }
                }
            }

            // BODY DOUBLE COLLISION DETECTION
            // Check if body double hits entities (separate loop to avoid issues with splice)
            if (bodyDoubleActive && (gameMode !== 'multiplayer' || localPlayerAlive)) {
                const doubleX = player.x + BODY_DOUBLE_OFFSET_X;
                const doubleY = bodyDoubleY;
                const doubleRight = doubleX + PLAYER_WIDTH;
                const doubleBottom = doubleY + PLAYER_HEIGHT;

                for (let i = entities.length - 1; i >= 0; i--) {
                    const ent = entities[i];
                    if (!ent || !ent.pixels || !ent.pixels[0]) continue;

                    const entW = ent.pixels[0].length * ent.scale;
                    const entH = ent.pixels.length * ent.scale;
                    const eRight = ent.x + entW;
                    const eBottom = ent.y + entH;

                    // Collision check for double
                    if (doubleX < eRight && doubleRight > ent.x &&
                        doubleY < eBottom && doubleBottom > ent.y) {

                        if (ent.type === 'banana') {
                            // Double collects bananas!
                            const bananaValue = ent.bananaValue || 1;
                            bananasCollected += bananaValue;
                            const pointsGained = bananaValue * 150;

                            if (moneyActive) {
                                spawnFloatingText(doubleX + PLAYER_WIDTH / 2, doubleY - 10, `+${pointsGained * 2} (2X!)`);
                            } else {
                                spawnFloatingText(doubleX + PLAYER_WIDTH / 2, doubleY - 10, `+${pointsGained}`);
                            }

                            entities.splice(i, 1);
                            continue;
                        } else if (ent.type === 'powerup') {
                            // Double collects power-ups! (Trigger same bonus but don't activate duplicates)
                            addBonusPoints(50, doubleX + PLAYER_WIDTH / 2, doubleY - 10);
                            entities.splice(i, 1);
                            continue;
                        } else if (ent.type === 'obstacle') {
                            // Check if double has destructive power (star/laser/dino)
                            const protection = getActiveProtection();

                            if (protection === 'star') {
                                // Double also destroys with star!
                                entities.splice(i, 1);
                                addBonusPoints(25, ent.x + 20, ent.y - 10);
                                continue;
                            } else if (protection === 'laser') {
                                // Double also destroys with laser!
                                entities.splice(i, 1);
                                addBonusPoints(20, ent.x + 20, ent.y - 10);
                                continue;
                            } else if (protection === 'dino') {
                                // Double also stomps with dino!
                                entities.splice(i, 1);
                                addBonusPoints(20, ent.x + 20, ent.y - 10);
                                triggerScreenShake(18);
                                continue;
                            } else {
                                // Double absorbs hit and disappears!
                                bodyDoubleActive = false;
                                bodyDoubleInputBuffer = [];

                                // Spawn cyan dissolve particles
                                spawnBodyDoubleDeathParticles(doubleX + PLAYER_WIDTH / 2, doubleY + PLAYER_HEIGHT / 2);

                                // Announce
                                triggerAnnouncement('DOUBLE DOWN');

                                // Remove the obstacle that hit the double
                                entities.splice(i, 1);
                                break; // Exit loop since double is gone
                            }
                        }
                    }
                }
            }

            // Jump bonus detection - award points for successfully jumping over obstacles
            if (gameMode !== 'multiplayer' || localPlayerAlive) {
                for (let i = 0; i < entities.length; i++) {
                    const ent = entities[i];
                    if (!ent || !ent.pixels || !ent.pixels[0]) continue;
                    if (ent.type !== 'obstacle') continue;
                    if (ent.spawnId === undefined) continue;

                    // Calculate obstacle dimensions
                    const eRight = ent.x + (ent.pixels[0].length * ent.scale);

                    // Check if player has passed this obstacle (player left > obstacle right)
                    if (player.x > eRight && !obstaclesJumpedOver.has(ent.spawnId)) {
                        // Award bonus based on obstacle count (+10 per obstacle unit)
                        const bonus = ent.obstacleCount * 10;
                        jumpBonusScore += bonus;
                        obstaclesJumpedOver.add(ent.spawnId);

                        // Show floating text above player (2x handled by score tracking)
                        const bonusText = moneyActive ? `+${bonus * 2} (2X!)` : `+${bonus}`;
                        spawnFloatingText(player.x + PLAYER_WIDTH / 2, player.y - 30, bonusText);
                    }
                }
            }

            // Update score (time survived + banana bonuses + jump bonuses) - but freeze on death in multiplayer
            if (gameMode !== 'multiplayer' || localPlayerAlive) {
                let baseScore = Math.floor(gameTime / 6) + (bananasCollected * 150) + jumpBonusScore + powerUpBonusScore;

                // MONEY POWER-UP: Track bonus points earned while 2x is active
                // When money is active, we earn bonus points equal to the score increase
                if (moneyActive) {
                    const scoreIncrease = baseScore - (score - moneyBonusAccumulated);
                    if (scoreIncrease > 0) {
                        moneyBonusAccumulated += scoreIncrease;
                    }
                }

                // Final score = base score + money bonus (extra points from 2x)
                score = baseScore + moneyBonusAccumulated;
            }

            scrollOffset = (scrollOffset + speed * gameDelta) % 40; // Use gameDelta for turtle slow-mo

            // Update and broadcast game state in multiplayer (every 5 frames = ~12 updates/sec for smoother sync)
            if (gameMode === 'multiplayer' && Math.floor(gameTime) % 5 === 0) {
                // Update local player state in shared state before broadcasting
                if (currentUser?.id && allPlayersStates[currentUser.id]) {
                    // Store yOffset for consistency (though local rendering uses player.y directly)
                    allPlayersStates[currentUser.id].yOffset = player ? (player.y - player.groundY) : 0;
                    allPlayersStates[currentUser.id].score = score;
                    allPlayersStates[currentUser.id].bananas = bananasCollected;
                    allPlayersStates[currentUser.id].isAlive = localPlayerAlive;
                }
                broadcastPlayerState();
            }

            // Update particle effects
            updateParticles(delta);
            updateSkinEffects(delta);
            updateFloatingTexts(delta);
        }

        // Draw menu action buttons
        function drawMenuButtons(buttons, startY) {
            const btnWidth = 200;
            const btnHeight = 50;
            const gap = 15;

            menuButtons = [];

            buttons.forEach((btn, i) => {
                const x = (canvas.width - btnWidth) / 2;
                const y = startY + i * (btnHeight + gap);

                menuButtons.push({ x, y, w: btnWidth, h: btnHeight, action: btn.action });

                // Draw button background
                ctx.fillStyle = btn.primary ? '#FFE135' : '#333';
                ctx.fillRect(x, y, btnWidth, btnHeight);

                // Draw border
                ctx.strokeStyle = btn.primary ? '#FFC107' : '#555';
                ctx.lineWidth = 2;
                ctx.strokeRect(x, y, btnWidth, btnHeight);

                // Draw text
                ctx.fillStyle = btn.primary ? '#000' : '#FFF';
                ctx.font = 'bold 18px monospace';
                ctx.textAlign = 'center';
                ctx.fillText(btn.label, x + btnWidth / 2, y + btnHeight / 2 + 6);
            });
        }

        // Draw back button (top right corner) - unified across screens
        let backButton = null;
        function drawBackButton(targetState = 'menu') {
            const btnWidth = 80;
            const btnHeight = 40;
            const x = canvas.width - btnWidth - 20;
            const y = 20;

            // Store for click detection
            backButton = { x, y, w: btnWidth, h: btnHeight, action: () => { gameState = targetState; } };

            // Draw button with rounded corners
            ctx.fillStyle = '#333';
            ctx.beginPath();
            ctx.roundRect(x, y, btnWidth, btnHeight, 8);
            ctx.fill();

            // Border
            ctx.strokeStyle = '#555';
            ctx.lineWidth = 2;
            ctx.stroke();

            // Arrow and text
            ctx.fillStyle = '#FFF';
            ctx.font = 'bold 16px monospace';
            ctx.textAlign = 'center';
            ctx.fillText('â† Back', x + btnWidth / 2, y + btnHeight / 2 + 5);

            return backButton;
        }

        // Draw land selection buttons
        function drawLandButtons(startY, showChangeText) {
            const landKeys = Object.keys(lands);
            // Responsive button sizes
            const btnWidth = Math.min(120, Math.round((canvas.width - DS.spacing.xl * 2) / landKeys.length - DS.spacing.sm));
            const btnHeight = Math.max(44, Math.round(canvas.width * 0.055));
            const gap = DS.spacing.sm;
            const totalWidth = landKeys.length * btnWidth + (landKeys.length - 1) * gap;
            const startX = (canvas.width - totalWidth) / 2;

            landButtons = [];

            landKeys.forEach((key, i) => {
                const land = lands[key];
                const x = startX + i * (btnWidth + gap);
                const y = startY;
                const isSelected = key === selectedLand;

                // Store button for click detection
                landButtons.push({ x, y, w: btnWidth, h: btnHeight, land: key });

                // Draw button with rounded corners
                ctx.fillStyle = isSelected ? land.ground : DS.colors.locked;
                ctx.beginPath();
                ctx.roundRect(x, y, btnWidth, btnHeight, DS.button.radius);
                ctx.fill();

                // Draw border
                ctx.strokeStyle = isSelected ? DS.colors.white : DS.colors.textMuted;
                ctx.lineWidth = isSelected ? 3 : 2;
                ctx.stroke();

                // Draw text
                ctx.fillStyle = DS.colors.white;
                ctx.font = DS.font('small', 'bold');
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(land.name, x + btnWidth / 2, y + btnHeight / 2);
            });

            if (showChangeText) {
                ctx.fillStyle = DS.colors.textSecondary;
                ctx.font = DS.font('tiny');
                ctx.textAlign = 'center';
                ctx.fillText('Tap a land to change, or tap anywhere to play', canvas.width / 2, startY + btnHeight + DS.spacing.lg);
            }
        }

        // Draw everything
        function draw() {
            const land = lands[selectedLand];
            const groundY = getGroundLevel();

            // Clear canvas
            ctx.fillStyle = '#FAFAFA';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw sky gradient with land colors
            const grad = ctx.createLinearGradient(0, 0, 0, groundY);
            grad.addColorStop(0, land.skyTop);
            grad.addColorStop(1, land.skyBottom);
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, canvas.width, groundY);

            // Draw scrolling ground with land colors
            ctx.fillStyle = land.ground;
            ctx.fillRect(0, groundY, canvas.width, canvas.height - groundY);

            // Draw ground bumps/dots (scrolling)
            ctx.fillStyle = land.groundAccent;
            let bumpX = (-scrollOffset) % 40;
            for (let i = 0; i < canvas.width / 20 + 3; i++) {
                const x = bumpX + (i * 40);
                ctx.fillRect(x, groundY - 4, 20, 8);
                ctx.fillRect(x + 22, groundY, 8, 8);
            }

            if (gameState === 'welcome') {
                // Welcome/Landing screen - shown before login
                resetClickables();
                ctx.fillStyle = DS.colors.bgOverlay;
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                const centerX = canvas.width / 2;

                // Compact mode for small screens
                const isCompact = canvas.height < 600;

                let y = isCompact ? DS.spacing.lg : DS.spacing.xxl;

                // Title with banana logo on left - smaller on compact
                const titleSize = isCompact ? 'h2' : 'h1';
                const bananaScale = isCompact ? Math.max(1, Math.round(canvas.width / 500)) : Math.max(2, Math.round(canvas.width / 400));
                const bananaWidth = sprites.banana[0].length * bananaScale;
                const bananaHeight = sprites.banana.length * bananaScale;

                ctx.font = DS.font(titleSize, 'bold');
                const titleWidth = ctx.measureText('BANANA RUNNER').width;
                const logoGap = isCompact ? DS.spacing.sm : DS.spacing.md;
                const totalWidth = bananaWidth + logoGap + titleWidth;
                const startX = centerX - totalWidth / 2;

                // Draw banana logo
                const logoY = y + (DS.fontSize(titleSize) - bananaHeight) / 2;
                drawSprite(ctx, startX, logoY, sprites.banana, bananaScale, colors.banana);

                // Draw title text
                ctx.textAlign = 'left';
                ctx.fillStyle = DS.colors.primary;
                ctx.fillText('BANANA RUNNER', startX + bananaWidth + logoGap, y + DS.fontSize(titleSize));
                ctx.textAlign = 'center'; // Reset for other elements
                y += DS.fontSize(titleSize) + (isCompact ? DS.spacing.md : DS.spacing.lg);

                // Tagline
                ctx.fillStyle = DS.colors.textPrimary;
                ctx.font = DS.font(isCompact ? 'body' : 'h3');
                ctx.fillText('An endless runner adventure!', centerX, y);
                y += DS.fontSize(isCompact ? 'body' : 'h3') + (isCompact ? DS.spacing.md : DS.spacing.xl);

                // Features panel - condensed on compact
                if (!isCompact) {
                    const panelWidth = Math.min(500, canvas.width - DS.spacing.xl * 2);
                    const panelHeight = DS.fontSize('body') * 4 + DS.spacing.lg * 2;
                    drawPanel(centerX, y, panelWidth, panelHeight, { centered: true });

                    ctx.fillStyle = DS.colors.textSecondary;
                    ctx.font = DS.font('body');
                    const featureY = y + DS.spacing.lg + DS.fontSize('body');
                    ctx.fillText('Jump over obstacles & collect bananas', centerX, featureY);
                    ctx.fillText('Compete in multiplayer battles', centerX, featureY + DS.fontSize('body') + DS.spacing.sm);
                    ctx.fillText('Unlock achievements & climb ranks', centerX, featureY + (DS.fontSize('body') + DS.spacing.sm) * 2);
                    y += panelHeight + DS.spacing.xl;
                }

                // Feature highlights
                ctx.fillStyle = DS.colors.primary;
                ctx.font = DS.font('small', 'bold');
                ctx.fillText('4 LANDS  â€¢  MULTIPLAYER  â€¢  LEADERBOARDS', centerX, y);
                y += DS.fontSize('small') + (isCompact ? DS.spacing.lg : DS.spacing.xxl);

                // Login button - smaller on compact
                const btnWidth = Math.min(isCompact ? 220 : 280, canvas.width - DS.spacing.lg * 2);
                const btnHeight = isCompact ? Math.max(44, DS.button.height() * 0.85) : DS.button.height();
                const btnBounds = drawStyledButton(centerX, y, btnWidth, btnHeight, 'GET STARTED', { action: 'login', primary: true });
                addClickable(btnBounds);

                // Footer - only if room
                if (canvas.height - y - btnHeight > 50) {
                    ctx.fillStyle = DS.colors.textMuted;
                    ctx.font = DS.font('small');
                    ctx.fillText('Create an account to save progress', centerX, canvas.height - DS.spacing.md);
                }

            } else if (gameState === 'menu') {
                // Menu screen - shown after login
                resetClickables();
                ctx.fillStyle = DS.colors.bgOverlayLight;
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                const centerX = canvas.width / 2;

                // Compact mode for small screens
                const isCompact = canvas.height < 600;
                const compactSpacing = isCompact ? DS.spacing.sm : DS.spacing.md;
                const compactLgSpacing = isCompact ? DS.spacing.md : DS.spacing.lg;

                let y = isCompact ? DS.spacing.md : DS.spacing.xl;

                // Title with banana logo on left - smaller on compact screens
                const titleSize = isCompact ? 'h2' : 'h1';
                const bananaScale = isCompact ? Math.max(1, Math.round(canvas.width / 500)) : Math.max(2, Math.round(canvas.width / 400));
                const bananaWidth = sprites.banana[0].length * bananaScale;
                const bananaHeight = sprites.banana.length * bananaScale;

                ctx.font = DS.font(titleSize, 'bold');
                const titleWidth = ctx.measureText('BANANA RUNNER').width;
                const logoGap = isCompact ? DS.spacing.sm : DS.spacing.md;
                const logoTotalWidth = bananaWidth + logoGap + titleWidth;
                const startX = centerX - logoTotalWidth / 2;

                // Draw banana logo
                const logoY = y + (DS.fontSize(titleSize) - bananaHeight) / 2;
                drawSprite(ctx, startX, logoY, sprites.banana, bananaScale, colors.banana);

                // Draw title text
                ctx.textAlign = 'left';
                ctx.fillStyle = DS.colors.white;
                ctx.fillText('BANANA RUNNER', startX + bananaWidth + logoGap, y + DS.fontSize(titleSize));
                ctx.textAlign = 'center'; // Reset for other elements
                y += DS.fontSize(titleSize) + compactLgSpacing;

                // User stats panel - condensed on compact
                if (userProfile) {
                    const statsPanelWidth = Math.min(isCompact ? 320 : 420, canvas.width - DS.spacing.lg * 2);
                    const statsFont = isCompact ? 'small' : 'body';
                    const statsPanelHeight = isCompact
                        ? DS.fontSize('small') * 2.5 + DS.spacing.md * 2
                        : DS.fontSize('body') * 3 + DS.spacing.lg * 2;
                    drawPanel(centerX, y, statsPanelWidth, statsPanelHeight, { centered: true });

                    const statsY = y + (isCompact ? DS.spacing.md : DS.spacing.lg) + DS.fontSize(statsFont) / 2;
                    ctx.fillStyle = DS.colors.primary;
                    ctx.font = DS.font(statsFont, 'bold');
                    ctx.fillText(`${userProfile.username || 'Player'}  â€¢  High: ${userProfile.high_score || 0}`, centerX, statsY);

                    if (!isCompact) {
                        ctx.fillStyle = DS.colors.white;
                        ctx.font = DS.font('body');
                        ctx.fillText(`High Score: ${userProfile.high_score || 0}`, centerX, statsY + DS.fontSize('body') + DS.spacing.xs);
                    }

                    ctx.fillStyle = DS.colors.textSecondary;
                    ctx.font = DS.font('small');
                    const statsLine2Y = isCompact ? statsY + DS.fontSize('small') + DS.spacing.xs : statsY + (DS.fontSize('body') + DS.spacing.xs) * 2;
                    ctx.fillText(`${spendableBananas} ðŸŒ to spend  |  ${userProfile.total_games || 0} games`, centerX, statsLine2Y);
                    y += statsPanelHeight + compactLgSpacing;
                }

                // Land selection
                y = drawSectionTitle('SELECT LAND', y);
                const landBtnHeight = isCompact ? 40 : 50;
                drawLandButtons(y, false);
                y += landBtnHeight + compactLgSpacing;

                // Two-column menu layout
                // Left: Solo Play, Multiplayer | Right: Shop, Achievements, Leaderboard
                const totalWidth = Math.min(isCompact ? 400 : 500, canvas.width - DS.spacing.lg * 2);
                const columnGap = isCompact ? DS.spacing.sm : DS.spacing.md;
                const columnWidth = (totalWidth - columnGap) / 2;
                const btnHeight = isCompact ? Math.max(40, DS.button.height() * 0.8) : DS.button.height();
                const gap = isCompact ? DS.spacing.sm : DS.spacing.md;
                const leftX = centerX - totalWidth / 2 + columnWidth / 2;
                const rightX = centerX + columnGap / 2 + columnWidth / 2;

                // Section labels
                ctx.fillStyle = DS.colors.textMuted;
                ctx.font = DS.font('tiny', 'bold');
                ctx.textAlign = 'center';
                ctx.fillText('PLAY', leftX, y);
                ctx.fillText('EXPLORE', rightX, y);
                y += DS.fontSize('tiny') + DS.spacing.xs;

                // Left column - Play modes
                const leftColumnY = y;
                const soloBounds = drawStyledButton(leftX, leftColumnY, columnWidth, btnHeight, 'SOLO', { action: 'solo', primary: true });
                addClickable(soloBounds);

                const multiBounds = drawStyledButton(leftX, leftColumnY + btnHeight + gap, columnWidth, btnHeight, 'MULTI', { action: 'multiplayer', primary: false });
                addClickable(multiBounds);

                // Right column - Explore options
                const rightColumnY = y;
                const shopBounds = drawStyledButton(rightX, rightColumnY, columnWidth, btnHeight, 'SHOP', { action: 'shop', primary: false });
                addClickable(shopBounds);

                const achieveBounds = drawStyledButton(rightX, rightColumnY + btnHeight + gap, columnWidth, btnHeight, 'ACHIEVE', { action: 'achievements', primary: false });
                addClickable(achieveBounds);

                const leaderBounds = drawStyledButton(rightX, rightColumnY + (btnHeight + gap) * 2, columnWidth, btnHeight, 'RANK', { action: 'leaderboard', primary: false });
                addClickable(leaderBounds);

                // Advance y to bottom of taller column
                y += Math.max((btnHeight + gap) * 2, (btnHeight + gap) * 3);

                // Instructions - only show if there's room
                if (canvas.height - y > 60) {
                    ctx.fillStyle = DS.colors.textMuted;
                    ctx.font = DS.font('small');
                    ctx.fillText('Press SPACE or tap to jump!', centerX, canvas.height - DS.spacing.md);
                }

            } else if (gameState === 'leaderboard') {
                // Leaderboard screen
                resetClickables();
                ctx.fillStyle = DS.colors.bgOverlay;
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // Header with back button
                const header = drawHeader('LEADERBOARD', true);
                addClickable(header.backBounds);

                const centerX = canvas.width / 2;
                let contentY = header.height + DS.spacing.lg;

                if (loadingLeaderboard) {
                    ctx.fillStyle = DS.colors.textSecondary;
                    ctx.font = DS.font('h3');
                    ctx.textAlign = 'center';
                    ctx.fillText('Loading...', centerX, canvas.height / 2);
                } else if (leaderboardData.length === 0) {
                    ctx.fillStyle = DS.colors.textSecondary;
                    ctx.font = DS.font('body');
                    ctx.textAlign = 'center';
                    ctx.fillText('No scores yet!', centerX, canvas.height / 2 - DS.spacing.md);
                    ctx.fillText('Be the first to play!', centerX, canvas.height / 2 + DS.spacing.md);
                } else {
                    // Draw leaderboard panel
                    const panelWidth = Math.min(500, canvas.width - DS.spacing.lg * 2);
                    const rowHeight = Math.max(36, DS.fontSize('body') + DS.spacing.md);
                    const panelHeight = rowHeight * (leaderboardData.length + 1) + DS.spacing.lg * 2;
                    const panelX = centerX - panelWidth / 2;

                    drawPanel(panelX, contentY, panelWidth, panelHeight);

                    // Table header
                    const tableY = contentY + DS.spacing.lg;
                    const colRank = panelX + DS.spacing.lg;
                    const colPlayer = panelX + DS.spacing.xl * 2;
                    const colScore = panelX + panelWidth - DS.spacing.lg;

                    ctx.fillStyle = DS.colors.textMuted;
                    ctx.font = DS.font('small', 'bold');
                    ctx.textAlign = 'left';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('RANK', colRank, tableY + rowHeight / 2);
                    ctx.fillText('PLAYER', colPlayer, tableY + rowHeight / 2);
                    ctx.textAlign = 'right';
                    ctx.fillText('SCORE', colScore, tableY + rowHeight / 2);

                    // Draw entries
                    leaderboardData.forEach((entry, i) => {
                        const y = tableY + (i + 1) * rowHeight + rowHeight / 2;
                        const isCurrentUser = currentUser && entry.player_id === currentUser.id;

                        ctx.fillStyle = isCurrentUser ? DS.colors.primary : DS.colors.white;
                        ctx.font = DS.font('body', isCurrentUser ? 'bold' : 'normal');

                        ctx.textAlign = 'left';
                        ctx.fillText(`#${i + 1}`, colRank, y);
                        ctx.fillText(entry.username || 'Anonymous', colPlayer, y);
                        ctx.textAlign = 'right';
                        ctx.fillText(entry.high_score?.toString() || '0', colScore, y);
                    });
                }

            } else if (gameState === 'shop') {
                // Shop screen - Browse and purchase skins
                resetClickables();
                ctx.fillStyle = DS.colors.bgOverlay;
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // Header with back button
                const header = drawHeader('BANANA SHOP', true);
                addClickable(header.backBounds);

                const centerX = canvas.width / 2;
                let contentY = header.height + DS.spacing.md;

                // Balance panel
                const balancePanelWidth = Math.min(280, canvas.width - DS.spacing.lg * 2);
                const balancePanelHeight = DS.fontSize('h3') + DS.spacing.lg;
                drawPanel(centerX - balancePanelWidth / 2, contentY, balancePanelWidth, balancePanelHeight);

                ctx.textAlign = 'center';
                ctx.fillStyle = DS.colors.primary;
                ctx.font = DS.font('h3', 'bold');
                ctx.fillText(`${spendableBananas} ðŸŒ to spend`, centerX, contentY + balancePanelHeight / 2 + DS.fontSize('h3') / 3);
                contentY += balancePanelHeight + DS.spacing.md;

                // Equipped skin indicator
                const equippedSkin = SKINS[selectedSkin];
                ctx.fillStyle = DS.colors.textSecondary;
                ctx.font = DS.font('small');
                ctx.fillText(`Equipped: ${equippedSkin?.name || 'Default'}`, centerX, contentY);
                contentY += DS.fontSize('small') + DS.spacing.md;

                // Skin cards - organized by tier with responsive grid
                const shopPadding = DS.spacing.sm;
                const cardGap = DS.spacing.xs;
                const availableWidth = canvas.width - shopPadding * 2;

                // Responsive: 2 columns if wide enough, otherwise 1
                const numCols = availableWidth >= 400 ? 2 : 1;
                const cardWidth = (availableWidth - (numCols - 1) * cardGap) / numCols;
                const cardHeight = 56;  // Compact height for better density

                // Group skins by tier
                const tierNames = {
                    0: 'DEFAULT',
                    1: 'ACHIEVEMENT SKINS (Free)',
                    2: 'BUDGET SKINS',
                    3: 'PREMIUM SKINS',
                    4: 'LEGENDARY SKINS'
                };
                const tierColors = {
                    0: DS.colors.textMuted,
                    1: DS.colors.success,
                    2: '#42A5F5',
                    3: DS.colors.primary,
                    4: '#FFD700'
                };

                // Build tier groups
                const tierGroups = {};
                Object.entries(SKINS).forEach(([skinId, skin]) => {
                    const tier = skin.tier ?? 0;
                    if (!tierGroups[tier]) tierGroups[tier] = [];
                    tierGroups[tier].push({ id: skinId, ...skin });
                });

                // Calculate scroll area
                const scrollAreaTop = contentY;
                const scrollAreaHeight = canvas.height - contentY - DS.spacing.md;
                const tierHeaderHeight = DS.fontSize('small') + DS.spacing.md;

                // First pass: calculate total content height (accounting for grid layout)
                let totalHeight = 0;
                [0, 1, 2, 3, 4].forEach(tier => {
                    const skins = tierGroups[tier];
                    if (!skins || skins.length === 0) return;
                    totalHeight += tierHeaderHeight;  // Tier header
                    const numRows = Math.ceil(skins.length / numCols);
                    totalHeight += numRows * (cardHeight + cardGap);  // Cards in grid rows
                    totalHeight += DS.spacing.sm;  // Tier spacing
                });

                // Set max scroll
                shopScrollMax = Math.max(0, totalHeight - scrollAreaHeight);

                // Clip to scroll area
                ctx.save();
                ctx.beginPath();
                ctx.rect(0, scrollAreaTop, canvas.width, scrollAreaHeight);
                ctx.clip();

                // Render skins by tier with scroll offset
                let currentY = scrollAreaTop - shopScrollY;

                [0, 1, 2, 3, 4].forEach(tier => {
                    const skins = tierGroups[tier];
                    if (!skins || skins.length === 0) return;

                    const headerY = currentY;
                    // Draw tier header (only if visible)
                    if (headerY + tierHeaderHeight > scrollAreaTop && headerY < scrollAreaTop + scrollAreaHeight) {
                        ctx.fillStyle = tierColors[tier] || DS.colors.textMuted;
                        ctx.font = DS.font('small', 'bold');
                        ctx.textAlign = 'left';
                        ctx.fillText(tierNames[tier] || `TIER ${tier}`, shopPadding, headerY + DS.fontSize('small'));
                    }
                    currentY += tierHeaderHeight;

                    // Draw skins in this tier using grid layout
                    skins.forEach((skin, idx) => {
                        const skinId = skin.id;
                        const row = Math.floor(idx / numCols);
                        const col = idx % numCols;
                        const cardX = shopPadding + col * (cardWidth + cardGap);
                        const cardY = currentY + row * (cardHeight + cardGap);

                        // Skip if off screen (with scroll)
                        if (cardY + cardHeight < scrollAreaTop || cardY > scrollAreaTop + scrollAreaHeight) return;

                        const isOwned = unlockedSkins.includes(skinId);
                        const isEquipped = selectedSkin === skinId;
                        const canAfford = skin.price ? spendableBananas >= skin.price : true;

                        // Draw card background
                        ctx.fillStyle = isEquipped ? DS.colors.bgPanel : DS.colors.bgDark;
                        ctx.beginPath();
                        ctx.roundRect(cardX, cardY, cardWidth, cardHeight, 6);
                        ctx.fill();

                        // Border with tier color
                        ctx.strokeStyle = isEquipped ? DS.colors.primary : (isOwned ? DS.colors.success : tierColors[tier] || DS.colors.textMuted);
                        ctx.lineWidth = isEquipped ? 2 : 1;
                        ctx.stroke();

                        // Compact layout: Color preview on left (square)
                        const previewSize = cardHeight - 8;
                        const previewX = cardX + 4;
                        const previewY = cardY + 4;
                        const swatchSize = previewSize / 3;

                        if (skin.transparency) {
                            ctx.globalAlpha = skin.transparency;
                        }
                        const overrides = skin.colorOverrides || {};
                        const previewColors = [overrides[4] || '#888', overrides[5] || '#666', overrides[6] || '#444'];
                        previewColors.forEach((color, ci) => {
                            ctx.fillStyle = color;
                            ctx.fillRect(previewX, previewY + ci * swatchSize, previewSize, swatchSize);
                        });
                        ctx.globalAlpha = 1;

                        // Compact: Name + badges on one line
                        const textX = previewX + previewSize + 6;
                        const textMaxWidth = cardWidth - previewSize - 70;  // Leave room for button
                        ctx.fillStyle = DS.colors.white;
                        ctx.font = DS.font('small', 'bold');
                        ctx.textAlign = 'left';

                        // Name with effect badge inline
                        let displayName = skin.name;
                        if (skin.effect) {
                            const effectIcons = { fire: 'ðŸ”¥', ice: 'â„ï¸', shadow: 'ðŸ‘¤', sparkle: 'âœ¨' };
                            displayName += ' ' + (effectIcons[skin.effect] || '');
                        }
                        if (skin.animated) displayName += ' ðŸŒˆ';
                        if (skin.transparency) displayName += ' ðŸ‘»';

                        ctx.fillText(displayName, textX, cardY + cardHeight / 2 + 4, textMaxWidth);

                        // Right side: Compact action button
                        const btnW = 50;
                        const btnH = 24;
                        const btnX = cardX + cardWidth - btnW - 4;
                        const btnY = cardY + (cardHeight - btnH) / 2;

                        if (isEquipped) {
                            ctx.fillStyle = DS.colors.primary;
                            ctx.font = DS.font('tiny', 'bold');
                            ctx.textAlign = 'center';
                            ctx.fillText('âœ“', btnX + btnW / 2, cardY + cardHeight / 2 + 4);
                        } else if (isOwned) {
                            ctx.fillStyle = DS.colors.success;
                            ctx.beginPath();
                            ctx.roundRect(btnX, btnY, btnW, btnH, 3);
                            ctx.fill();
                            ctx.fillStyle = DS.colors.white;
                            ctx.font = DS.font('tiny', 'bold');
                            ctx.textAlign = 'center';
                            ctx.fillText('USE', btnX + btnW / 2, btnY + btnH / 2 + 3);
                            addClickable({ x: btnX, y: btnY, w: btnW, h: btnH, action: `equip_${skinId}` });
                        } else if (skin.type === 'purchasable') {
                            ctx.fillStyle = canAfford ? DS.colors.primary : DS.colors.locked;
                            ctx.beginPath();
                            ctx.roundRect(btnX, btnY, btnW, btnH, 3);
                            ctx.fill();
                            ctx.fillStyle = canAfford ? DS.colors.bgDark : DS.colors.textMuted;
                            ctx.font = DS.font('tiny', 'bold');
                            ctx.textAlign = 'center';
                            ctx.fillText(`${skin.price}ðŸŒ`, btnX + btnW / 2, btnY + btnH / 2 + 3);
                            if (canAfford) {
                                addClickable({ x: btnX, y: btnY, w: btnW, h: btnH, action: `buy_${skinId}` });
                            }
                        } else if (skin.type === 'achievement') {
                            ctx.fillStyle = DS.colors.textMuted;
                            ctx.font = DS.font('tiny');
                            ctx.textAlign = 'center';
                            ctx.fillText('ðŸ”’', btnX + btnW / 2, cardY + cardHeight / 2 + 4);
                        }
                    });

                    // Advance Y by the number of rows in this tier
                    const numRows = Math.ceil(skins.length / numCols);
                    currentY += numRows * (cardHeight + cardGap);

                    // Add spacing between tiers
                    currentY += DS.spacing.sm;
                });

                // Restore clipping
                ctx.restore();

                // Draw scroll indicator if content is scrollable
                if (shopScrollMax > 0) {
                    const scrollTrackHeight = scrollAreaHeight - 20;
                    const scrollThumbHeight = Math.max(30, scrollTrackHeight * (scrollAreaHeight / totalHeight));
                    const scrollThumbY = scrollAreaTop + 10 + (shopScrollY / shopScrollMax) * (scrollTrackHeight - scrollThumbHeight);

                    // Track
                    ctx.fillStyle = 'rgba(255, 225, 53, 0.2)';
                    ctx.fillRect(canvas.width - 8, scrollAreaTop + 10, 4, scrollTrackHeight);

                    // Thumb
                    ctx.fillStyle = DS.colors.primary;
                    ctx.beginPath();
                    ctx.roundRect(canvas.width - 8, scrollThumbY, 4, scrollThumbHeight, 2);
                    ctx.fill();
                }

            } else if (gameState === 'achievements') {
                // ============================================
                // ACHIEVEMENTS PAGE
                // ============================================
                resetClickables();
                ctx.fillStyle = DS.colors.bgOverlay;
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // Header with back button
                const header = drawHeader('ACHIEVEMENTS', true);
                addClickable(header.backBounds);

                const centerX = canvas.width / 2;
                let contentY = header.height + DS.spacing.md;

                // Achievement stats summary
                const unlockedCount = unlockedAchievements.length;
                const totalCount = Object.keys(ACHIEVEMENTS).length;
                const totalBananasEarned = unlockedAchievements.reduce((sum, id) => {
                    return sum + (ACHIEVEMENTS[id]?.reward || 0);
                }, 0);

                const summaryWidth = Math.min(320, canvas.width - DS.spacing.lg * 2);
                const summaryHeight = DS.fontSize('body') * 2 + DS.spacing.lg;
                drawPanel(centerX - summaryWidth / 2, contentY, summaryWidth, summaryHeight);

                ctx.textAlign = 'center';
                ctx.fillStyle = DS.colors.primary;
                ctx.font = DS.font('body', 'bold');
                ctx.fillText(`${unlockedCount} / ${totalCount} Unlocked`, centerX, contentY + DS.spacing.md + DS.fontSize('body') / 2);

                ctx.fillStyle = DS.colors.success;
                ctx.font = DS.font('small');
                ctx.fillText(`+${totalBananasEarned} bananas earned from achievements`, centerX, contentY + DS.spacing.md + DS.fontSize('body') + DS.spacing.sm);
                contentY += summaryHeight + DS.spacing.md;

                // Check Achievements button
                const checkBtnWidth = Math.min(200, canvas.width - DS.spacing.lg * 2);
                const checkBtnHeight = 40;
                const checkBtnText = isCheckingAchievements ? 'CHECKING...' : 'CHECK ACHIEVEMENTS';
                const checkBtnBounds = drawStyledButton(
                    centerX, contentY + checkBtnHeight / 2,
                    checkBtnWidth, checkBtnHeight,
                    checkBtnText,
                    { action: 'check_achievements', primary: false, disabled: isCheckingAchievements }
                );
                if (!isCheckingAchievements) {
                    addClickable(checkBtnBounds);
                }
                contentY += checkBtnHeight + DS.spacing.sm;

                // Show result of last check
                if (lastAchievementCheckResult) {
                    ctx.textAlign = 'center';
                    if (lastAchievementCheckResult.unlocked > 0) {
                        ctx.fillStyle = DS.colors.success;
                        ctx.font = DS.font('small', 'bold');
                        ctx.fillText(
                            `Unlocked ${lastAchievementCheckResult.unlocked} achievement${lastAchievementCheckResult.unlocked > 1 ? 's' : ''}! +${lastAchievementCheckResult.newRewards} bananas`,
                            centerX, contentY
                        );
                    } else {
                        ctx.fillStyle = DS.colors.textMuted;
                        ctx.font = DS.font('small');
                        ctx.fillText('All achievements up to date', centerX, contentY);
                    }
                    contentY += DS.fontSize('small') + DS.spacing.sm;
                }

                // Scrollable achievements list
                const scrollAreaTop = contentY;
                const scrollAreaBottom = canvas.height - DS.spacing.md;
                const scrollAreaHeight = scrollAreaBottom - scrollAreaTop;

                // Calculate total content height
                const rowHeight = 60;
                const sectionHeaderHeight = 30;
                let totalContentHeight = 0;

                // Count content height by category
                const sortedCategories = Object.entries(ACHIEVEMENT_CATEGORIES)
                    .sort((a, b) => a[1].order - b[1].order);

                for (const [categoryId, category] of sortedCategories) {
                    const categoryAchievements = Object.entries(ACHIEVEMENTS)
                        .filter(([id, ach]) => ach.category === categoryId);
                    if (categoryAchievements.length > 0) {
                        totalContentHeight += sectionHeaderHeight + categoryAchievements.length * rowHeight;
                    }
                }

                achievementsScrollMax = Math.max(0, totalContentHeight - scrollAreaHeight + DS.spacing.lg);

                // Clamp scroll
                achievementsScrollY = Math.max(0, Math.min(achievementsScrollMax, achievementsScrollY));

                // Create clipping region for scroll area
                ctx.save();
                ctx.beginPath();
                ctx.rect(0, scrollAreaTop, canvas.width, scrollAreaHeight);
                ctx.clip();

                // Draw achievements by category
                let drawY = scrollAreaTop - achievementsScrollY;
                const cardPadding = DS.spacing.sm;
                const cardWidth = Math.min(450, canvas.width - DS.spacing.lg * 2);

                for (const [categoryId, category] of sortedCategories) {
                    const categoryAchievements = Object.entries(ACHIEVEMENTS)
                        .filter(([id, ach]) => ach.category === categoryId);

                    if (categoryAchievements.length === 0) continue;

                    // Category header
                    if (drawY + sectionHeaderHeight > scrollAreaTop - 50 && drawY < scrollAreaBottom + 50) {
                        ctx.fillStyle = DS.colors.textMuted;
                        ctx.font = DS.font('small', 'bold');
                        ctx.textAlign = 'left';
                        ctx.fillText(category.name.toUpperCase(), centerX - cardWidth / 2, drawY + sectionHeaderHeight / 2 + DS.fontSize('small') / 3);
                    }
                    drawY += sectionHeaderHeight;

                    // Draw each achievement
                    for (const [achId, achievement] of categoryAchievements) {
                        if (drawY + rowHeight > scrollAreaTop - 50 && drawY < scrollAreaBottom + 50) {
                            const isUnlocked = unlockedAchievements.includes(achId);
                            const cardX = centerX - cardWidth / 2;
                            const cardY = drawY;

                            // Card background
                            ctx.fillStyle = isUnlocked ? 'rgba(76, 175, 80, 0.15)' : DS.colors.bgPanel;
                            ctx.beginPath();
                            ctx.roundRect(cardX, cardY, cardWidth, rowHeight - 4, 6);
                            ctx.fill();

                            // Left side - status indicator
                            const indicatorX = cardX + 20;
                            const indicatorY = cardY + (rowHeight - 4) / 2;

                            if (isUnlocked) {
                                ctx.fillStyle = DS.colors.success;
                                ctx.font = 'bold 18px monospace';
                                ctx.textAlign = 'center';
                                ctx.fillText('âœ“', indicatorX, indicatorY + 6);
                            } else {
                                ctx.strokeStyle = DS.colors.textMuted;
                                ctx.lineWidth = 2;
                                ctx.beginPath();
                                ctx.arc(indicatorX, indicatorY, 10, 0, Math.PI * 2);
                                ctx.stroke();
                            }

                            // Achievement name
                            ctx.fillStyle = isUnlocked ? DS.colors.white : DS.colors.textSecondary;
                            ctx.font = DS.font('body', 'bold');
                            ctx.textAlign = 'left';
                            ctx.fillText(achievement.name, cardX + 45, cardY + 22);

                            // Achievement description
                            ctx.fillStyle = isUnlocked ? DS.colors.textSecondary : DS.colors.textMuted;
                            ctx.font = DS.font('small');
                            ctx.fillText(achievement.description, cardX + 45, cardY + 42);

                            // Reward on right side
                            ctx.fillStyle = isUnlocked ? DS.colors.primary : DS.colors.textMuted;
                            ctx.font = DS.font('body', 'bold');
                            ctx.textAlign = 'right';
                            ctx.fillText(`+${achievement.reward}`, cardX + cardWidth - 15, cardY + (rowHeight - 4) / 2 + 6);
                        }
                        drawY += rowHeight;
                    }
                }

                ctx.restore();

                // Draw scroll indicator if needed
                if (achievementsScrollMax > 0) {
                    const scrollTrackHeight = scrollAreaHeight - 20;
                    const scrollThumbHeight = Math.max(30, scrollTrackHeight * (scrollAreaHeight / (totalContentHeight + scrollAreaHeight)));
                    const scrollThumbY = scrollAreaTop + 10 + (scrollTrackHeight - scrollThumbHeight) * (achievementsScrollY / achievementsScrollMax);

                    // Track
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
                    ctx.fillRect(canvas.width - 8, scrollAreaTop + 10, 4, scrollTrackHeight);

                    // Thumb
                    ctx.fillStyle = DS.colors.primary;
                    ctx.beginPath();
                    ctx.roundRect(canvas.width - 8, scrollThumbY, 4, scrollThumbHeight, 2);
                    ctx.fill();
                }

            } else if (gameState === 'multiplayer-menu') {
                // Multiplayer menu - Create or Join options
                resetClickables();
                ctx.fillStyle = DS.colors.bgOverlay;
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                const header = drawHeader('MULTIPLAYER', true);
                addClickable(header.backBounds);

                const centerX = canvas.width / 2;
                let y = header.height + DS.spacing.xl * 2;

                // Title
                ctx.textAlign = 'center';
                ctx.fillStyle = DS.colors.white;
                ctx.font = DS.font('h2', 'bold');
                ctx.fillText('Choose an option', centerX, y);
                y += DS.fontSize('h2') + DS.spacing.xl;

                const btnWidth = Math.min(280, canvas.width - DS.spacing.lg * 2);
                const btnHeight = DS.button.height();

                // Create Lobby button
                const createBounds = drawStyledButton(centerX, y, btnWidth, btnHeight, 'CREATE LOBBY', { action: 'create_lobby', primary: true });
                addClickable(createBounds);
                y += btnHeight + DS.spacing.sm;

                ctx.fillStyle = DS.colors.textMuted;
                ctx.font = DS.font('small');
                ctx.fillText('Start a new game and invite friends', centerX, y);
                y += DS.fontSize('small') + DS.spacing.xl;

                // Join Lobby button
                const joinBounds = drawStyledButton(centerX, y, btnWidth, btnHeight, 'JOIN LOBBY', { action: 'show_join', primary: false });
                addClickable(joinBounds);
                y += btnHeight + DS.spacing.sm;

                ctx.fillStyle = DS.colors.textMuted;
                ctx.font = DS.font('small');
                ctx.fillText('Enter a code to join a friend\'s game', centerX, y);

            } else if (gameState === 'join-lobby') {
                // Join lobby screen with code input
                resetClickables();
                ctx.fillStyle = DS.colors.bgOverlay;
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                const header = drawHeader('JOIN LOBBY', true);
                addClickable({ ...header.backBounds, action: 'back_to_mp_menu' });

                const centerX = canvas.width / 2;
                let y = header.height + DS.spacing.xl * 2;

                // Instructions
                ctx.textAlign = 'center';
                ctx.fillStyle = DS.colors.white;
                ctx.font = DS.font('body');
                ctx.fillText('Enter the lobby word (tap to type)', centerX, y);
                y += DS.fontSize('body') + DS.spacing.lg;

                // Code input display (styled as a panel) - clickable to focus hidden input
                const inputWidth = 200;
                const inputHeight = 60;
                drawPanel(centerX, y, inputWidth, inputHeight, { centered: true });

                ctx.fillStyle = lobbyCodeInput ? DS.colors.primary : DS.colors.textMuted;
                ctx.font = DS.font('h2', 'bold');
                ctx.fillText(lobbyCodeInput || '______', centerX, y + inputHeight / 2 + DS.fontSize('h2') / 3);

                // Add clickable area for the input panel to focus native keyboard
                addClickable({
                    x: centerX - inputWidth / 2,
                    y: y,
                    w: inputWidth,
                    h: inputHeight,
                    action: 'focus_code_input'
                });
                y += inputHeight + DS.spacing.md;

                // Error message
                if (lobbyJoinError) {
                    ctx.fillStyle = DS.colors.error || '#E53935';
                    ctx.font = DS.font('small');
                    ctx.fillText(lobbyJoinError, centerX, y);
                    y += DS.fontSize('small') + DS.spacing.md;
                } else {
                    y += DS.spacing.md;
                }

                // Virtual keyboard for code input (letters only - no numbers needed for word codes)
                const keySize = Math.min(40, (canvas.width - DS.spacing.lg * 2) / 10);
                const keyGap = 4;
                const keys = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'; // Letters only
                const keysPerRow = 9;

                y += DS.spacing.md;
                for (let i = 0; i < keys.length; i++) {
                    const row = Math.floor(i / keysPerRow);
                    const col = i % keysPerRow;
                    const rowWidth = Math.min(keysPerRow, keys.length - row * keysPerRow) * (keySize + keyGap) - keyGap;
                    const startX = centerX - rowWidth / 2;
                    const keyX = startX + col * (keySize + keyGap);
                    const keyY = y + row * (keySize + keyGap);

                    // Draw key
                    ctx.fillStyle = DS.colors.bgPanel;
                    ctx.fillRect(keyX, keyY, keySize, keySize);
                    ctx.strokeStyle = DS.colors.border;
                    ctx.lineWidth = 1;
                    ctx.strokeRect(keyX, keyY, keySize, keySize);

                    ctx.fillStyle = DS.colors.white;
                    ctx.font = DS.font('body', 'bold');
                    ctx.fillText(keys[i], keyX + keySize / 2, keyY + keySize / 2 + DS.fontSize('body') / 3);

                    // Add clickable for key
                    addClickable({ x: keyX, y: keyY, w: keySize, h: keySize, action: `key_${keys[i]}` });
                }

                const numRows = Math.ceil(keys.length / keysPerRow);
                y += numRows * (keySize + keyGap) + DS.spacing.lg;

                // Backspace and Join buttons
                const btnWidth = Math.min(120, canvas.width / 3);
                const btnHeight = DS.button.height();

                const backspaceBounds = drawStyledButton(centerX - btnWidth / 2 - DS.spacing.sm, y, btnWidth, btnHeight, 'â† DELETE', { action: 'key_backspace', primary: false });
                addClickable(backspaceBounds);

                const joinBounds = drawStyledButton(centerX + btnWidth / 2 + DS.spacing.sm, y, btnWidth, btnHeight, 'JOIN', { action: 'join_with_code', primary: true });
                addClickable(joinBounds);

            } else if (gameState === 'lobby') {
                // Lobby screen
                resetClickables();
                ctx.fillStyle = DS.colors.bgOverlay;
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // Header with back button
                const header = drawHeader('MULTIPLAYER LOBBY', true);
                addClickable({ ...header.backBounds, action: 'leave_lobby' });

                const centerX = canvas.width / 2;
                let contentY = header.height + DS.spacing.lg;

                if (currentLobby) {
                    // Lobby code panel
                    const codePanelWidth = Math.min(300, canvas.width - DS.spacing.xl * 2);
                    const codePanelHeight = DS.fontSize('body') + DS.fontSize('h2') + DS.spacing.lg * 2;
                    drawPanel(centerX, contentY, codePanelWidth, codePanelHeight, { centered: true });

                    ctx.textAlign = 'center';
                    ctx.fillStyle = DS.colors.textSecondary;
                    ctx.font = DS.font('small');
                    ctx.fillText('Lobby Code', centerX, contentY + DS.spacing.md + DS.fontSize('small') / 2);
                    ctx.fillStyle = DS.colors.primary;
                    ctx.font = DS.font('h2', 'bold');
                    ctx.fillText(currentLobby.code, centerX, contentY + DS.spacing.md + DS.fontSize('small') + DS.spacing.sm + DS.fontSize('h2') / 2);
                    contentY += codePanelHeight + DS.spacing.md;

                    // Land info
                    ctx.fillStyle = DS.colors.textMuted;
                    ctx.font = DS.font('small');
                    ctx.fillText(`Land: ${lands[selectedLand].name}`, centerX, contentY);
                    contentY += DS.fontSize('small') + DS.spacing.lg;

                    // Players section with count
                    contentY = drawSectionTitle(`PLAYERS (${lobbyPlayers.length}/${MAX_LOBBY_PLAYERS})`, contentY);

                    const playerRowHeight = Math.max(40, DS.fontSize('body') + DS.spacing.md);
                    // Sort players by join order (host first)
                    const sortedPlayers = [...lobbyPlayers].sort((a, b) => {
                        // Host always first
                        if (a.player_id === currentLobby.host_id) return -1;
                        if (b.player_id === currentLobby.host_id) return 1;
                        // Then by joined_at
                        return new Date(a.joined_at) - new Date(b.joined_at);
                    });

                    sortedPlayers.forEach((p, i) => {
                        const y = contentY + i * playerRowHeight;
                        const isMe = currentUser && p.player_id === currentUser.id;
                        const isHost = p.player_id === currentLobby.host_id;
                        const username = p.profiles?.username || 'Player';

                        // Player number and name
                        ctx.fillStyle = isMe ? DS.colors.primary : DS.colors.white;
                        ctx.font = DS.font('body', isMe ? 'bold' : 'normal');
                        ctx.textAlign = 'left';
                        const displayName = `${i + 1}. ${username}${isMe ? ' (You)' : ''}`;
                        ctx.fillText(displayName, centerX - 100, y + playerRowHeight / 2);

                        // Show host badge
                        if (isHost) {
                            ctx.fillStyle = DS.colors.primary;
                            ctx.font = DS.font('small', 'bold');
                            ctx.textAlign = 'right';
                            ctx.fillText('HOST', centerX + 100, y + playerRowHeight / 2);
                        }
                    });
                    contentY += sortedPlayers.length * playerRowHeight + DS.spacing.md;

                    // Status message
                    ctx.textAlign = 'center';
                    if (lobbyPlayers.length < 2) {
                        ctx.fillStyle = DS.colors.textMuted;
                        ctx.font = DS.font('body');
                        ctx.fillText('Waiting for players to join...', centerX, contentY);
                        ctx.font = DS.font('small');
                        ctx.fillText('Share the lobby code above!', centerX, contentY + DS.fontSize('body') + DS.spacing.xs);
                    } else if (!isLobbyHost) {
                        ctx.fillStyle = DS.colors.textSecondary;
                        ctx.font = DS.font('body');
                        ctx.fillText('Waiting for host to start...', centerX, contentY);
                    }

                    // Buttons
                    const btnWidth = Math.min(220, canvas.width - DS.spacing.xl * 2);
                    const btnHeight = DS.button.height();
                    const btnY = canvas.height - DS.spacing.xl - btnHeight * 2 - DS.spacing.md;

                    // Host sees START GAME, others see nothing (just waiting)
                    if (isLobbyHost) {
                        const canStart = lobbyPlayers.length >= 2;
                        const startBounds = drawStyledButton(centerX, btnY, btnWidth, btnHeight, 'START GAME', {
                            action: canStart ? 'start_game' : null,
                            primary: canStart,
                            disabled: !canStart
                        });
                        if (canStart) {
                            addClickable(startBounds);
                        }
                    }

                    const leaveBounds = drawStyledButton(centerX, btnY + btnHeight + DS.spacing.md, btnWidth, btnHeight, 'LEAVE LOBBY', { action: 'leave_lobby', primary: false });
                    addClickable(leaveBounds);

                    // Instructions at bottom
                    ctx.fillStyle = DS.colors.textMuted;
                    ctx.font = DS.font('small');
                    ctx.textAlign = 'center';
                    if (isLobbyHost && lobbyPlayers.length >= 2) {
                        ctx.fillStyle = DS.colors.success;
                        ctx.fillText('Ready to start! Click START GAME', centerX, canvas.height - DS.spacing.md);
                    }
                } else {
                    ctx.fillStyle = DS.colors.textSecondary;
                    ctx.font = DS.font('body');
                    ctx.textAlign = 'center';
                    ctx.fillText('Creating lobby...', centerX, canvas.height / 2);
                }

            } else if (gameState === 'playing') {
                // Apply screen shake effect
                ctx.save();
                if (screenShakeIntensity > 0.5) {
                    const shakeX = (Math.random() - 0.5) * screenShakeIntensity * 2;
                    const shakeY = (Math.random() - 0.5) * screenShakeIntensity * 2;
                    ctx.translate(shakeX, shakeY);
                    screenShakeIntensity *= screenShakeDecay;
                }

                // Draw background announcement (behind everything)
                drawAnnouncement();

                // Draw entities first (behind players) - with accessibility outlines
                entities.forEach(ent => {
                    if (!ent || !ent.pixels) return; // Skip malformed entities
                    if (ent.type === 'obstacle') {
                        drawSpriteWithOutline(ctx, ent.x, ent.y, ent.pixels, ent.scale, ent.colors, DS.colors.outlineObstacle, 1);
                    } else if (ent.type === 'banana') {
                        drawSpriteWithOutline(ctx, ent.x, ent.y, ent.pixels, ent.scale, ent.colors, DS.colors.outlineCollectible, 1);
                    } else if (ent.type === 'powerup') {
                        // Power-ups get a gold/cyan outline for visibility
                        const powerUpOutline = '#FFD700'; // Gold outline for all power-ups
                        drawSpriteWithOutline(ctx, ent.x, ent.y, ent.pixels, ent.scale, ent.colors, powerUpOutline, 1);

                        // Draw text label above power-up bubble
                        const labelMap = {
                            'jetpack': 'JETPACK',
                            'trex': 'STOMP',
                            'bubble': 'SHIELD',
                            'pogo': 'POGO',
                            'lion': 'LION',
                            'turtle': 'SLOW',
                            'star': 'STAR',
                            'money': '2X PTS',
                            'laser': 'LASER',
                            'bodyDouble': 'DOUBLE'
                        };
                        const label = labelMap[ent.powerupType] || 'POWER';
                        const labelX = ent.x + (48 * ent.scale) / 2;
                        const labelY = ent.y - 12;

                        // Background pill for label - white with transparency
                        ctx.font = 'bold 14px monospace';
                        const textWidth = ctx.measureText(label).width;
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.85)';
                        ctx.beginPath();
                        ctx.roundRect(labelX - textWidth / 2 - 8, labelY - 14, textWidth + 16, 20, 10);
                        ctx.fill();

                        // Subtle border for better visibility
                        ctx.strokeStyle = 'rgba(0, 0, 0, 0.3)';
                        ctx.lineWidth = 1;
                        ctx.stroke();

                        // Label text - dark for contrast on white bg
                        ctx.fillStyle = '#222222';
                        ctx.textAlign = 'center';
                        ctx.fillText(label, labelX, labelY);
                    } else {
                        drawSprite(ctx, ent.x, ent.y, ent.pixels, ent.scale, ent.colors);
                    }
                });

                // In multiplayer, draw all players
                if (gameMode === 'multiplayer') {
                    // Update local player state for rendering
                    if (allPlayersStates[currentUser?.id]) {
                        allPlayersStates[currentUser.id].yOffset = player.y - player.groundY;
                        allPlayersStates[currentUser.id].score = score;
                        allPlayersStates[currentUser.id].bananas = bananasCollected;
                    }

                    // Draw all players (sorted by x position so front players overlap back)
                    const playersToDraw = Object.values(allPlayersStates)
                        .sort((a, b) => a.x - b.x);

                    // Get local ground position for rendering
                    const localGroundY = player.groundY;

                    playersToDraw.forEach(p => {
                        const isLocal = p.id === currentUser?.id;
                        // For local player, use actual position
                        // For remote players, calculate from local ground + their offset
                        const yPos = isLocal ? player.y : (localGroundY + (p.yOffset || 0));

                        // Get the player's skin
                        const playerSkinId = isLocal ? selectedSkin : (p.skin || 'default');
                        const playerSkin = SKINS[playerSkinId];

                        // Ghost players are semi-transparent, skin transparency also applies
                        let alpha = 1;
                        if (!p.isAlive) alpha = 0.4;
                        else if (playerSkin?.transparency) alpha = playerSkin.transparency;
                        ctx.globalAlpha = alpha;

                        // Draw player sprite with skin colors, costume overlay, and accessibility outline
                        const playerSkinColors = getSkinColors(land.runnerColors, playerSkinId);
                        drawSpriteWithOutlinePlayer(ctx, p.x, yPos, land.runner, player.scale, playerSkinColors, DS.colors.outlinePlayer, 1, playerSkin);

                        // Draw username above player
                        ctx.globalAlpha = p.isAlive ? 1 : 0.5;
                        ctx.fillStyle = isLocal ? DS.colors.primary : DS.colors.white;
                        ctx.font = 'bold 12px monospace';
                        ctx.textAlign = 'center';
                        ctx.fillText(p.username, p.x + PLAYER_WIDTH / 2, yPos - 5);

                        // Ghost label
                        if (!p.isAlive) {
                            ctx.fillStyle = '#888';
                            ctx.font = '10px monospace';
                            ctx.fillText('GHOST', p.x + PLAYER_WIDTH / 2, yPos - 18);
                        }

                        ctx.globalAlpha = 1;
                    });

                    // Show ghost spectating message if dead
                    if (!localPlayerAlive) {
                        ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                        ctx.fillRect(0, 0, canvas.width, 40);
                        ctx.fillStyle = DS.colors.primary;
                        ctx.font = 'bold 16px monospace';
                        ctx.textAlign = 'center';
                        ctx.fillText('ðŸ‘» SPECTATING - Waiting for others to finish...', canvas.width / 2, 26);
                    }

                    // Show all player scores on the right (with bananas)
                    ctx.textAlign = 'right';
                    let scoreY = 35;
                    Object.values(allPlayersStates)
                        .sort((a, b) => b.score - a.score)
                        .forEach((p, i) => {
                            const isLocal = p.id === currentUser?.id;
                            ctx.fillStyle = isLocal ? DS.colors.primary : (p.isAlive ? '#333' : '#888');
                            ctx.font = `${isLocal ? 'bold ' : ''}14px monospace`;
                            const status = p.isAlive ? '' : ' ðŸ‘»';
                            // Show score and banana count
                            ctx.fillText(`${p.username}: ${p.score} (ðŸŒ${p.bananas || 0})${status}`, canvas.width - 20, scoreY);
                            scoreY += 20;
                        });
                } else {
                    // Solo mode - draw single player with skin colors and accessibility outline

                    // BODY DOUBLE: Render ghost duplicate and energy beam
                    if (bodyDoubleActive) {
                        const doubleX = player.x + BODY_DOUBLE_OFFSET_X;
                        const doubleY = bodyDoubleY;

                        // Draw wiggly energy beam connecting player to double
                        ctx.save();
                        ctx.strokeStyle = '#4DD0E1';
                        ctx.lineWidth = 3;
                        ctx.shadowColor = '#00BCD4';
                        ctx.shadowBlur = 10;
                        ctx.globalAlpha = 0.7;

                        ctx.beginPath();
                        ctx.moveTo(player.x + PLAYER_WIDTH, player.y + PLAYER_HEIGHT / 2);

                        // Wiggly bezier curve with animated wave
                        const midX = player.x + PLAYER_WIDTH + BODY_DOUBLE_OFFSET_X / 2;
                        const waveOffset = Math.sin(gameTime * 0.3) * 8;
                        ctx.bezierCurveTo(
                            midX, player.y + PLAYER_HEIGHT / 2 + waveOffset,
                            midX, doubleY + PLAYER_HEIGHT / 2 - waveOffset,
                            doubleX, doubleY + PLAYER_HEIGHT / 2
                        );
                        ctx.stroke();
                        ctx.restore();

                        // Draw ghosted double sprite
                        ctx.save();
                        ctx.globalAlpha = 0.5;

                        if (trexActive) {
                            // Draw T-Rex double
                            const trexWidth = sprites.trex[0].length;
                            const trexHeight = sprites.trex.length;
                            const playerWidth = 32;
                            const trexDoubleX = doubleX - ((trexWidth - playerWidth) / 2) * player.scale;
                            const trexDoubleY = player.groundY + (48 * player.scale) - (trexHeight * player.scale);
                            drawSpriteWithOutline(ctx, trexDoubleX, trexDoubleY, sprites.trex, player.scale, colors.trex, '#00BCD4', 1);
                        } else {
                            // Draw normal player double with cyan tint
                            const doubleColors = getSkinColors(land.runnerColors, selectedSkin);
                            const doubleSkin = SKINS[selectedSkin];
                            drawSpriteWithOutlinePlayer(ctx, doubleX, doubleY, land.runner, player.scale, doubleColors, '#00BCD4', 1, doubleSkin);
                        }

                        // Cyan energy overlay on double (follows sprite shape)
                        ctx.globalAlpha = 0.35;
                        const doublePixels = land.runner;
                        for (let row = 0; row < doublePixels.length; row++) {
                            for (let col = 0; col < doublePixels[row].length; col++) {
                                if (doublePixels[row][col] !== 0) {
                                    ctx.fillStyle = '#00BCD4';
                                    ctx.fillRect(
                                        doubleX + col * player.scale,
                                        doubleY + row * player.scale,
                                        player.scale,
                                        player.scale
                                    );
                                }
                            }
                        }
                        ctx.restore();

                        // If double has destructive power-ups, render their effects too
                        const doubleCenterX = doubleX + PLAYER_WIDTH / 2;
                        const doubleCenterY = doubleY + PLAYER_HEIGHT / 2;

                        // LASER on double (ghosted)
                        if (laserActive) {
                            ctx.save();
                            ctx.globalAlpha = 0.4;
                            const beamCount = 8;
                            const beamLength = 300;
                            for (let i = 0; i < beamCount; i++) {
                                const angle = laserAngle + (i * Math.PI * 2 / beamCount);
                                const endX = doubleCenterX + Math.cos(angle) * beamLength;
                                const endY = doubleCenterY + Math.sin(angle) * beamLength;
                                const gradient = ctx.createLinearGradient(doubleCenterX, doubleCenterY, endX, endY);
                                gradient.addColorStop(0, 'rgba(0, 188, 212, 0.7)');
                                gradient.addColorStop(1, 'rgba(0, 188, 212, 0)');
                                ctx.strokeStyle = gradient;
                                ctx.lineWidth = 3;
                                ctx.beginPath();
                                ctx.moveTo(doubleCenterX, doubleCenterY);
                                ctx.lineTo(endX, endY);
                                ctx.stroke();
                            }
                            ctx.restore();
                        }

                        // STAR on double (ghosted)
                        if (starActive) {
                            ctx.save();
                            ctx.globalAlpha = 0.4;
                            ctx.strokeStyle = '#00BCD4';
                            ctx.lineWidth = 3;
                            ctx.shadowColor = '#00BCD4';
                            ctx.shadowBlur = 15;
                            ctx.beginPath();
                            ctx.arc(doubleCenterX, doubleCenterY, 35, 0, Math.PI * 2);
                            ctx.stroke();
                            ctx.restore();
                        }
                    }

                    // DINO FOOTPRINTS: Draw elongated dino steps above player head
                    if (dinoFootprints.length > 0) {
                        dinoFootprints.forEach(fp => {
                            const alpha = fp.timer / DINO_FOOT_DURATION;
                            ctx.save();
                            ctx.globalAlpha = alpha * 0.8;

                            const footX = fp.x;
                            const footY = fp.y;
                            const mirror = fp.isLeft ? -1 : 1;

                            // Elongated dino step - larger, more dramatic
                            // Main elongated heel pad
                            ctx.fillStyle = '#5D4037'; // Brown
                            ctx.beginPath();
                            ctx.ellipse(footX, footY + 8, 12, 18, 0, 0, Math.PI * 2);
                            ctx.fill();

                            // Three elongated toes spreading outward
                            ctx.fillStyle = '#4E342E'; // Darker brown for toes
                            // Center toe (longest)
                            ctx.beginPath();
                            ctx.ellipse(footX, footY - 18, 5, 14, 0, 0, Math.PI * 2);
                            ctx.fill();
                            // Left toe
                            ctx.beginPath();
                            ctx.ellipse(footX - 10 * mirror, footY - 12, 4, 12, -0.4 * mirror, 0, Math.PI * 2);
                            ctx.fill();
                            // Right toe
                            ctx.beginPath();
                            ctx.ellipse(footX + 10 * mirror, footY - 12, 4, 12, 0.4 * mirror, 0, Math.PI * 2);
                            ctx.fill();

                            // Add claw tips
                            ctx.fillStyle = '#3E2723'; // Very dark brown
                            ctx.beginPath();
                            ctx.ellipse(footX, footY - 32, 3, 5, 0, 0, Math.PI * 2);
                            ctx.fill();
                            ctx.beginPath();
                            ctx.ellipse(footX - 12 * mirror, footY - 22, 2, 4, -0.4 * mirror, 0, Math.PI * 2);
                            ctx.fill();
                            ctx.beginPath();
                            ctx.ellipse(footX + 12 * mirror, footY - 22, 2, 4, 0.4 * mirror, 0, Math.PI * 2);
                            ctx.fill();

                            ctx.restore();
                        });
                    }

                    if (trexActive) {
                        // Draw T-Rex sprite when transformed
                        // T-Rex is 48px wide, player is 32px wide - center the T-Rex on player position
                        const trexWidth = sprites.trex[0].length; // 48
                        const trexHeight = sprites.trex.length; // 48
                        const playerWidth = 32;
                        const trexX = player.x - ((trexWidth - playerWidth) / 2) * player.scale;
                        // Align T-Rex feet with where player's feet would be
                        const trexY = player.groundY + (48 * player.scale) - (trexHeight * player.scale);
                        drawSpriteWithOutline(ctx, trexX, trexY, sprites.trex, player.scale, colors.trex, DS.colors.outlinePlayer, 1);
                    } else {
                        // Normal player
                        const soloPlayerColors = getSkinColors(land.runnerColors, selectedSkin);
                        // Apply transparency for ghost skin
                        const soloSkin = SKINS[selectedSkin];
                        if (soloSkin?.transparency) {
                            ctx.globalAlpha = soloSkin.transparency;
                        }
                        drawSpriteWithOutlinePlayer(ctx, player.x, player.y, land.runner, player.scale, soloPlayerColors, DS.colors.outlinePlayer, 1, soloSkin);
                        ctx.globalAlpha = 1;
                    }

                    // ========== POWER-UP VISUAL EFFECTS ==========
                    const playerCenterX = player.x + PLAYER_WIDTH / 2;
                    const playerCenterY = player.y + PLAYER_HEIGHT / 2;

                    // STAR: Rainbow glow ring around player
                    if (starActive) {
                        ctx.save();
                        ctx.strokeStyle = RAINBOW_COLORS[Math.floor(starColorIndex)];
                        ctx.lineWidth = 4;
                        ctx.shadowColor = RAINBOW_COLORS[Math.floor(starColorIndex)];
                        ctx.shadowBlur = 15;
                        ctx.beginPath();
                        ctx.arc(playerCenterX, playerCenterY, 35, 0, Math.PI * 2);
                        ctx.stroke();
                        // Inner white forcefield
                        ctx.strokeStyle = 'rgba(255, 255, 255, 0.6)';
                        ctx.lineWidth = 2;
                        ctx.shadowBlur = 8;
                        ctx.shadowColor = '#FFFFFF';
                        ctx.beginPath();
                        ctx.arc(playerCenterX, playerCenterY, 28, 0, Math.PI * 2);
                        ctx.stroke();
                        ctx.restore();
                    }

                    // BUBBLE: Cyan shield rings (one per bubble, concentric)
                    if (bubbleShieldCount > 0) {
                        ctx.save();
                        ctx.strokeStyle = '#00BCD4';
                        ctx.lineWidth = 2;
                        ctx.shadowColor = '#00BCD4';
                        ctx.shadowBlur = 8;
                        for (let b = 0; b < Math.min(bubbleShieldCount, 3); b++) {
                            ctx.beginPath();
                            ctx.arc(playerCenterX, playerCenterY, 30 + (b * 8), 0, Math.PI * 2);
                            ctx.stroke();
                        }
                        ctx.restore();
                    }

                    // TURTLE: Green tint overlay following player shape
                    if (turtleActive && !trexActive) {
                        ctx.save();
                        ctx.globalAlpha = 0.35;
                        // Draw green overlay matching player sprite shape
                        const turtlePixels = land.runner;
                        const turtleScale = player.scale;
                        for (let row = 0; row < turtlePixels.length; row++) {
                            for (let col = 0; col < turtlePixels[row].length; col++) {
                                if (turtlePixels[row][col] !== 0) {
                                    ctx.fillStyle = '#009688'; // Teal color
                                    ctx.fillRect(
                                        player.x + col * turtleScale,
                                        player.y + row * turtleScale,
                                        turtleScale,
                                        turtleScale
                                    );
                                }
                            }
                        }
                        ctx.restore();
                    }

                    // POGO: Orange spring indicator at feet (visual, not particles)
                    if (pogoStickCount > 0 && player.jumping) {
                        ctx.save();
                        ctx.strokeStyle = '#FF5722';
                        ctx.lineWidth = 3;
                        ctx.shadowColor = '#FF9800';
                        ctx.shadowBlur = 5;
                        // Draw spring coils at feet
                        const springY = player.y + PLAYER_HEIGHT;
                        const springX = player.x + PLAYER_WIDTH / 2;
                        ctx.beginPath();
                        for (let i = 0; i < 3; i++) {
                            ctx.moveTo(springX - 8, springY + i * 4);
                            ctx.lineTo(springX + 8, springY + i * 4 + 2);
                        }
                        ctx.stroke();
                        ctx.restore();
                    }

                    // LASER: Disco ball spinning laser beams
                    if (laserActive) {
                        ctx.save();
                        const beamCount = 8; // Number of laser beams
                        const beamLength = 300; // How far beams reach (matches collision check)
                        const beamWidth = 3;

                        for (let i = 0; i < beamCount; i++) {
                            const angle = laserAngle + (i * Math.PI * 2 / beamCount);
                            const endX = playerCenterX + Math.cos(angle) * beamLength;
                            const endY = playerCenterY + Math.sin(angle) * beamLength;

                            // Create gradient for beam
                            const gradient = ctx.createLinearGradient(playerCenterX, playerCenterY, endX, endY);
                            gradient.addColorStop(0, 'rgba(244, 67, 54, 0.9)');
                            gradient.addColorStop(0.5, 'rgba(233, 30, 99, 0.7)');
                            gradient.addColorStop(1, 'rgba(244, 67, 54, 0)');

                            ctx.strokeStyle = gradient;
                            ctx.lineWidth = beamWidth;
                            ctx.shadowColor = '#F44336';
                            ctx.shadowBlur = 10;
                            ctx.beginPath();
                            ctx.moveTo(playerCenterX, playerCenterY);
                            ctx.lineTo(endX, endY);
                            ctx.stroke();
                        }

                        // Central eye glow
                        ctx.fillStyle = 'rgba(244, 67, 54, 0.8)';
                        ctx.shadowColor = '#F44336';
                        ctx.shadowBlur = 20;
                        ctx.beginPath();
                        ctx.arc(playerCenterX, playerCenterY - 10, 8, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.restore();
                    }

                    // LION ROAR: Growing emoji animation
                    if (lionEmojiActive) {
                        const alpha = lionEmojiTimer / LION_EMOJI_DURATION;
                        ctx.save();
                        ctx.globalAlpha = alpha;
                        ctx.font = `${32 * lionEmojiScale}px Arial`;
                        ctx.textAlign = 'center';
                        ctx.fillText('ðŸ¦', playerCenterX, player.y - 20 * lionEmojiScale);
                        ctx.restore();
                    }

                    // TURTLE TIME: Growing emoji animation
                    if (turtleEmojiActive) {
                        const alpha = turtleEmojiTimer / TURTLE_EMOJI_DURATION;
                        ctx.save();
                        ctx.globalAlpha = alpha;
                        ctx.font = `${32 * turtleEmojiScale}px Arial`;
                        ctx.textAlign = 'center';
                        ctx.fillText('ðŸ¢', playerCenterX, player.y - 20 * turtleEmojiScale);
                        ctx.restore();
                    }
                }

                // Draw particle effects (behind UI, after player)
                drawParticles();

                // Draw floating score texts
                drawFloatingTexts();

                // Draw local scores (left side)
                ctx.fillStyle = '#000';
                ctx.font = 'bold 28px monospace';
                ctx.textAlign = 'left';
                ctx.fillText(`Score: ${score}`, 20, 35);
                ctx.fillText(`Bananas: ${bananasCollected}`, 20, 70);

                // Draw jetpack timer if active (right of player)
                if (jetpackActive) {
                    const timerX = player.x + PLAYER_WIDTH + 15;
                    const timerY = player.y + PLAYER_HEIGHT / 2;
                    const secondsLeft = Math.ceil(jetpackTimer / 60);

                    // Timer background pill
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                    ctx.beginPath();
                    ctx.roundRect(timerX - 5, timerY - 12, 55, 24, 12);
                    ctx.fill();

                    // Clock icon (simple)
                    ctx.fillStyle = '#FFEB3B';
                    ctx.font = 'bold 14px monospace';
                    ctx.textAlign = 'left';
                    ctx.fillText('â±', timerX, timerY + 5);

                    // Timer countdown
                    ctx.fillStyle = '#FFFFFF';
                    ctx.font = 'bold 16px monospace';
                    ctx.fillText(`${secondsLeft}s`, timerX + 20, timerY + 5);
                }

                // Draw T-Rex timer if active (right of player)
                if (trexActive) {
                    const timerX = player.x + PLAYER_WIDTH + 50; // Further right for larger T-Rex
                    const timerY = player.groundY - 20;
                    const secondsLeft = Math.ceil(trexTimer / 60);

                    // Timer background pill
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                    ctx.beginPath();
                    ctx.roundRect(timerX - 5, timerY - 12, 55, 24, 12);
                    ctx.fill();

                    // Dino icon
                    ctx.fillStyle = '#4CAF50';
                    ctx.font = 'bold 14px monospace';
                    ctx.textAlign = 'left';
                    ctx.fillText('ðŸ¦–', timerX, timerY + 5);

                    // Timer countdown
                    ctx.fillStyle = '#FFFFFF';
                    ctx.font = 'bold 16px monospace';
                    ctx.fillText(`${secondsLeft}s`, timerX + 20, timerY + 5);
                }

                // Draw Turtle timer if active
                if (turtleActive) {
                    const timerX = player.x + PLAYER_WIDTH + 15;
                    const timerY = player.y - 30;
                    const secondsLeft = Math.ceil(turtleTimer / 60);

                    ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                    ctx.beginPath();
                    ctx.roundRect(timerX - 5, timerY - 12, 55, 24, 12);
                    ctx.fill();

                    ctx.fillStyle = '#009688';
                    ctx.font = 'bold 14px monospace';
                    ctx.textAlign = 'left';
                    ctx.fillText('ðŸ¢', timerX, timerY + 5);

                    ctx.fillStyle = '#FFFFFF';
                    ctx.font = 'bold 16px monospace';
                    ctx.fillText(`${secondsLeft}s`, timerX + 20, timerY + 5);
                }

                // Draw Star timer if active
                if (starActive) {
                    const timerX = player.x + PLAYER_WIDTH + 15;
                    const timerY = player.y - 60;
                    const secondsLeft = Math.ceil(starTimer / 60);

                    ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                    ctx.beginPath();
                    ctx.roundRect(timerX - 5, timerY - 12, 55, 24, 12);
                    ctx.fill();

                    ctx.fillStyle = '#FFD700';
                    ctx.font = 'bold 14px monospace';
                    ctx.textAlign = 'left';
                    ctx.fillText('â­', timerX, timerY + 5);

                    ctx.fillStyle = '#FFFFFF';
                    ctx.font = 'bold 16px monospace';
                    ctx.fillText(`${secondsLeft}s`, timerX + 20, timerY + 5);
                }

                // Draw Money timer if active (double points)
                if (moneyActive) {
                    const timerX = player.x + PLAYER_WIDTH + 15;
                    const timerY = player.y - 90;
                    const secondsLeft = Math.ceil(moneyTimer / 60);

                    ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                    ctx.beginPath();
                    ctx.roundRect(timerX - 5, timerY - 12, 55, 24, 12);
                    ctx.fill();

                    ctx.fillStyle = '#4CAF50';
                    ctx.font = 'bold 14px monospace';
                    ctx.textAlign = 'left';
                    ctx.fillText('ðŸ’°', timerX, timerY + 5);

                    ctx.fillStyle = '#FFFFFF';
                    ctx.font = 'bold 16px monospace';
                    ctx.fillText(`${secondsLeft}s`, timerX + 20, timerY + 5);
                }

                // Draw Laser timer if active (disco destruction)
                if (laserActive) {
                    const timerX = player.x + PLAYER_WIDTH + 15;
                    const timerY = player.y - 120;
                    const secondsLeft = Math.ceil(laserTimer / 60);

                    ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                    ctx.beginPath();
                    ctx.roundRect(timerX - 5, timerY - 12, 55, 24, 12);
                    ctx.fill();

                    ctx.fillStyle = '#F44336';
                    ctx.font = 'bold 14px monospace';
                    ctx.textAlign = 'left';
                    ctx.fillText('ðŸ‘ï¸', timerX, timerY + 5);

                    ctx.fillStyle = '#FFFFFF';
                    ctx.font = 'bold 16px monospace';
                    ctx.fillText(`${secondsLeft}s`, timerX + 20, timerY + 5);
                }

                // ========== PERMANENT BUFF INDICATORS (top left, below score) ==========
                let buffY = 95;
                const buffX = 20;

                // Bubble Shield indicator (only 1 at a time)
                if (bubbleShieldCount > 0) {
                    ctx.fillStyle = 'rgba(0, 188, 212, 0.9)';
                    ctx.font = 'bold 18px monospace';
                    ctx.textAlign = 'left';
                    ctx.fillText('ðŸ«§ SHIELD', buffX, buffY);
                    buffY += 25;
                }

                // Pogo Stick indicator (only 1 at a time)
                if (pogoStickCount > 0) {
                    ctx.fillStyle = 'rgba(255, 87, 34, 0.9)';
                    ctx.font = 'bold 18px monospace';
                    ctx.textAlign = 'left';
                    ctx.fillText('ðŸ¦˜ POGO', buffX, buffY);
                    buffY += 25;
                }

                // Lion Roar indicator (shows if obstacles are shrunk)
                if (obstaclesShrunk) {
                    ctx.fillStyle = 'rgba(255, 193, 7, 0.9)';
                    ctx.font = 'bold 18px monospace';
                    ctx.textAlign = 'left';
                    ctx.fillText('ðŸ¦ SMALL', buffX, buffY);
                    buffY += 25;
                }

                // Show current land
                ctx.fillStyle = '#666';
                ctx.font = '18px monospace';
                ctx.textAlign = 'right';
                if (gameMode !== 'multiplayer') {
                    ctx.fillText(land.name, canvas.width - 20, 35);
                }

                // Restore from screen shake
                ctx.restore();

            } else if (gameState === 'gameover') {
                // Draw player and entities frozen with skin colors, overlay, and accessibility outlines
                const gameoverPlayerColors = getSkinColors(land.runnerColors, selectedSkin);
                const gameoverSkin = SKINS[selectedSkin];
                drawSpriteWithOutlinePlayer(ctx, player.x, player.y, land.runner, player.scale, gameoverPlayerColors, DS.colors.outlinePlayer, 1, gameoverSkin);
                entities.forEach(ent => {
                    if (ent.type === 'obstacle') {
                        drawSpriteWithOutline(ctx, ent.x, ent.y, ent.pixels, ent.scale, ent.colors, DS.colors.outlineObstacle, 1);
                    } else if (ent.type === 'banana') {
                        drawSpriteWithOutline(ctx, ent.x, ent.y, ent.pixels, ent.scale, ent.colors, DS.colors.outlineCollectible, 1);
                    } else if (ent.type === 'powerup') {
                        const powerUpOutline = '#FFD700';
                        drawSpriteWithOutline(ctx, ent.x, ent.y, ent.pixels, ent.scale, ent.colors, powerUpOutline, 1);
                    } else {
                        drawSprite(ctx, ent.x, ent.y, ent.pixels, ent.scale, ent.colors);
                    }
                });

                // Dark overlay
                resetClickables();
                ctx.fillStyle = DS.colors.bgOverlay;
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                const centerX = canvas.width / 2;
                let y = canvas.height * 0.15;
                ctx.textAlign = 'center';

                // Show multiplayer result
                if (gameMode === 'multiplayer' && gameResult) {
                    const resultColors = { win: DS.colors.success, lose: DS.colors.error, tie: DS.colors.primary };
                    const resultText = { win: 'YOU WIN!', lose: 'YOU LOSE!', tie: 'TIE GAME!' };

                    ctx.fillStyle = resultColors[gameResult];
                    ctx.font = DS.font('h1', 'bold');
                    ctx.fillText(resultText[gameResult], centerX, y);
                    y += DS.fontSize('h1') + DS.spacing.lg;

                    ctx.fillStyle = DS.colors.white;
                    ctx.font = DS.font('h3', 'bold');
                    ctx.fillText(`Your Score: ${score}`, centerX, y);
                    y += DS.fontSize('h3') + DS.spacing.md;

                    ctx.fillStyle = DS.colors.error;
                    ctx.fillText(`Opponent: ${opponentScore}`, centerX, y);
                    y += DS.fontSize('h3') + DS.spacing.lg;
                } else {
                    ctx.fillStyle = DS.colors.white;
                    ctx.font = DS.font('h1', 'bold');
                    ctx.fillText('Game Over', centerX, y);
                    y += DS.fontSize('h1') + DS.spacing.md;

                    // Your score panel
                    const panelWidth = Math.min(340, canvas.width - DS.spacing.lg * 2);
                    const yourScorePanelHeight = DS.fontSize('h2') + DS.fontSize('small') + DS.spacing.lg;
                    drawPanel(centerX, y, panelWidth, yourScorePanelHeight, { centered: true });

                    ctx.fillStyle = DS.colors.primary;
                    ctx.font = DS.font('h2', 'bold');
                    ctx.fillText(score.toString(), centerX, y + DS.spacing.md + DS.fontSize('h2') / 2);

                    ctx.fillStyle = DS.colors.textSecondary;
                    ctx.font = DS.font('small');
                    ctx.fillText(`${bananasCollected} bananas collected`, centerX, y + DS.spacing.md + DS.fontSize('h2') + DS.spacing.xs);
                    y += yourScorePanelHeight + DS.spacing.md;

                    // New high score notification
                    if (currentUser && userProfile && score > (userProfile.high_score || 0)) {
                        ctx.fillStyle = DS.colors.primary;
                        ctx.font = DS.font('body', 'bold');
                        ctx.fillText('NEW PERSONAL BEST!', centerX, y);
                        y += DS.fontSize('body') + DS.spacing.sm;
                    }

                    // Stats comparison section
                    if (!gameOverStats.loading && supabaseClient) {
                        const statsRowHeight = DS.fontSize('small') + DS.spacing.sm;
                        const statsPanelHeight = statsRowHeight * 3 + DS.spacing.md * 2;
                        const currentLandName = lands[selectedLand].name;

                        y += DS.spacing.sm;
                        drawPanel(centerX, y, panelWidth, statsPanelHeight, { centered: true });

                        const statsX = centerX - panelWidth / 2 + DS.spacing.md;
                        const statsRightX = centerX + panelWidth / 2 - DS.spacing.md;
                        let statsY = y + DS.spacing.md + statsRowHeight / 2;

                        // Global top score
                        ctx.textAlign = 'left';
                        ctx.fillStyle = DS.colors.textSecondary;
                        ctx.font = DS.font('small');
                        ctx.fillText('Global Best', statsX, statsY);
                        ctx.textAlign = 'right';
                        if (gameOverStats.isNewGlobalBest) {
                            ctx.fillStyle = DS.colors.success;
                            ctx.font = DS.font('small', 'bold');
                            ctx.fillText('NEW RECORD!', statsRightX, statsY);
                        } else if (gameOverStats.globalTopScore !== null) {
                            ctx.fillStyle = DS.colors.white;
                            ctx.font = DS.font('small', 'bold');
                            ctx.fillText(`${gameOverStats.globalTopScore} by ${gameOverStats.globalTopPlayer}`, statsRightX, statsY);
                        }
                        statsY += statsRowHeight;

                        // Biome top score
                        ctx.textAlign = 'left';
                        ctx.fillStyle = DS.colors.textSecondary;
                        ctx.font = DS.font('small');
                        ctx.fillText(`${currentLandName} Best`, statsX, statsY);
                        ctx.textAlign = 'right';
                        if (gameOverStats.biomeTopScore !== null) {
                            const isNewBiomeRecord = score > gameOverStats.biomeTopScore;
                            if (isNewBiomeRecord) {
                                ctx.fillStyle = DS.colors.success;
                                ctx.font = DS.font('small', 'bold');
                                ctx.fillText('NEW RECORD!', statsRightX, statsY);
                            } else {
                                ctx.fillStyle = DS.colors.white;
                                ctx.font = DS.font('small', 'bold');
                                ctx.fillText(`${gameOverStats.biomeTopScore} by ${gameOverStats.biomeTopPlayer}`, statsRightX, statsY);
                            }
                        } else {
                            ctx.fillStyle = DS.colors.success;
                            ctx.font = DS.font('small', 'bold');
                            ctx.fillText('FIRST SCORE!', statsRightX, statsY);
                        }
                        statsY += statsRowHeight;

                        // Personal biome best
                        if (currentUser) {
                            ctx.textAlign = 'left';
                            ctx.fillStyle = DS.colors.textSecondary;
                            ctx.font = DS.font('small');
                            ctx.fillText(`Your ${currentLandName} Best`, statsX, statsY);
                            ctx.textAlign = 'right';
                            if (gameOverStats.isNewBiomeBest) {
                                ctx.fillStyle = DS.colors.success;
                                ctx.font = DS.font('small', 'bold');
                                ctx.fillText('NEW!', statsRightX, statsY);
                            } else if (gameOverStats.personalBiomeBest !== null) {
                                ctx.fillStyle = DS.colors.white;
                                ctx.font = DS.font('small', 'bold');
                                ctx.fillText(gameOverStats.personalBiomeBest.toString(), statsRightX, statsY);
                            }
                        }

                        y += statsPanelHeight + DS.spacing.md;
                    } else if (gameOverStats.loading) {
                        ctx.fillStyle = DS.colors.textMuted;
                        ctx.font = DS.font('small');
                        ctx.textAlign = 'center';
                        ctx.fillText('Loading stats...', centerX, y + DS.spacing.md);
                        y += DS.fontSize('small') + DS.spacing.lg;
                    }
                }

                // Land selection instruction
                ctx.textAlign = 'center';
                y = drawSectionTitle('SELECT LAND & TAP TO PLAY', y);
                drawLandButtons(y, false);
                y += Math.max(44, Math.round(canvas.width * 0.055)) + DS.spacing.lg; // Land button height + spacing

                // Back to menu button
                const menuBtnWidth = Math.min(180, canvas.width - DS.spacing.xl * 2);
                const menuBtnHeight = Math.max(40, DS.button.height() * 0.8);
                const menuBtnBounds = drawStyledButton(centerX, y, menuBtnWidth, menuBtnHeight, 'MENU', { action: 'back', primary: false });
                addClickable(menuBtnBounds);

            } else if (gameState === 'multiplayer-results') {
                // Multiplayer round results screen
                resetClickables();
                ctx.fillStyle = DS.colors.bgOverlay;
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                const centerX = canvas.width / 2;
                let y = DS.spacing.xl;

                // Title
                ctx.textAlign = 'center';
                ctx.fillStyle = DS.colors.primary;
                ctx.font = DS.font('h1', 'bold');
                ctx.fillText('ROUND OVER', centerX, y + DS.fontSize('h1'));
                y += DS.fontSize('h1') + DS.spacing.lg;

                // Result message
                if (gameResult === 'win') {
                    ctx.fillStyle = DS.colors.success;
                    ctx.font = DS.font('h2', 'bold');
                    ctx.fillText('ðŸ† YOU WON!', centerX, y + DS.fontSize('h2'));
                } else {
                    ctx.fillStyle = DS.colors.error;
                    ctx.font = DS.font('h2', 'bold');
                    ctx.fillText('Better luck next time!', centerX, y + DS.fontSize('h2'));
                }
                y += DS.fontSize('h2') + DS.spacing.xl;

                // Leaderboard panel
                const panelWidth = Math.min(400, canvas.width - DS.spacing.lg * 2);
                const results = Object.values(allPlayersStates)
                    .sort((a, b) => b.score - a.score);
                const rowHeight = 36;
                const panelHeight = rowHeight * (results.length + 1) + DS.spacing.lg * 2;

                drawPanel(centerX, y, panelWidth, panelHeight, { centered: true });

                // Header row
                const tableStartY = y + DS.spacing.lg;
                const panelLeft = centerX - panelWidth / 2;
                const colRank = panelLeft + DS.spacing.md;
                const colPlayer = panelLeft + DS.spacing.xl * 1.5;
                const colScore = panelLeft + panelWidth - DS.spacing.lg - 60;
                const colBananas = panelLeft + panelWidth - DS.spacing.md;

                ctx.fillStyle = DS.colors.textMuted;
                ctx.font = DS.font('small', 'bold');
                ctx.textAlign = 'left';
                ctx.fillText('#', colRank, tableStartY + rowHeight / 2);
                ctx.fillText('PLAYER', colPlayer, tableStartY + rowHeight / 2);
                ctx.textAlign = 'right';
                ctx.fillText('SCORE', colScore, tableStartY + rowHeight / 2);
                ctx.fillText('ðŸŒ', colBananas, tableStartY + rowHeight / 2);

                // Player rows
                results.forEach((p, i) => {
                    const rowY = tableStartY + (i + 1) * rowHeight + rowHeight / 2;
                    const isLocal = p.id === currentUser?.id;
                    const medal = i === 0 ? 'ðŸ¥‡' : (i === 1 ? 'ðŸ¥ˆ' : (i === 2 ? 'ðŸ¥‰' : ''));

                    ctx.fillStyle = isLocal ? DS.colors.primary : DS.colors.white;
                    ctx.font = DS.font('body', isLocal ? 'bold' : 'normal');
                    ctx.textAlign = 'left';
                    ctx.fillText(`${medal || (i + 1)}`, colRank, rowY);
                    ctx.fillText(p.username + (isLocal ? ' (You)' : ''), colPlayer, rowY);
                    ctx.textAlign = 'right';
                    ctx.fillText(p.score.toString(), colScore, rowY);
                    ctx.fillText(p.bananas.toString(), colBananas, rowY);
                });

                y += panelHeight + DS.spacing.xl;

                // Buttons - Play Again is prominent, Leave is minor
                const btnWidth = Math.min(220, canvas.width - DS.spacing.xl * 2);
                const btnHeight = DS.button.height();

                if (isLobbyHost) {
                    // Large prominent PLAY AGAIN button for host
                    const playAgainBounds = drawStyledButton(centerX, y, btnWidth, btnHeight * 1.2, 'PLAY AGAIN', { action: 'play_again', primary: true });
                    addClickable(playAgainBounds);
                    y += btnHeight * 1.2 + DS.spacing.xl;
                } else {
                    ctx.fillStyle = DS.colors.textMuted;
                    ctx.font = DS.font('body');
                    ctx.fillText('Waiting for host to start next round...', centerX, y + DS.fontSize('body') / 2);
                    y += DS.fontSize('body') + DS.spacing.xl;
                }

                // Minor text-link style "leave" option
                ctx.fillStyle = DS.colors.textMuted;
                ctx.font = DS.font('small');
                const leaveText = 'Leave Lobby';
                const leaveWidth = ctx.measureText(leaveText).width + 20;
                const leaveHeight = DS.fontSize('small') + 16;
                const leaveX = centerX - leaveWidth / 2;
                const leaveY = y;
                ctx.fillText(leaveText, centerX, leaveY + leaveHeight / 2 + 2);

                // Add subtle underline
                const textWidth = ctx.measureText(leaveText).width;
                ctx.beginPath();
                ctx.moveTo(centerX - textWidth / 2, leaveY + leaveHeight / 2 + 6);
                ctx.lineTo(centerX + textWidth / 2, leaveY + leaveHeight / 2 + 6);
                ctx.strokeStyle = DS.colors.textMuted;
                ctx.lineWidth = 1;
                ctx.stroke();

                addClickable({ x: leaveX, y: leaveY, w: leaveWidth, h: leaveHeight, action: 'leave_results' });
            }

            // Draw notifications on top of everything
            drawNotifications();

            ctx.textAlign = 'left';
        }

        // Game loop
        // Update shop scroll momentum
        function updateShopScroll() {
            if (gameState !== 'shop') return;

            // Apply momentum when not dragging
            if (!shopDragging && Math.abs(shopScrollVel) > 0.1) {
                shopScrollY += shopScrollVel;
                shopScrollY = Math.max(0, Math.min(shopScrollMax, shopScrollY));
                shopScrollVel *= 0.92;  // Friction
            } else if (!shopDragging) {
                shopScrollVel = 0;
            }
        }

        // Delta time tracking for frame-rate independent gameplay
        let lastFrameTime = performance.now();
        const TARGET_FRAME_TIME = 1000 / 60; // 60fps = 16.67ms per frame

        function gameLoop(currentTime) {
            try {
                // Calculate delta time and normalize to 60fps
                const deltaTime = currentTime - lastFrameTime;
                lastFrameTime = currentTime;

                // Delta multiplier: 1.0 at 60fps, 0.5 at 120fps, 2.0 at 30fps
                // Clamped to prevent extreme values on tab switch or lag spikes
                const delta = Math.min(Math.max(deltaTime / TARGET_FRAME_TIME, 0.1), 3);

                update(delta);
                updateShopScroll();
                draw();
            } catch (err) {
                console.error('Game loop error:', err);
            }
            requestAnimationFrame(gameLoop);
        }

        // Start the game
        requestAnimationFrame(gameLoop);
    </script>
</body>
</html>