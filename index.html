<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Banana Runner</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: #000;
            font-family: monospace;
        }
        canvas {
            display: block;
            background: #FAFAFA;
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
        }
        /* Auth Modal Styles */
        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            z-index: 1000;
            justify-content: center;
            align-items: center;
            cursor: pointer;
        }
        .modal-overlay.active {
            display: flex;
        }
        .auth-modal {
            background: #1a1a2e;
            border: 3px solid #FFE135;
            border-radius: 12px;
            padding: 30px;
            max-width: 400px;
            width: 90%;
            box-shadow: 0 0 30px rgba(255, 225, 53, 0.3);
            cursor: default;
        }
        .auth-modal h2 {
            color: #FFE135;
            text-align: center;
            margin-bottom: 25px;
            font-size: 28px;
        }
        .auth-modal input {
            width: 100%;
            padding: 12px;
            margin-bottom: 15px;
            background: #16213e;
            border: 2px solid #444;
            border-radius: 6px;
            color: #fff;
            font-family: monospace;
            font-size: 16px;
            box-sizing: border-box;
        }
        .auth-modal input:focus {
            outline: none;
            border-color: #FFE135;
        }
        .auth-modal button {
            width: 100%;
            padding: 14px;
            margin-bottom: 10px;
            background: #FFE135;
            border: none;
            border-radius: 6px;
            color: #000;
            font-family: monospace;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            transition: transform 0.1s, background 0.2s;
        }
        .auth-modal button:hover {
            background: #FFC107;
            transform: scale(1.02);
        }
        .auth-modal button.secondary {
            background: transparent;
            border: 2px solid #666;
            color: #aaa;
        }
        .auth-modal button.secondary:hover {
            border-color: #FFE135;
            color: #FFE135;
        }
        .auth-modal .toggle-text {
            text-align: center;
            color: #888;
            margin-top: 15px;
        }
        .auth-modal .toggle-text a {
            color: #FFE135;
            cursor: pointer;
            text-decoration: underline;
        }
        .auth-modal .error-msg {
            color: #ff6b6b;
            text-align: center;
            margin-bottom: 15px;
            min-height: 20px;
        }
        .auth-modal .success-msg {
            color: #4CAF50;
            text-align: center;
            margin-bottom: 15px;
        }
        .user-info {
            position: fixed;
            top: 10px;
            right: 10px;
            color: #fff;
            font-family: monospace;
            font-size: 14px;
            z-index: 100;
            text-align: right;
        }
        .user-info .username {
            color: #FFE135;
            font-weight: bold;
        }
        .user-info .logout-btn {
            color: #888;
            cursor: pointer;
            margin-left: 10px;
        }
        .user-info .logout-btn:hover {
            color: #ff6b6b;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>

    <!-- User Info Display -->
    <div id="userInfo" class="user-info" style="display: none;">
        <span class="username" id="displayUsername"></span>
        <span class="logout-btn" onclick="logout()">[Logout]</span>
    </div>

    <!-- Auth Modal -->
    <div id="authModal" class="modal-overlay">
        <div class="auth-modal">
            <h2 id="authTitle">Sign Up</h2>
            <div id="authError" class="error-msg"></div>
            <div id="authSuccess" class="success-msg" style="display: none;"></div>
            <form id="authForm">
                <input type="text" id="authUsername" placeholder="Username" autocomplete="username" required>
                <input type="password" id="authPassword" placeholder="Password" autocomplete="current-password" required>
                <button type="submit" id="authSubmit">Create Account</button>
            </form>
            <div class="toggle-text" id="authToggle">
                Already have an account? <a onclick="toggleAuthMode()">Login</a>
            </div>
        </div>
    </div>

    <!-- Supabase SDK -->
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>

    <script type="module">
        // ============================================
        // MODULE IMPORTS
        // ============================================

        // Core configuration
        import {
            SUPABASE_URL,
            SUPABASE_ANON_KEY,
            PLAYER_SCALE,
            ENTITY_SCALE,
            BANANA_HEIGHT_OFFSET,
            JUMP_BUFFER_MS,
            INITIAL_SPEED,
            JUMP_VELOCITY,
            GRAVITY,
            SPAWN_INTERVAL,
            BANANA_SPAWN_CHANCE,
            BANANA_POINTS,
            GROUND_HEIGHT_RATIO,
            GAME_STATES,
            GAME_MODES
        } from './src/core/config.js';

        // Design system
        import { createDesignSystem } from './src/core/designSystem.js';

        // Utilities
        import {
            drawSprite as drawSpriteUtil,
            pointInBounds as pointInBoundsUtil,
            clamp,
            lerp,
            randomInt
        } from './src/core/utils.js';

        // UI Components (available for future use)
        import { createUIComponents } from './src/ui/components.js';

        // Click handling (available for future use)
        import { createClickManager, createInputHandler } from './src/ui/clickHandler.js';

        // Services
        import { createAuthService, usernameToEmail as authUsernameToEmail, validateUsername } from './src/services/auth.js';
        import { createDatabaseService } from './src/services/database.js';
        import { createMultiplayerService } from './src/services/multiplayer.js';

        // ============================================
        // CANVAS SETUP
        // ============================================
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        ctx.imageSmoothingEnabled = false;

        // Initialize design system bound to canvas
        const DS = createDesignSystem(canvas);

        // ============================================
        // UI COMPONENTS
        // ============================================

        // Navigation stack for back button
        let navigationStack = [];

        function navigateTo(screen, addToStack = true) {
            if (addToStack && gameState !== 'welcome' && gameState !== 'playing') {
                navigationStack.push(gameState);
            }
            gameState = screen;
        }

        function navigateBack() {
            if (navigationStack.length > 0) {
                gameState = navigationStack.pop();
            } else {
                gameState = 'menu';
            }
        }

        // Draw a styled button - returns bounds for click detection
        function drawStyledButton(x, y, width, height, label, options = {}) {
            const {
                primary = true,
                disabled = false,
                centered = true
            } = options;

            const actualX = centered ? x - width / 2 : x;
            const actualY = y;

            // Background
            if (disabled) {
                ctx.fillStyle = DS.colors.locked;
            } else if (primary) {
                ctx.fillStyle = DS.colors.primary;
            } else {
                ctx.fillStyle = 'transparent';
                ctx.strokeStyle = DS.colors.primary;
                ctx.lineWidth = 2;
            }

            // Draw rounded rect
            const r = DS.button.radius;
            ctx.beginPath();
            ctx.roundRect(actualX, actualY, width, height, r);
            if (primary || disabled) {
                ctx.fill();
            } else {
                ctx.stroke();
            }

            // Text
            ctx.fillStyle = primary ? DS.colors.bgDark : DS.colors.primary;
            if (disabled) ctx.fillStyle = DS.colors.textMuted;
            ctx.font = DS.font('body', 'bold');
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(label, actualX + width / 2, actualY + height / 2);

            // Return bounds for click detection
            return { x: actualX, y: actualY, w: width, h: height, action: options.action || label };
        }

        // Draw header with title and optional back button
        function drawHeader(title, showBack = true) {
            const height = DS.header.height();

            // Background
            ctx.fillStyle = DS.colors.bgOverlay;
            ctx.fillRect(0, 0, canvas.width, height);

            // Bottom border
            ctx.strokeStyle = DS.colors.primary;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(0, height);
            ctx.lineTo(canvas.width, height);
            ctx.stroke();

            // Back button
            let backBounds = null;
            if (showBack) {
                const backSize = height - DS.spacing.lg;
                const backX = DS.spacing.md;
                const backY = (height - backSize) / 2;

                ctx.fillStyle = DS.colors.primary;
                ctx.font = DS.font('h3', 'bold');
                ctx.textAlign = 'left';
                ctx.textBaseline = 'middle';
                ctx.fillText('â†', backX, height / 2);

                backBounds = { x: 0, y: 0, w: height, h: height, action: 'back' };
            }

            // Title
            ctx.fillStyle = DS.colors.white;
            ctx.font = DS.font('h3', 'bold');
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(title, canvas.width / 2, height / 2);

            return { height, backBounds };
        }

        // Draw a panel/card
        function drawPanel(x, y, width, height, options = {}) {
            const { centered = false, title = null } = options;
            const actualX = centered ? x - width / 2 : x;

            // Background
            ctx.fillStyle = DS.colors.bgPanel;
            ctx.beginPath();
            ctx.roundRect(actualX, y, width, height, 12);
            ctx.fill();

            // Border
            ctx.strokeStyle = DS.colors.primary;
            ctx.lineWidth = 2;
            ctx.stroke();

            // Title if provided
            if (title) {
                ctx.fillStyle = DS.colors.primary;
                ctx.font = DS.font('body', 'bold');
                ctx.textAlign = 'left';
                ctx.textBaseline = 'top';
                ctx.fillText(title, actualX + DS.spacing.md, y + DS.spacing.md);
            }

            return { x: actualX, y, w: width, h: height };
        }

        // Draw section title
        function drawSectionTitle(text, y) {
            ctx.fillStyle = DS.colors.textSecondary;
            ctx.font = DS.font('small', 'bold');
            ctx.textAlign = 'center';
            ctx.textBaseline = 'top';
            ctx.fillText(text.toUpperCase(), canvas.width / 2, y);
            return y + DS.fontSize('small') + DS.spacing.sm;
        }

        // Check if point is in bounds
        function pointInBounds(px, py, bounds) {
            if (!bounds) return false;
            return px >= bounds.x && px <= bounds.x + bounds.w &&
                   py >= bounds.y && py <= bounds.y + bounds.h;
        }

        // Store clickable areas for current frame
        let clickableAreas = [];

        function resetClickables() {
            clickableAreas = [];
        }

        function addClickable(bounds) {
            if (bounds) clickableAreas.push(bounds);
        }

        // ============================================
        // SUPABASE INITIALIZATION
        // Config imported from ./src/core/config.js
        // ============================================

        // Initialize Supabase client
        let supabaseClient = null;
        let currentUser = null;
        let userProfile = null;
        let isAuthMode = 'signup'; // 'signup' or 'login' - default to signup for new users

        // Declare early to avoid temporal dead zone issues with callbacks and resize handlers
        let gameState = 'welcome';
        let player = null;
        let entities = [];
        let spawnCounter = 0;

        function initSupabase() {
            if (SUPABASE_URL !== 'YOUR_SUPABASE_URL' && typeof window.supabase !== 'undefined') {
                supabaseClient = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
                checkAuth();
            } else {
                console.log('Supabase not configured - running in guest mode');
            }
        }

        // ============================================
        // AUTHENTICATION FUNCTIONS
        // ============================================
        async function checkAuth() {
            if (!supabaseClient) return;

            const { data: { session } } = await supabaseClient.auth.getSession();
            if (session) {
                currentUser = session.user;
                // Set fallback profile immediately
                userProfile = {
                    id: currentUser.id,
                    username: currentUser.user_metadata?.username || 'Player'
                };
                await loadUserProfileWithTimeout();
                updateUserDisplay();
                // Go to menu if already logged in
                gameState = 'menu';
            }

            // Listen for auth changes (e.g., from other tabs)
            supabaseClient.auth.onAuthStateChange(async (event, session) => {
                // Skip if this is from our own signIn (already handled)
                if (event === 'SIGNED_IN' && currentUser?.id === session?.user?.id) {
                    return;
                }

                if (session) {
                    currentUser = session.user;
                    userProfile = {
                        id: currentUser.id,
                        username: currentUser.user_metadata?.username || 'Player'
                    };
                    await loadUserProfileWithTimeout();
                    updateUserDisplay();
                    if (gameState === 'welcome') {
                        gameState = 'menu';
                    }
                } else {
                    currentUser = null;
                    userProfile = null;
                    updateUserDisplay();
                    gameState = 'welcome';
                }
            });
        }

        async function loadUserProfile() {
            if (!supabaseClient || !currentUser) return;

            try {
                const { data, error } = await supabaseClient
                    .from('profiles')
                    .select('*')
                    .eq('id', currentUser.id)
                    .single();

                if (error) {
                    // Keep fallback profile that was already set
                } else if (data) {
                    userProfile = data;
                }

                // Also load skins and achievements
                await loadPlayerProgress();
            } catch (err) {
                // Keep fallback profile that was already set
            }
        }

        // Convert username to internal email format for Supabase auth
        function usernameToEmail(username) {
            return `${username.toLowerCase()}@banana-jump.local`;
        }

        async function signUp(username, password) {
            if (!supabaseClient) {
                showAuthError('Supabase not configured');
                return false;
            }

            // Validate username
            if (username.length < 3) {
                showAuthError('Username must be at least 3 characters');
                return false;
            }
            if (!/^[a-zA-Z0-9_]+$/.test(username)) {
                showAuthError('Username can only contain letters, numbers, and underscores');
                return false;
            }

            const email = usernameToEmail(username);

            const { data, error } = await supabaseClient.auth.signUp({
                email,
                password,
                options: {
                    data: { username }
                }
            });

            if (error) {
                // Make error messages more user-friendly
                if (error.message.includes('already registered')) {
                    showAuthError('Username already taken');
                } else {
                    showAuthError(error.message);
                }
                return false;
            }

            // Create profile
            if (data.user) {
                const { error: profileError } = await supabaseClient
                    .from('profiles')
                    .upsert({
                        id: data.user.id,
                        username: username
                    });

                if (profileError) {
                    console.error('Profile creation error:', profileError);
                }
            }

            // Auto-login after signup (since email confirmation is disabled)
            if (data.session && data.user) {
                // Session already exists, user is logged in
                // Set user immediately (don't wait for onAuthStateChange)
                currentUser = data.user;
                // Set a basic profile immediately (the upsert above created it)
                userProfile = { id: data.user.id, username: username };
                updateUserDisplay();
                closeAuthModal();
                return true;
            } else {
                // Manually sign in if no session returned
                const signInResult = await signIn(username, password);
                return signInResult;
            }
        }

        async function signIn(username, password) {
            if (!supabaseClient) {
                showAuthError('Supabase not configured');
                return false;
            }

            // Check if already logged in (e.g., from another tab)
            const { data: { session: existingSession } } = await supabaseClient.auth.getSession();
            if (existingSession) {
                // Already authenticated - just load profile and proceed
                currentUser = existingSession.user;
                userProfile = {
                    id: currentUser.id,
                    username: currentUser.user_metadata?.username || 'Player'
                };
                await loadUserProfileWithTimeout();
                updateUserDisplay();
                closeAuthModal();
                return true;
            }

            const email = usernameToEmail(username);

            try {
                const { data, error } = await supabaseClient.auth.signInWithPassword({
                    email,
                    password
                });

                if (error) {
                    if (error.message.includes('Invalid login')) {
                        showAuthError('Invalid username or password');
                    } else {
                        showAuthError(error.message);
                    }
                    return false;
                }

                if (data && data.user) {
                    currentUser = data.user;
                    userProfile = {
                        id: data.user.id,
                        username: data.user.user_metadata?.username || 'Player'
                    };

                    await loadUserProfileWithTimeout();
                    updateUserDisplay();
                    closeAuthModal();
                    return true;
                } else {
                    showAuthError('Login failed - please try again');
                    return false;
                }
            } catch (err) {
                console.error('SignIn error:', err);
                showAuthError('Login failed - please try again');
                return false;
            }
        }

        // Helper to load profile with timeout protection
        async function loadUserProfileWithTimeout() {
            try {
                const profilePromise = loadUserProfile();
                const timeoutPromise = new Promise((_, reject) =>
                    setTimeout(() => reject(new Error('timeout')), 5000)
                );
                await Promise.race([profilePromise, timeoutPromise]);
            } catch (err) {
                // Profile load failed/timed out, fallback profile already set
            }
        }

        async function logout() {
            if (!supabaseClient) return;

            await supabaseClient.auth.signOut();
            currentUser = null;
            userProfile = null;
            updateUserDisplay();
            gameState = 'welcome';
        }

        // ============================================
        // SCORE PERSISTENCE
        // ============================================
        async function saveScore(finalScore, bananas, landPlayed) {
            if (!supabaseClient || !currentUser) return;

            // Save to game_sessions
            const { error: sessionError } = await supabaseClient
                .from('game_sessions')
                .insert({
                    player_id: currentUser.id,
                    score: finalScore,
                    bananas_collected: bananas,
                    land_played: landPlayed,
                    game_mode: 'solo'
                });

            if (sessionError) {
                console.error('Error saving session:', sessionError);
                return;
            }

            // Update profile stats
            if (userProfile) {
                const updates = {
                    total_games: (userProfile.total_games || 0) + 1,
                    total_bananas: (userProfile.total_bananas || 0) + bananas,
                    total_score: (userProfile.total_score || 0) + finalScore
                };

                if (finalScore > (userProfile.high_score || 0)) {
                    updates.high_score = finalScore;
                }

                const { error: updateError } = await supabaseClient
                    .from('profiles')
                    .update(updates)
                    .eq('id', currentUser.id);

                if (!updateError) {
                    userProfile = { ...userProfile, ...updates };
                }
            }
        }

        async function getLeaderboard(land = null, limit = 10) {
            if (!supabaseClient) return [];

            let query = supabaseClient
                .from('leaderboard')
                .select('*')
                .order('high_score', { ascending: false })
                .limit(limit);

            if (land) {
                // Get land-specific leaderboard from game_sessions
                const { data, error } = await supabaseClient
                    .from('game_sessions')
                    .select('player_id, score, profiles!inner(username)')
                    .eq('land_played', land)
                    .order('score', { ascending: false })
                    .limit(limit);

                return data || [];
            }

            const { data, error } = await query;
            return data || [];
        }

        // Fetch stats for game over screen
        async function fetchGameOverStats(currentScore, landPlayed) {
            gameOverStats.loading = true;

            if (!supabaseClient) {
                gameOverStats.loading = false;
                return;
            }

            try {
                // Fetch global top score (from profiles - overall high score)
                const { data: globalData } = await supabaseClient
                    .from('profiles')
                    .select('username, high_score')
                    .order('high_score', { ascending: false })
                    .limit(1)
                    .single();

                if (globalData) {
                    gameOverStats.globalTopScore = globalData.high_score;
                    gameOverStats.globalTopPlayer = globalData.username;
                    gameOverStats.isNewGlobalBest = currentUser && currentScore > globalData.high_score;
                }

                // Fetch biome/land top score
                const { data: biomeData } = await supabaseClient
                    .from('game_sessions')
                    .select('score, profiles!inner(username)')
                    .eq('land_played', landPlayed)
                    .order('score', { ascending: false })
                    .limit(1)
                    .single();

                if (biomeData) {
                    gameOverStats.biomeTopScore = biomeData.score;
                    gameOverStats.biomeTopPlayer = biomeData.profiles?.username || 'Unknown';
                }

                // Fetch personal best for this biome (only if logged in)
                if (currentUser) {
                    const { data: personalData } = await supabaseClient
                        .from('game_sessions')
                        .select('score')
                        .eq('player_id', currentUser.id)
                        .eq('land_played', landPlayed)
                        .order('score', { ascending: false })
                        .limit(1)
                        .single();

                    if (personalData) {
                        // This is the previous best (before this game was saved)
                        gameOverStats.personalBiomeBest = personalData.score;
                        gameOverStats.isNewBiomeBest = currentScore > personalData.score;
                    } else {
                        // First time playing this biome
                        gameOverStats.personalBiomeBest = 0;
                        gameOverStats.isNewBiomeBest = true;
                    }
                }
            } catch (err) {
                console.error('Error fetching game over stats:', err);
            }

            gameOverStats.loading = false;
        }

        // ============================================
        // MULTIPLAYER LOBBY FUNCTIONS
        // ============================================
        async function createLobby() {
            if (!supabaseClient || !currentUser) return null;

            const lobbyCode = Math.random().toString(36).substring(2, 8).toUpperCase();

            const { data, error } = await supabaseClient
                .from('game_lobbies')
                .insert({
                    code: lobbyCode,
                    host_id: currentUser.id,
                    land: selectedLand,
                    status: 'waiting'
                })
                .select()
                .single();

            if (error) {
                console.error('Error creating lobby:', error);
                return null;
            }

            currentLobby = data;
            isLobbyHost = true;
            await joinLobbyAsPlayer(data.id);
            subscribeLobbyUpdates(data.id);
            return data;
        }

        async function findOrCreateLobby() {
            if (!supabaseClient || !currentUser) return;

            // First try to find an existing waiting lobby
            const { data: existingLobbies, error } = await supabaseClient
                .from('game_lobbies')
                .select('*')
                .eq('status', 'waiting')
                .neq('host_id', currentUser.id)
                .order('created_at', { ascending: true })
                .limit(1);

            if (existingLobbies && existingLobbies.length > 0) {
                // Join existing lobby
                currentLobby = existingLobbies[0];
                isLobbyHost = false;
                selectedLand = currentLobby.land;
                await joinLobbyAsPlayer(currentLobby.id);
                subscribeLobbyUpdates(currentLobby.id);
            } else {
                // Create new lobby
                await createLobby();
            }

            gameState = 'lobby';
        }

        async function joinLobbyAsPlayer(lobbyId) {
            if (!supabaseClient || !currentUser) return;

            const { error } = await supabaseClient
                .from('lobby_players')
                .insert({
                    lobby_id: lobbyId,
                    player_id: currentUser.id,
                    is_ready: true  // Joining = ready (no toggle needed)
                });

            if (error) {
                console.error('Error joining lobby:', error);
            }
        }

        function subscribeLobbyUpdates(lobbyId) {
            if (!supabaseClient) return;

            // Subscribe to lobby changes
            lobbySubscription = supabaseClient
                .channel(`lobby:${lobbyId}`)
                .on('postgres_changes',
                    { event: '*', schema: 'public', table: 'lobby_players', filter: `lobby_id=eq.${lobbyId}` },
                    (payload) => {
                        loadLobbyPlayers(lobbyId);
                    }
                )
                .on('postgres_changes',
                    { event: 'UPDATE', schema: 'public', table: 'game_lobbies', filter: `id=eq.${lobbyId}` },
                    (payload) => {
                        if (payload.new.status === 'playing') {
                            startMultiplayerGame();
                        }
                    }
                )
                .subscribe();

            loadLobbyPlayers(lobbyId);
        }

        async function loadLobbyPlayers(lobbyId) {
            if (!supabaseClient) return;

            const { data, error } = await supabaseClient
                .from('lobby_players')
                .select('*, profiles:player_id(username)')
                .eq('lobby_id', lobbyId)
                .order('joined_at', { ascending: true });

            if (data) {
                lobbyPlayers = data;

                // Calculate local player index for multiplayer rendering
                const myIndex = data.findIndex(p => currentUser && p.player_id === currentUser.id);
                if (myIndex !== -1) {
                    localPlayerIndex = myIndex;
                }
            }
        }

        // toggleReady is no longer needed - joining = ready
        async function toggleReady() {
            // Deprecated - kept for compatibility
            if (!supabaseClient || !currentUser || !currentLobby) return;

            const currentPlayer = lobbyPlayers.find(p => p.player_id === currentUser.id);
            if (!currentPlayer) return;

            await supabaseClient
                .from('lobby_players')
                .update({ is_ready: !currentPlayer.is_ready })
                .eq('lobby_id', currentLobby.id)
                .eq('player_id', currentUser.id);
        }

        async function startLobbyGame() {
            if (!supabaseClient || !currentLobby || !isLobbyHost) return;

            await supabaseClient
                .from('game_lobbies')
                .update({ status: 'playing' })
                .eq('id', currentLobby.id);
        }

        // Visual stagger: each player is 60px apart horizontally
        const PLAYER_STAGGER_X = 60;

        function startMultiplayerGame() {
            gameMode = 'multiplayer';
            localPlayerAlive = true;
            gameResult = null;

            // Initialize all players states from lobby
            initializeMultiplayerPlayers();

            // Start the game
            startGame();

            // Position local player based on their index (host rightmost, joiners to left)
            if (player) {
                const playerCount = lobbyPlayers.length;
                player.x = 80 + ((playerCount - 1 - localPlayerIndex) * PLAYER_STAGGER_X);
            }

            // Subscribe to game updates from all players
            if (supabaseClient && currentLobby) {
                subscribeGameUpdates();
            }
        }

        function initializeMultiplayerPlayers() {
            // Create player state objects for all lobby players
            // Position: host (index 0) is RIGHTMOST, joiners to the LEFT in join order
            const playerCount = lobbyPlayers.length;
            allPlayersStates = {};
            multiplayerPlayers = lobbyPlayers.map((lp, index) => {
                // Reverse the X position: host at right, later joiners at left
                const xPosition = 80 + ((playerCount - 1 - index) * PLAYER_STAGGER_X);
                const playerState = {
                    id: lp.player_id,
                    username: lp.profiles?.username || 'Player',
                    playerIndex: index,
                    x: xPosition,
                    y: 0,  // Will be updated
                    score: 0,
                    bananas: 0,
                    isAlive: true,
                    isLocal: lp.player_id === currentUser?.id
                };
                allPlayersStates[lp.player_id] = playerState;
                return playerState;
            });

            // Find local player index
            localPlayerIndex = multiplayerPlayers.findIndex(p => p.isLocal);
        }

        let gameChannelReady = false;

        function subscribeGameUpdates() {
            if (!supabaseClient || !currentLobby) return;

            // Clean up existing channel
            if (gameChannel) {
                supabaseClient.removeChannel(gameChannel);
                gameChannel = null;
            }
            gameChannelReady = false;

            gameChannel = supabaseClient
                .channel(`game:${currentLobby.id}`)
                .on('broadcast', { event: 'player_update' }, (payload) => {
                    const data = payload.payload;
                    if (data.playerId !== currentUser?.id) {
                        // Update remote player state
                        if (allPlayersStates[data.playerId]) {
                            allPlayersStates[data.playerId].y = data.y;
                            allPlayersStates[data.playerId].score = data.score;
                            allPlayersStates[data.playerId].bananas = data.bananas;
                            allPlayersStates[data.playerId].isAlive = data.isAlive;
                            // Debug: log received state occasionally
                            if (Math.random() < 0.02) { // ~2% of updates to reduce spam
                                console.log(`[Received] ${allPlayersStates[data.playerId].username}: score=${data.score}, bananas=${data.bananas}, alive=${data.isAlive}`);
                            }
                        }

                        // Check if all players are dead
                        checkRoundOver();
                    }
                })
                .on('broadcast', { event: 'round_over' }, (payload) => {
                    // Someone detected round is over - transition everyone
                    if (gameState === 'playing') {
                        // Update final states from payload
                        if (payload.payload?.finalStates) {
                            Object.assign(allPlayersStates, payload.payload.finalStates);
                        }
                        endMultiplayerRound();
                    }
                })
                .on('broadcast', { event: 'play_again' }, () => {
                    // Host triggered play again
                    if (gameState === 'multiplayer-results') {
                        resetMultiplayerGame();
                    }
                })
                .subscribe((status) => {
                    if (status === 'SUBSCRIBED') {
                        gameChannelReady = true;
                        // Send initial state once connected
                        broadcastPlayerState();
                    }
                });
        }

        function broadcastPlayerState() {
            if (!gameChannel || !gameChannelReady || gameMode !== 'multiplayer') return;

            gameChannel.send({
                type: 'broadcast',
                event: 'player_update',
                payload: {
                    playerId: currentUser?.id,
                    playerIndex: localPlayerIndex,
                    y: player?.y || 0,
                    score: score,
                    bananas: bananasCollected,
                    isAlive: localPlayerAlive
                }
            });
        }

        function checkRoundOver() {
            if (gameMode !== 'multiplayer' || gameState !== 'playing') return;

            // Check if all players are dead
            const allDead = Object.values(allPlayersStates).every(p => !p.isAlive);
            if (allDead) {
                // Broadcast round_over to ensure everyone transitions
                if (gameChannel && gameChannelReady) {
                    gameChannel.send({
                        type: 'broadcast',
                        event: 'round_over',
                        payload: { finalStates: allPlayersStates }
                    });
                }
                endMultiplayerRound();
            }
        }

        function endMultiplayerRound() {
            if (gameState === 'multiplayer-results') return; // Already ended

            // Determine results - sort by score descending
            const results = Object.values(allPlayersStates)
                .sort((a, b) => b.score - a.score);

            // Find local player's position
            const localResult = results.find(p => p.isLocal);
            if (localResult) {
                const position = results.indexOf(localResult);
                if (position === 0) {
                    gameResult = 'win';
                } else {
                    gameResult = 'lose';
                }
            }

            // Save score for local player
            if (currentUser && !scoreSaved) {
                scoreSaved = true;
                saveScore(score, bananasCollected, selectedLand);
            }

            gameState = 'multiplayer-results';
        }

        // Legacy function for compatibility
        function broadcastGameState(isGameOver = false) {
            broadcastPlayerState();
        }

        async function leaveLobby() {
            if (!supabaseClient || !currentLobby) {
                gameState = 'menu';
                return;
            }

            // Unsubscribe from updates
            if (lobbySubscription) {
                supabaseClient.removeChannel(lobbySubscription);
                lobbySubscription = null;
            }

            // Remove player from lobby
            await supabaseClient
                .from('lobby_players')
                .delete()
                .eq('lobby_id', currentLobby.id)
                .eq('player_id', currentUser.id);

            // If host, delete the lobby
            if (isLobbyHost) {
                await supabaseClient
                    .from('game_lobbies')
                    .delete()
                    .eq('id', currentLobby.id);
            }

            currentLobby = null;
            lobbyPlayers = [];
            isLobbyHost = false;
            gameState = 'menu';
        }

        // New multiplayer functions for Create/Join flow
        async function createNewLobby() {
            if (!supabaseClient || !currentUser) return;

            const code = generateLobbyCode();
            const { data, error } = await supabaseClient
                .from('game_lobbies')
                .insert({
                    code: code,
                    host_id: currentUser.id,
                    land: selectedLand,
                    status: 'waiting'
                })
                .select()
                .single();

            if (error) {
                console.error('Error creating lobby:', error);
                return;
            }

            currentLobby = data;
            isLobbyHost = true;
            await joinLobbyAsPlayer(currentLobby.id);
            subscribeLobbyUpdates(currentLobby.id);
            gameState = 'lobby';
        }

        function generateLobbyCode() {
            return Math.random().toString(36).substring(2, 8).toUpperCase();
        }

        async function joinLobbyWithCode() {
            if (!supabaseClient || !currentUser || !lobbyCodeInput) {
                lobbyJoinError = 'Please enter a lobby code';
                return;
            }

            const code = lobbyCodeInput.toUpperCase().trim();
            if (code.length !== 6) {
                lobbyJoinError = 'Code must be 6 characters';
                return;
            }

            // Find lobby by code
            const { data: lobby, error } = await supabaseClient
                .from('game_lobbies')
                .select('*')
                .eq('code', code)
                .eq('status', 'waiting')
                .single();

            if (error || !lobby) {
                lobbyJoinError = 'Lobby not found or game already started';
                return;
            }

            // Check if lobby is full
            const { data: players } = await supabaseClient
                .from('lobby_players')
                .select('id')
                .eq('lobby_id', lobby.id);

            if (players && players.length >= MAX_LOBBY_PLAYERS) {
                lobbyJoinError = 'Lobby is full (max 7 players)';
                return;
            }

            // Join the lobby
            currentLobby = lobby;
            isLobbyHost = false;
            selectedLand = lobby.land;
            await joinLobbyAsPlayer(currentLobby.id);
            subscribeLobbyUpdates(currentLobby.id);
            lobbyJoinError = '';
            gameState = 'lobby';
        }

        async function hostStartGame() {
            if (!supabaseClient || !currentLobby || !isLobbyHost) return;
            if (lobbyPlayers.length < 2) return;

            await supabaseClient
                .from('game_lobbies')
                .update({ status: 'playing' })
                .eq('id', currentLobby.id);
        }

        async function hostPlayAgain() {
            if (!supabaseClient || !currentLobby || !isLobbyHost) return;

            // Reset game state and broadcast to all players
            await supabaseClient
                .from('game_lobbies')
                .update({ status: 'playing' })
                .eq('id', currentLobby.id);

            // Broadcast play again signal
            if (gameChannel) {
                gameChannel.send({
                    type: 'broadcast',
                    event: 'play_again',
                    payload: { startTime: Date.now() + 1000 }
                });
            }

            // Start locally
            resetMultiplayerGame();
        }

        function leaveMultiplayerResults() {
            // Clean up and go to menu
            if (gameChannel) {
                supabaseClient.removeChannel(gameChannel);
                gameChannel = null;
            }
            if (lobbySubscription) {
                supabaseClient.removeChannel(lobbySubscription);
                lobbySubscription = null;
            }
            currentLobby = null;
            lobbyPlayers = [];
            isLobbyHost = false;
            multiplayerPlayers = [];
            allPlayersStates = {};
            gameMode = 'solo';
            gameState = 'menu';
        }

        function resetMultiplayerGame() {
            // Reset local state for new round
            localPlayerAlive = true;
            gameResult = null;
            scoreSaved = false;

            // Reinitialize all players from lobby
            initializeMultiplayerPlayers();

            // Start the game
            startGame();

            // Position local player based on their index (host rightmost, joiners to left)
            if (player) {
                const playerCount = lobbyPlayers.length;
                player.x = 80 + ((playerCount - 1 - localPlayerIndex) * PLAYER_STAGGER_X);
            }
        }

        // ============================================
        // SKINS & ACHIEVEMENTS FUNCTIONS
        // ============================================
        async function loadPlayerProgress() {
            if (!supabaseClient || !currentUser) return;

            try {
                // Load unlocked skins
                const { data: skins, error: skinsError } = await supabaseClient
                    .from('player_skins')
                    .select('skin_id')
                    .eq('player_id', currentUser.id);

                if (!skinsError && skins) {
                    unlockedSkins = ['default', ...skins.map(s => s.skin_id)];
                }

                // Load equipped skin from profile
                if (userProfile?.equipped_skin) {
                    selectedSkin = userProfile.equipped_skin;
                }

                // Load achievements
                const { data: achievements, error: achievementsError } = await supabaseClient
                    .from('player_achievements')
                    .select('achievement_id')
                    .eq('player_id', currentUser.id);

                if (!achievementsError && achievements) {
                    unlockedAchievements = achievements.map(a => a.achievement_id);
                }
            } catch (err) {
                // Continue anyway - skins/achievements are not critical
            }
        }

        async function unlockSkin(skinId) {
            if (!supabaseClient || !currentUser || unlockedSkins.includes(skinId)) return;

            const { error } = await supabaseClient
                .from('player_skins')
                .insert({ player_id: currentUser.id, skin_id: skinId });

            if (!error) {
                unlockedSkins.push(skinId);
                showNotification(`Skin Unlocked: ${SKINS[skinId].name}!`);
            }
        }

        async function unlockAchievement(achievementId) {
            if (!supabaseClient || !currentUser || unlockedAchievements.includes(achievementId)) return;

            const { error } = await supabaseClient
                .from('player_achievements')
                .insert({ player_id: currentUser.id, achievement_id: achievementId });

            if (!error) {
                unlockedAchievements.push(achievementId);
                const achievement = ACHIEVEMENTS[achievementId];
                showNotification(`${achievement.icon} Achievement: ${achievement.name}!`);
            }
        }

        async function equipSkin(skinId) {
            if (!unlockedSkins.includes(skinId)) return;

            selectedSkin = skinId;

            if (supabaseClient && currentUser) {
                await supabaseClient
                    .from('profiles')
                    .update({ equipped_skin: skinId })
                    .eq('id', currentUser.id);
            }
        }

        function checkAchievements(gameScore, gameBananas, gameTimeSeconds, isMultiplayer, didWin) {
            // Track land played
            landsPlayed.add(selectedLand);

            // First game
            if (userProfile && (userProfile.total_games || 0) >= 1) {
                unlockAchievement('first_game');
            }

            // Banana collector (50 in one game)
            if (gameBananas >= 50) {
                unlockAchievement('banana_collector');
            }

            // High scorer (10000 points)
            if (gameScore >= 10000) {
                unlockAchievement('high_scorer');
            }

            // World traveler (all 4 lands)
            if (landsPlayed.size >= 4) {
                unlockAchievement('world_traveler');
            }

            // Marathon runner (60 seconds)
            if (gameTimeSeconds >= 60) {
                unlockAchievement('marathon_runner');
            }

            // Multiplayer achievements
            if (isMultiplayer) {
                unlockAchievement('multiplayer_debut');
                if (didWin) {
                    unlockAchievement('first_win');
                }
            }

            // Check profile-based achievements
            if (userProfile) {
                if ((userProfile.total_bananas || 0) >= 500) {
                    unlockAchievement('banana_hoarder');
                }
                if ((userProfile.total_games || 0) >= 100) {
                    unlockAchievement('dedicated');
                }
            }

            // Check skin unlocks
            checkSkinUnlocks(gameScore);
        }

        function checkSkinUnlocks(gameScore) {
            if (!userProfile) return;

            // Golden - 100 total bananas
            if ((userProfile.total_bananas || 0) >= 100) {
                unlockSkin('golden');
            }

            // Speedster - 5000 points in one game
            if (gameScore >= 5000) {
                unlockSkin('speedster');
            }

            // Veteran - 50 games
            if ((userProfile.total_games || 0) >= 50) {
                unlockSkin('veteran');
            }

            // Champion - 10 multiplayer wins (would need to track this)
        }

        // Notification system
        let notifications = [];

        function showNotification(message) {
            notifications.push({
                message,
                time: Date.now(),
                opacity: 1
            });

            // Remove after 3 seconds
            setTimeout(() => {
                notifications.shift();
            }, 3000);
        }

        function drawNotifications() {
            const now = Date.now();
            notifications.forEach((notif, i) => {
                const age = now - notif.time;
                const opacity = Math.max(0, 1 - (age / 3000));

                ctx.globalAlpha = opacity;
                ctx.fillStyle = '#FFE135';
                ctx.font = 'bold 20px monospace';
                ctx.textAlign = 'center';
                ctx.fillText(notif.message, canvas.width / 2, 100 + i * 30);
                ctx.globalAlpha = 1;
            });
        }

        // ============================================
        // AUTH UI FUNCTIONS
        // ============================================
        function showAuthModal() {
            document.getElementById('authModal').classList.add('active');
            document.getElementById('authError').textContent = '';
            document.getElementById('authSuccess').style.display = 'none';
        }

        function closeAuthModal() {
            document.getElementById('authModal').classList.remove('active');
            document.getElementById('authError').textContent = '';
            document.getElementById('authSuccess').style.display = 'none';
            // Go to menu after login (only if logged in)
            if (currentUser) {
                gameState = 'menu';
            }
        }

        function toggleAuthMode() {
            isAuthMode = isAuthMode === 'login' ? 'signup' : 'login';

            const title = document.getElementById('authTitle');
            const submit = document.getElementById('authSubmit');
            const toggle = document.getElementById('authToggle');

            if (isAuthMode === 'signup') {
                title.textContent = 'Sign Up';
                submit.textContent = 'Create Account';
                toggle.innerHTML = 'Already have an account? <a onclick="toggleAuthMode()">Login</a>';
            } else {
                title.textContent = 'Login';
                submit.textContent = 'Login';
                toggle.innerHTML = 'Don\'t have an account? <a onclick="toggleAuthMode()">Sign Up</a>';
            }

            document.getElementById('authError').textContent = '';
            document.getElementById('authSuccess').style.display = 'none';
        }

        // Expose functions to global scope for HTML onclick handlers
        window.toggleAuthMode = toggleAuthMode;
        window.logout = logout;

        function showAuthError(message) {
            document.getElementById('authError').textContent = message;
            document.getElementById('authSuccess').style.display = 'none';
        }

        function showAuthSuccess(message) {
            document.getElementById('authSuccess').textContent = message;
            document.getElementById('authSuccess').style.display = 'block';
            document.getElementById('authError').textContent = '';
        }

        function updateUserDisplay() {
            const userInfo = document.getElementById('userInfo');
            const displayName = document.getElementById('displayUsername');

            if (currentUser && userProfile) {
                displayName.textContent = userProfile.username || 'Player';
                userInfo.style.display = 'block';
            } else {
                userInfo.style.display = 'none';
            }
        }

        // Auth form handler
        document.getElementById('authForm').addEventListener('submit', async (e) => {
            e.preventDefault();

            const username = document.getElementById('authUsername').value.trim();
            const password = document.getElementById('authPassword').value;

            if (!username) {
                showAuthError('Username is required');
                return;
            }

            if (isAuthMode === 'signup') {
                await signUp(username, password);
            } else {
                await signIn(username, password);
            }
        });

        // Click outside modal to close
        document.getElementById('authModal').addEventListener('click', (e) => {
            // Only close if clicking the overlay itself, not the modal content
            if (e.target.id === 'authModal') {
                closeAuthModal();
            }
        });

        // Initialize Supabase when DOM is ready
        document.addEventListener('DOMContentLoaded', initSupabase);

        // Resize canvas to fill screen
        let lastCanvasHeight = 0;

        function resizeCanvas() {
            const oldWidth = canvas.width;
            const oldHeight = canvas.height;
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            ctx.imageSmoothingEnabled = false;

            // Detect significant orientation/size change (more than 100px difference)
            const significantChange = (Math.abs(canvas.width - oldWidth) > 100 ||
                                       Math.abs(canvas.height - oldHeight) > 100);

            // Handle resize during active gameplay
            if (oldHeight > 0 && player !== null && typeof PLAYER_HEIGHT !== 'undefined') {
                const newGroundLevel = canvas.height - 70;

                // Always snap player to correct ground position
                if (!player.jumping) {
                    player.y = newGroundLevel - PLAYER_HEIGHT;
                } else {
                    // Adjust jump position proportionally
                    const oldGroundLevel = oldHeight - 70;
                    const groundDiff = newGroundLevel - oldGroundLevel;
                    player.y += groundDiff;

                    // Ensure player doesn't end up below ground
                    if (player.y > newGroundLevel - PLAYER_HEIGHT) {
                        player.y = newGroundLevel - PLAYER_HEIGHT;
                        player.jumping = false;
                        player.vy = 0;
                    }
                }

                // Reposition all entities on resize (including orientation change)
                // Entities keep their X position but Y adjusts to new ground level
                if (entities && entities.length > 0) {
                    const newGroundLevel = canvas.height - 70;
                    const widthRatio = canvas.width / oldWidth;

                    for (let i = entities.length - 1; i >= 0; i--) {
                        const ent = entities[i];
                        const entHeight = ent.pixels.length * ent.scale;

                        // Scale X position proportionally for width changes
                        if (significantChange && widthRatio !== 1) {
                            ent.x = ent.x * widthRatio;
                        }

                        // Snap to new ground level
                        if (ent.type === 'obstacle') {
                            ent.y = newGroundLevel - entHeight;
                        } else if (ent.type === 'banana') {
                            ent.y = newGroundLevel - entHeight - BANANA_HEIGHT_OFFSET;
                        }

                        // Remove entities now off-screen (but keep ones ahead)
                        if (ent.x < -100) {
                            entities.splice(i, 1);
                        }
                    }
                }
            }

            lastCanvasHeight = canvas.height;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // Dynamic constants based on screen size
        // Note: PLAYER_SCALE, ENTITY_SCALE, BANANA_HEIGHT_OFFSET imported from config.js
        function getGroundLevel() {
            return canvas.height - 70;
        }

        // High-definition pixel art sprites (32x48 runners, doubled detail)
        const sprites = {
            // Snow runner - winter hat with pom-pom, puffy jacket (32x48)
            runnerSnow: [
                [0,0,0,0,0,0,0,0,0,0,0,0,0,7,7,7,7,7,7,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,7,7,7,7,7,7,7,7,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,4,4,4,4,4,4,4,4,4,4,4,4,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,4,4,4,4,4,4,4,4,4,4,4,4,4,4,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,1,2,2,2,2,2,2,1,1,2,2,2,2,2,2,1,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,1,2,2,3,3,2,2,1,1,2,2,3,3,2,2,1,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,1,2,2,3,3,2,2,2,2,2,2,3,3,2,2,1,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,1,1,2,2,2,2,2,2,2,2,2,2,2,2,1,1,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,1,1,2,2,2,8,8,8,8,2,2,2,1,1,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,1,1,2,2,2,2,2,2,2,2,1,1,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,5,5,5,5,5,5,5,5,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,4,4,4,4,4,4,4,4,4,4,4,4,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,4,4,4,4,4,4,4,4,4,4,4,4,4,4,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,0,0,0,0,0,0],
                [0,0,0,0,0,2,2,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,2,2,0,0,0,0,0],
                [0,0,0,0,2,2,2,2,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,2,2,2,2,0,0,0,0],
                [0,0,0,0,2,2,2,0,0,4,4,4,4,4,4,4,4,4,4,4,4,4,4,0,0,2,2,2,0,0,0,0],
                [0,0,0,0,2,2,0,0,0,4,4,4,4,4,4,4,4,4,4,4,4,4,4,0,0,0,2,2,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,4,4,4,4,4,4,4,4,4,4,4,4,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,4,4,4,4,4,4,4,4,4,4,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,5,5,5,5,0,0,5,5,5,5,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,5,5,5,5,0,0,5,5,5,5,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,5,5,5,5,5,0,0,5,5,5,5,5,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,5,5,5,5,0,0,0,0,5,5,5,5,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,5,5,5,5,5,0,0,0,0,5,5,5,5,5,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,5,5,5,5,0,0,0,0,0,0,5,5,5,5,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,5,5,5,5,5,0,0,0,0,0,0,5,5,5,5,5,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,5,5,5,5,0,0,0,0,0,0,0,0,5,5,5,5,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,5,5,5,5,5,0,0,0,0,0,0,0,0,5,5,5,5,5,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,5,5,5,5,0,0,0,0,0,0,0,0,0,0,5,5,5,5,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,6,6,6,6,6,6,0,0,0,0,0,0,0,0,6,6,6,6,6,6,0,0,0,0,0,0],
                [0,0,0,0,0,0,6,6,6,6,6,6,0,0,0,0,0,0,0,0,6,6,6,6,6,6,0,0,0,0,0,0],
                [0,0,0,0,0,0,6,6,6,6,6,6,0,0,0,0,0,0,0,0,6,6,6,6,6,6,0,0,0,0,0,0],
                [0,0,0,0,0,0,6,6,6,6,6,6,0,0,0,0,0,0,0,0,6,6,6,6,6,6,0,0,0,0,0,0]
            ],
            // Desert runner - cowboy hat, vest (32x48)
            runnerDesert: [
                [0,0,0,0,0,0,0,0,0,0,0,0,4,4,4,4,4,4,4,4,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,4,4,4,4,4,4,4,4,4,4,4,4,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,4,4,4,4,4,4,4,4,4,4,4,4,4,4,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,0,0,0,0,0,0],
                [0,0,0,0,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,1,2,2,2,2,2,2,2,2,2,2,2,2,1,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,1,2,2,3,3,2,2,2,2,3,3,2,2,1,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,1,2,2,3,3,2,2,2,2,3,3,2,2,1,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,1,1,2,2,2,2,2,2,2,2,2,2,1,1,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,1,1,2,2,8,8,8,8,2,2,1,1,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,1,1,2,2,2,2,2,2,1,1,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,5,5,5,5,5,5,5,5,5,5,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,5,5,5,5,5,5,5,5,5,5,5,5,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,5,5,5,6,6,6,6,6,6,6,6,5,5,5,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,5,5,5,5,6,6,6,6,6,6,6,6,5,5,5,5,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,5,5,5,5,5,6,6,6,6,6,6,6,6,5,5,5,5,5,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,5,5,5,5,5,5,6,6,6,6,6,6,6,6,5,5,5,5,5,5,0,0,0,0,0,0],
                [0,0,0,0,0,2,2,5,5,5,5,5,6,6,6,6,6,6,6,6,5,5,5,5,5,2,2,0,0,0,0,0],
                [0,0,0,0,2,2,2,2,5,5,5,5,6,6,6,6,6,6,6,6,5,5,5,5,2,2,2,2,0,0,0,0],
                [0,0,0,0,2,2,2,0,0,5,5,5,5,5,5,5,5,5,5,5,5,5,5,0,0,2,2,2,0,0,0,0],
                [0,0,0,0,2,2,0,0,0,5,5,5,5,5,5,5,5,5,5,5,5,5,5,0,0,0,2,2,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,5,5,5,5,5,5,5,5,5,5,5,5,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,5,5,5,5,5,5,5,5,5,5,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,7,7,7,7,0,0,7,7,7,7,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,7,7,7,7,0,0,7,7,7,7,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,7,7,7,7,7,0,0,7,7,7,7,7,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,7,7,7,7,0,0,0,0,7,7,7,7,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,7,7,7,7,7,0,0,0,0,7,7,7,7,7,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,7,7,7,7,0,0,0,0,0,0,7,7,7,7,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,7,7,7,7,7,0,0,0,0,0,0,7,7,7,7,7,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,7,7,7,7,0,0,0,0,0,0,0,0,7,7,7,7,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,7,7,7,7,7,0,0,0,0,0,0,0,0,7,7,7,7,7,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,7,7,7,7,0,0,0,0,0,0,0,0,0,0,7,7,7,7,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,9,9,9,9,9,9,0,0,0,0,0,0,0,0,9,9,9,9,9,9,0,0,0,0,0,0],
                [0,0,0,0,0,0,9,9,9,9,9,9,0,0,0,0,0,0,0,0,9,9,9,9,9,9,0,0,0,0,0,0],
                [0,0,0,0,0,0,9,9,9,9,9,9,0,0,0,0,0,0,0,0,9,9,9,9,9,9,0,0,0,0,0,0],
                [0,0,0,0,0,0,9,9,9,9,9,9,0,0,0,0,0,0,0,0,9,9,9,9,9,9,0,0,0,0,0,0]
            ],
            // Jungle runner - Tarzan loincloth, bare chest (32x48)
            runnerJungle: [
                [0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,1,2,2,2,2,2,2,1,1,2,2,2,2,2,2,1,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,1,2,2,3,3,2,2,2,2,2,2,3,3,2,2,1,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,1,2,2,3,3,2,2,2,2,2,2,3,3,2,2,1,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,1,1,2,2,2,2,2,2,2,2,2,2,2,2,1,1,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,1,1,2,2,2,2,2,2,2,2,2,2,1,1,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,1,1,2,2,2,2,2,2,2,2,1,1,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,2,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,2,2,2,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,2,2,2,2,2,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,0,0,0,0,0,0],
                [0,0,0,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,0,0,0,0],
                [0,0,0,0,2,2,2,2,0,0,2,2,2,2,2,2,2,2,2,2,2,2,0,0,2,2,2,2,0,0,0,0],
                [0,0,0,0,2,2,2,0,0,0,2,2,2,2,2,2,2,2,2,2,2,2,0,0,0,2,2,2,0,0,0,0],
                [0,0,0,0,2,2,0,0,0,0,0,4,4,4,4,4,4,4,4,4,4,0,0,0,0,0,2,2,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,4,4,4,4,4,4,4,4,4,4,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,4,4,4,4,4,4,4,4,4,4,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,4,4,4,4,4,4,4,4,4,4,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,0,0,2,2,2,2,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,0,0,2,2,2,2,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,0,0,2,2,2,2,2,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,2,2,2,2,0,0,0,0,2,2,2,2,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,2,2,2,2,2,0,0,0,0,2,2,2,2,2,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,2,2,2,2,0,0,0,0,0,0,2,2,2,2,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,2,2,2,2,2,0,0,0,0,0,0,2,2,2,2,2,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,2,2,2,2,0,0,0,0,0,0,0,0,2,2,2,2,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,2,2,2,2,2,0,0,0,0,0,0,0,0,2,2,2,2,2,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,2,2,2,2,0,0,0,0,0,0,0,0,0,0,2,2,2,2,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,2,2,2,2,0,0,0,0,0,0,0,0,0,0,2,2,2,2,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,2,2,2,2,0,0,0,0,0,0,0,0,0,0,2,2,2,2,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,2,2,2,2,0,0,0,0,0,0,0,0,0,0,2,2,2,2,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,2,2,2,2,0,0,0,0,0,0,0,0,0,0,2,2,2,2,0,0,0,0,0,0,0]
            ],
            // Ocean runner - scuba helmet, wetsuit (32x48)
            runnerOcean: [
                [0,0,0,0,0,0,0,0,0,0,4,4,4,4,4,4,4,4,4,4,4,4,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,4,4,4,4,4,4,4,4,4,4,4,4,4,4,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,4,4,4,5,5,5,5,4,4,4,4,5,5,5,5,4,4,4,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,4,4,4,5,5,5,5,4,4,4,4,5,5,5,5,4,4,4,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,4,4,4,5,5,3,3,4,4,4,4,3,3,5,5,4,4,4,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,4,4,4,5,5,3,3,4,4,4,4,3,3,5,5,4,4,4,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,4,4,4,4,4,4,4,4,4,4,4,4,4,4,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,4,4,4,4,4,4,4,4,4,4,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,6,6,6,6,6,6,6,6,6,6,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,6,6,6,6,6,6,6,6,6,6,6,6,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,6,6,6,6,6,6,6,6,6,6,6,6,6,6,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,0,0,0,0,0,0],
                [0,0,0,0,0,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,0,0,0,0,0],
                [0,0,0,0,6,6,6,6,0,0,6,6,6,6,6,6,6,6,6,6,6,6,0,0,6,6,6,6,0,0,0,0],
                [0,0,0,0,6,6,6,0,0,0,6,6,6,6,6,6,6,6,6,6,6,6,0,0,0,6,6,6,0,0,0,0],
                [0,0,0,0,6,6,0,0,0,0,6,6,6,6,6,6,6,6,6,6,6,6,0,0,0,0,6,6,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,6,6,6,6,6,6,6,6,6,6,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,6,6,6,6,6,6,6,6,6,6,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,6,6,6,6,0,0,6,6,6,6,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,6,6,6,6,0,0,6,6,6,6,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,6,6,6,6,6,0,0,6,6,6,6,6,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,6,6,6,6,0,0,0,0,6,6,6,6,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,6,6,6,6,6,0,0,0,0,6,6,6,6,6,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,6,6,6,6,0,0,0,0,0,0,6,6,6,6,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,6,6,6,6,6,0,0,0,0,0,0,6,6,6,6,6,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,6,6,6,6,0,0,0,0,0,0,0,0,6,6,6,6,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,6,6,6,6,6,0,0,0,0,0,0,0,0,6,6,6,6,6,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,6,6,6,6,0,0,0,0,0,0,0,0,0,0,6,6,6,6,0,0,0,0,0,0,0],
                [0,0,0,0,0,7,7,7,7,7,7,7,7,0,0,0,0,0,0,7,7,7,7,7,7,7,7,0,0,0,0,0],
                [0,0,0,0,0,7,7,7,7,7,7,7,7,0,0,0,0,0,0,7,7,7,7,7,7,7,7,0,0,0,0,0],
                [0,0,0,0,0,7,7,7,7,7,7,7,7,0,0,0,0,0,0,7,7,7,7,7,7,7,7,0,0,0,0,0],
                [0,0,0,0,0,7,7,7,7,7,7,7,7,0,0,0,0,0,0,7,7,7,7,7,7,7,7,0,0,0,0,0]
            ],
            // Curved banana (20x36 pixels) - doubled detail
            banana: [
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,3,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,3,3,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,3,3,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,3,3,3,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,3,3,3,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,1,1,2,2,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,1,1,1,1,2,2,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,2,0,0,0,0],
                [0,0,0,0,0,0,0,0,1,1,1,1,1,1,2,2,0,0,0,0],
                [0,0,0,0,0,0,0,1,1,1,1,1,1,1,2,2,0,0,0,0],
                [0,0,0,0,0,0,1,1,1,1,1,1,1,2,2,0,0,0,0,0],
                [0,0,0,0,0,1,1,1,1,1,1,1,1,2,2,0,0,0,0,0],
                [0,0,0,0,1,1,1,1,1,1,1,1,2,2,0,0,0,0,0,0],
                [0,0,0,1,1,1,1,1,1,1,1,1,2,2,0,0,0,0,0,0],
                [0,0,1,1,1,1,1,1,1,1,1,2,2,0,0,0,0,0,0,0],
                [0,1,1,1,1,1,1,1,1,1,1,2,2,0,0,0,0,0,0,0],
                [0,1,1,1,1,1,1,1,1,1,2,2,0,0,0,0,0,0,0,0],
                [1,1,1,1,1,1,1,1,1,1,2,2,0,0,0,0,0,0,0,0],
                [1,1,1,1,1,1,1,1,1,2,2,0,0,0,0,0,0,0,0,0],
                [1,1,1,1,1,1,1,1,1,2,2,0,0,0,0,0,0,0,0,0],
                [1,1,1,1,1,1,1,1,2,2,0,0,0,0,0,0,0,0,0,0],
                [1,1,1,1,1,1,1,1,2,2,0,0,0,0,0,0,0,0,0,0],
                [1,1,1,1,1,1,1,2,2,0,0,0,0,0,0,0,0,0,0,0],
                [0,1,1,1,1,1,1,2,2,0,0,0,0,0,0,0,0,0,0,0],
                [0,1,1,1,1,1,2,2,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,1,1,1,1,2,2,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,1,1,1,1,2,2,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,1,1,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,1,1,2,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,4,4,4,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,4,4,4,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,4,4,0,0,0,0,0,0,0,0,0,0,0,0,0]
            ],
            // Snowman (20x36 pixels)
            snowman: [
                [0,0,0,0,0,0,0,0,5,5,5,5,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,5,5,5,5,5,5,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,5,5,5,5,5,5,5,5,0,0,0,0,0,0],
                [0,0,0,0,0,5,5,5,5,5,5,5,5,5,5,0,0,0,0,0],
                [0,0,0,0,5,5,5,5,5,5,5,5,5,5,5,5,0,0,0,0],
                [0,0,0,0,5,5,5,5,5,5,5,5,5,5,5,5,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,1,1,1,1,1,1,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,0,0],
                [0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0],
                [0,0,0,0,0,1,1,2,2,1,1,2,2,1,1,0,0,0,0,0],
                [0,0,0,0,1,1,1,2,2,1,1,2,2,1,1,1,0,0,0,0],
                [0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0],
                [0,0,0,0,1,1,1,1,3,1,1,3,1,1,1,1,0,0,0,0],
                [0,0,0,0,0,1,1,1,1,3,3,1,1,1,1,0,0,0,0,0],
                [0,0,0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,4,4,4,4,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,1,1,1,1,1,1,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,0,0],
                [0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0],
                [0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0],
                [0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0],
                [0,0,0,1,1,1,1,2,1,1,1,1,2,1,1,1,1,0,0,0],
                [0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0],
                [0,0,1,1,1,1,1,1,2,1,1,2,1,1,1,1,1,1,0,0],
                [0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0],
                [0,1,1,1,1,1,1,1,1,2,2,1,1,1,1,1,1,1,1,0],
                [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
                [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
                [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
                [0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0],
                [0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0],
                [0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0],
                [0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0],
                [0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0],
                [0,0,0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,0,0]
            ],
            // Cactus (20x36 pixels) - doubled detail
            cactus: [
                [0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,1,2,2,1,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,1,1,2,2,1,1,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,1,2,2,2,2,1,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,1,2,2,2,2,1,0,0,0,0,0,0,0],
                [0,0,1,1,0,0,0,1,2,2,2,2,1,0,0,0,1,1,0,0],
                [0,1,1,2,1,0,0,1,2,2,2,2,1,0,0,1,2,1,1,0],
                [0,1,2,2,1,0,1,1,2,2,2,2,1,1,0,1,2,2,1,0],
                [1,1,2,2,1,1,1,1,2,2,2,2,1,1,1,1,2,2,1,1],
                [1,2,2,2,2,1,1,1,2,2,2,2,1,1,1,2,2,2,2,1],
                [1,2,2,2,2,1,1,1,2,2,2,2,1,1,1,2,2,2,2,1],
                [1,2,2,2,2,1,1,1,2,2,2,2,1,1,1,2,2,2,2,1],
                [1,2,2,2,2,2,1,1,2,2,2,2,1,1,2,2,2,2,2,1],
                [0,1,2,2,2,2,1,1,2,2,2,2,1,1,2,2,2,2,1,0],
                [0,0,1,2,2,2,1,1,2,2,2,2,1,1,2,2,2,1,0,0],
                [0,0,0,1,1,1,1,1,2,2,2,2,1,1,1,1,1,0,0,0],
                [0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0],
                [0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0],
                [0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0],
                [0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0],
                [0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0],
                [0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0],
                [0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0],
                [0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0],
                [0,0,0,0,0,0,1,1,1,2,2,1,1,1,0,0,0,0,0,0],
                [0,0,0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,0,0],
                [0,0,0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,0,0]
            ],
            // Jungle palm tree (24x40 pixels)
            jungleTree: [
                [0,0,0,0,0,0,1,1,1,1,1,0,0,0,1,1,1,1,1,0,0,0,0,0],
                [0,0,0,0,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,0,0,0],
                [0,0,0,0,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,0,0,0],
                [0,0,0,1,1,1,1,2,2,1,1,1,0,1,1,1,2,2,1,1,1,1,0,0],
                [0,0,1,1,1,2,2,2,2,2,1,1,0,1,1,2,2,2,2,2,1,1,1,0],
                [0,1,1,1,2,2,2,2,2,2,1,0,0,0,1,2,2,2,2,2,2,1,1,1],
                [1,1,1,2,2,2,2,2,2,1,1,0,0,0,1,1,2,2,2,2,2,2,1,1],
                [1,1,2,2,2,2,2,2,1,1,0,0,0,0,0,1,1,2,2,2,2,2,2,1],
                [0,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,1,1,2,2,2,2,1,0],
                [0,0,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,1,1,1,1,1,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,3,3,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,3,3,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,3,3,3,3,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,3,3,3,3,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,3,3,3,3,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,3,3,3,3,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,3,3,3,3,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,3,3,3,3,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,3,3,3,3,3,3,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,3,3,3,3,3,3,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,3,3,3,3,3,3,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,3,3,3,3,3,3,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,3,3,3,3,3,3,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,3,3,3,3,3,3,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,3,3,3,3,3,3,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,3,3,3,3,3,3,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,3,3,3,3,3,3,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,3,3,3,3,3,3,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,3,3,3,3,3,3,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,3,3,3,3,3,3,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,3,3,4,4,3,3,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,3,3,3,4,4,3,3,3,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,3,3,3,4,4,3,3,3,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,3,3,3,3,4,4,3,3,3,3,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,3,3,3,3,4,4,3,3,3,3,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,3,3,3,3,3,4,4,3,3,3,3,3,0,0,0,0,0,0],
                [0,0,0,0,0,0,3,3,3,3,3,4,4,3,3,3,3,3,0,0,0,0,0,0],
                [0,0,0,0,0,3,3,3,3,3,3,4,4,3,3,3,3,3,3,0,0,0,0,0],
                [0,0,0,0,0,3,3,3,3,3,3,4,4,3,3,3,3,3,3,0,0,0,0,0],
                [0,0,0,0,0,3,3,3,3,3,3,3,3,3,3,3,3,3,3,0,0,0,0,0]
            ],
            // Kraken tentacle - tight spiral tip with S-curve body (22x44 pixels)
            tentacle: [
                [0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,1,1,2,2,1,1,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,1,1,2,2,1,1,2,2,1,1,0,0,0],
                [0,0,0,0,0,0,0,0,1,1,2,2,1,0,0,1,2,2,1,0,0,0],
                [0,0,0,0,0,0,0,1,1,2,2,1,0,0,0,1,1,2,1,1,0,0],
                [0,0,0,0,0,0,1,1,2,2,1,0,0,0,0,0,1,1,2,1,0,0],
                [0,0,0,0,0,1,1,2,2,1,1,0,0,0,0,0,0,1,1,1,0,0],
                [0,0,0,0,1,1,2,3,4,3,1,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,1,1,2,2,3,4,3,1,1,0,0,0,0,0,0,0,0,0,0],
                [0,0,1,1,2,2,2,2,2,2,2,1,0,0,0,0,0,0,0,0,0,0],
                [0,1,1,2,2,2,3,4,3,2,2,1,1,0,0,0,0,0,0,0,0,0],
                [1,1,2,2,2,2,3,4,3,2,2,2,1,0,0,0,0,0,0,0,0,0],
                [1,2,2,2,2,2,2,2,2,2,2,1,1,0,0,0,0,0,0,0,0,0],
                [1,2,2,2,3,4,3,2,2,2,1,1,0,0,0,0,0,0,0,0,0,0],
                [1,1,2,2,3,4,3,2,2,1,1,0,0,0,0,0,0,0,0,0,0,0],
                [0,1,1,2,2,2,2,2,1,1,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,1,1,3,4,3,2,1,1,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,1,3,4,3,2,2,1,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,1,1,2,2,2,2,1,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,1,1,2,2,2,1,1,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,1,1,2,2,2,1,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,1,1,2,2,1,1,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,1,1,2,2,1,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,1,1,2,1,1,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,1,1,2,1,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,1,2,2,1,1,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,1,1,2,2,1,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,1,2,2,1,1,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,1,1,2,2,1,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,1,2,2,1,1,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,2,2,1,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,2,2,1,1,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,2,2,1,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,2,2,1,1,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,2,2,1,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,2,2,1,1,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,2,2,1,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,2,2,1,1],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,2,1,1],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0]
            ]
        };

        // Colors for each sprite
        const colors = {
            // Snow outfit - winter gear
            runnerSnow: {
                1: '#8B5A2B',  // Hair
                2: '#DEB887',  // Skin
                3: '#000000',  // Eyes
                4: '#E53935',  // Red winter jacket/hat
                5: '#1A237E',  // Navy pants
                6: '#5D4037',  // Brown snow boots
                7: '#FFFFFF',  // Pom-pom
                8: '#CD5C5C'   // Mouth/smile
            },
            // Desert outfit - cowboy
            runnerDesert: {
                1: '#8B5A2B',  // Hair
                2: '#DEB887',  // Skin
                3: '#000000',  // Eyes
                4: '#8D6E63',  // Brown cowboy hat
                5: '#F5DEB3',  // Tan shirt
                6: '#5D4037',  // Brown vest
                7: '#1565C0',  // Blue jeans
                8: '#CD5C5C',  // Mouth/smile
                9: '#4E342E'   // Cowboy boots
            },
            // Jungle outfit - Tarzan
            runnerJungle: {
                1: '#5D4037',  // Dark hair
                2: '#C8A27A',  // Tanned skin
                3: '#000000',  // Eyes
                4: '#6D4C41'   // Brown loincloth
            },
            // Ocean outfit - scuba
            runnerOcean: {
                1: '#8B5A2B',  // Hair (hidden)
                2: '#DEB887',  // Skin (hidden)
                3: '#000000',  // Eyes
                4: '#FFB300',  // Yellow helmet
                5: '#81D4FA',  // Light blue visor
                6: '#212121',  // Black wetsuit
                7: '#000000'   // Black flippers
            },
            banana: {
                1: '#FFE135',  // Bright yellow
                2: '#FFC107',  // Darker yellow edge
                3: '#4E3524',  // Brown stem
                4: '#3E2723'   // Dark brown tip
            },
            snowman: {
                1: '#FFFFFF',  // White snow body
                2: '#212121',  // Black eyes/buttons
                3: '#FF5722',  // Orange carrot nose
                4: '#E53935',  // Red scarf
                5: '#212121'   // Black top hat
            },
            cactus: {
                1: '#2E7D32',  // Dark green
                2: '#4CAF50'   // Light green
            },
            jungleTree: {
                1: '#2E7D32',  // Dark green leaves
                2: '#4CAF50',  // Light green leaves
                3: '#5D4037',  // Brown trunk
                4: '#8D6E63'   // Light brown trunk detail
            },
            tentacle: {
                1: '#B71C1C',  // Dark red outer edge
                2: '#E57373',  // Pink tentacle body
                3: '#FFCDD2',  // Light pink suction cup ring
                4: '#C62828'   // Dark red suction cup center
            }
        };

        // Land configurations
        const lands = {
            snow: {
                name: 'Snow',
                skyTop: '#B3E5FC',
                skyBottom: '#E1F5FE',
                ground: '#ECEFF1',
                groundAccent: '#FFFFFF',
                obstacle: sprites.snowman,
                obstacleColors: colors.snowman,
                runner: sprites.runnerSnow,
                runnerColors: colors.runnerSnow
            },
            desert: {
                name: 'Desert',
                skyTop: '#FFE082',
                skyBottom: '#FFF8E1',
                ground: '#E6C47A',
                groundAccent: '#F5DEB3',
                obstacle: sprites.cactus,
                obstacleColors: colors.cactus,
                runner: sprites.runnerDesert,
                runnerColors: colors.runnerDesert
            },
            jungle: {
                name: 'Jungle',
                skyTop: '#81C784',
                skyBottom: '#C8E6C9',
                ground: '#6D4C41',
                groundAccent: '#4CAF50',
                obstacle: sprites.jungleTree,
                obstacleColors: colors.jungleTree,
                runner: sprites.runnerJungle,
                runnerColors: colors.runnerJungle
            },
            ocean: {
                name: 'Ocean',
                skyTop: '#4FC3F7',
                skyBottom: '#B3E5FC',
                ground: '#1565C0',
                groundAccent: '#42A5F5',
                obstacle: sprites.tentacle,
                obstacleColors: colors.tentacle,
                runner: sprites.runnerOcean,
                runnerColors: colors.runnerOcean
            }
        };

        let selectedLand = 'snow';

        // Calculate dimensions from sprites
        const PLAYER_WIDTH = sprites.runnerSnow[0].length * PLAYER_SCALE;
        const PLAYER_HEIGHT = sprites.runnerSnow.length * PLAYER_SCALE;

        // Draw sprite function
        function drawSprite(ctx, x, y, pixels, scale, colorMap) {
            for (let row = 0; row < pixels.length; row++) {
                for (let col = 0; col < pixels[row].length; col++) {
                    const colorId = pixels[row][col];
                    if (colorId) {
                        ctx.fillStyle = colorMap[colorId];
                        ctx.fillRect(
                            x + col * scale,
                            y + row * scale,
                            scale,
                            scale
                        );
                    }
                }
            }
        }

        // Game state: 'welcome', 'menu', 'playing', 'gameover', 'leaderboard', 'lobby'
        // (gameState declared early to avoid temporal dead zone)
        let gameMode = 'solo'; // 'solo' or 'multiplayer'
        let score = 0;
        let bananasCollected = 0;
        let gameTime = 0;
        let speed = 6;
        // (spawnCounter declared early to avoid temporal dead zone)
        let scrollOffset = 0;
        // (entities declared early to avoid temporal dead zone)
        let scoreSaved = false; // Track if score was saved for current game

        // Leaderboard data
        let leaderboardData = [];
        let loadingLeaderboard = false;

        // Game Over stats
        let gameOverStats = {
            globalTopScore: null,
            globalTopPlayer: null,
            biomeTopScore: null,
            biomeTopPlayer: null,
            personalBiomeBest: null,
            isNewBiomeBest: false,
            isNewGlobalBest: false,
            loading: true
        };

        // Multiplayer lobby state
        let currentLobby = null;
        let lobbyPlayers = [];
        let lobbySubscription = null;
        let isLobbyHost = false;
        let lobbyCodeInput = '';
        let lobbyJoinError = '';
        const MAX_LOBBY_PLAYERS = 7;

        // Multiplayer game state
        let multiplayerPlayers = [];  // All players' states for rendering
        let localPlayerIndex = 0;     // My position in the player order
        let localPlayerAlive = true;  // Am I still alive?
        let allPlayersStates = {};    // Track all player states by ID
        let gameChannel = null;       // Supabase realtime channel for game state

        // Legacy (will be replaced by multiplayerPlayers)
        let opponentScore = 0;
        let opponentBananas = 0;
        let gameResult = null; // 'win', 'lose', 'tie'

        // Skins system
        const SKINS = {
            default: { name: 'Default', description: 'The classic runner', unlocked: true },
            golden: { name: 'Golden Runner', description: 'Collect 100 total bananas', unlockReq: { type: 'bananas', value: 100 } },
            speedster: { name: 'Speedster', description: 'Score 5000 points in one game', unlockReq: { type: 'score', value: 5000 } },
            veteran: { name: 'Veteran', description: 'Play 50 games', unlockReq: { type: 'games', value: 50 } },
            champion: { name: 'Champion', description: 'Win 10 multiplayer games', unlockReq: { type: 'mp_wins', value: 10 } }
        };

        // Achievements system
        const ACHIEVEMENTS = {
            first_game: { name: 'First Steps', description: 'Play your first game', icon: 'ðŸŽ®' },
            banana_collector: { name: 'Banana Collector', description: 'Collect 50 bananas in one game', icon: 'ðŸŒ' },
            high_scorer: { name: 'High Scorer', description: 'Score 10000 points', icon: 'ðŸ†' },
            world_traveler: { name: 'World Traveler', description: 'Play on all 4 lands', icon: 'ðŸŒ' },
            marathon_runner: { name: 'Marathon Runner', description: 'Survive for 60 seconds', icon: 'ðŸƒ' },
            multiplayer_debut: { name: 'Social Butterfly', description: 'Play your first multiplayer game', icon: 'ðŸ‘¥' },
            first_win: { name: 'Victory!', description: 'Win your first multiplayer game', icon: 'ðŸ¥‡' },
            banana_hoarder: { name: 'Banana Hoarder', description: 'Collect 500 total bananas', icon: 'ðŸŒ' },
            dedicated: { name: 'Dedicated', description: 'Play 100 games', icon: 'â­' }
        };

        let unlockedSkins = ['default'];
        let unlockedAchievements = [];
        let selectedSkin = 'default';
        let landsPlayed = new Set();

        // Jump buffering - stores timestamp of last jump attempt
        // JUMP_BUFFER_MS imported from config.js
        let jumpBufferTime = 0;

        // Variable jump height - track if jump button is held
        let jumpHeld = false;
        const JUMP_RELEASE_MULTIPLIER = 0.4;  // Velocity multiplier when releasing early
        const FALL_GRAVITY_MULTIPLIER = 1.5;  // Extra gravity when falling or released

        // Dynamic jump velocity based on screen height
        // Ensures player doesn't bonk head on ceiling in landscape mobile
        const BASE_JUMP_VELOCITY = -18;
        const MIN_CEILING_MARGIN = 30;  // Minimum space from top of screen

        function getJumpVelocity() {
            // Calculate available jump space (from ground to ceiling margin)
            const groundLevel = getGroundLevel();
            const availableHeight = groundLevel - MIN_CEILING_MARGIN - PLAYER_HEIGHT;

            // For a standard 600px height, available is about 500px
            // Scale jump velocity if screen is shorter
            const standardHeight = 500;
            const heightRatio = Math.min(1, availableHeight / standardHeight);

            // Scale velocity (sqrt for more natural feel - half height = ~70% velocity)
            return BASE_JUMP_VELOCITY * Math.sqrt(heightRatio);
        }

        // Land selection buttons (will be calculated in draw)
        let landButtons = [];
        // Menu action buttons (Solo, Multiplayer, Leaderboard, Login)
        let menuButtons = [];

        // Player (declared early to avoid temporal dead zone, assigned here)
        player = {
            x: 100,
            y: getGroundLevel() - PLAYER_HEIGHT,
            vy: 0,
            jumping: false,
            get groundY() { return getGroundLevel() - PLAYER_HEIGHT; },
            scale: PLAYER_SCALE
        };

        // Check if a point is inside a button
        function pointInButton(x, y, btn) {
            return x >= btn.x && x <= btn.x + btn.w && y >= btn.y && y <= btn.y + btn.h;
        }

        // Handle click/tap for land selection and menu buttons
        function handleClick(clientX, clientY) {
            const rect = canvas.getBoundingClientRect();
            const x = (clientX - rect.left) * (canvas.width / rect.width);
            const y = (clientY - rect.top) * (canvas.height / rect.height);

            // Check design system clickable areas first
            for (const area of clickableAreas) {
                if (pointInBounds(x, y, area)) {
                    handleMenuAction(area.action);
                    return true;
                }
            }

            // Check legacy menu action buttons
            for (const btn of menuButtons) {
                if (pointInButton(x, y, btn)) {
                    handleMenuAction(btn.action);
                    return true;
                }
            }

            // Check land buttons
            for (const btn of landButtons) {
                if (pointInButton(x, y, btn)) {
                    selectedLand = btn.land;
                    if (gameState === 'gameover') {
                        startGame();
                    }
                    return true;
                }
            }
            return false;
        }

        // Handle menu button actions
        function handleMenuAction(action) {
            switch (action) {
                case 'solo':
                    gameMode = 'solo';
                    startGame();
                    break;
                case 'multiplayer':
                    if (!currentUser) {
                        showAuthModal();
                    } else {
                        gameState = 'multiplayer-menu';
                    }
                    break;
                case 'create_lobby':
                    createNewLobby();
                    break;
                case 'show_join':
                    lobbyCodeInput = '';
                    lobbyJoinError = '';
                    gameState = 'join-lobby';
                    break;
                case 'join_with_code':
                    joinLobbyWithCode();
                    break;
                case 'start_game':
                    hostStartGame();
                    break;
                case 'leaderboard':
                    showLeaderboard();
                    break;
                case 'login':
                    showAuthModal();
                    break;
                case 'back':
                    if (gameState === 'join-lobby' || gameState === 'multiplayer-menu') {
                        gameState = 'menu';
                    } else {
                        gameState = 'menu';
                    }
                    break;
                case 'back_to_mp_menu':
                    gameState = 'multiplayer-menu';
                    break;
                case 'leave_lobby':
                    leaveLobby();
                    break;
                case 'play_again':
                    hostPlayAgain();
                    break;
                case 'leave_results':
                    leaveMultiplayerResults();
                    break;
                default:
                    // Handle virtual keyboard keys for lobby code input
                    if (action.startsWith('key_')) {
                        const key = action.substring(4);
                        if (key === 'backspace') {
                            lobbyCodeInput = lobbyCodeInput.slice(0, -1);
                            lobbyJoinError = '';
                        } else if (lobbyCodeInput.length < 6) {
                            lobbyCodeInput += key;
                            lobbyJoinError = '';
                        }
                    }
                    break;
            }
        }

        // Show leaderboard
        async function showLeaderboard() {
            gameState = 'leaderboard';
            loadingLeaderboard = true;
            leaderboardData = await getLeaderboard(null, 10);
            loadingLeaderboard = false;
        }

        // Input handling
        function jump() {
            if (gameState === 'playing') {
                // Ghosts can't jump in multiplayer
                if (gameMode === 'multiplayer' && !localPlayerAlive) {
                    return;
                }

                if (!player.jumping) {
                    // On ground - jump immediately with screen-scaled velocity
                    player.vy = getJumpVelocity();
                    player.jumping = true;
                    jumpHeld = true;
                    jumpBufferTime = 0;
                } else {
                    // In air - buffer the jump request
                    jumpBufferTime = Date.now();
                }
            }
        }

        // Release jump - called when button/touch is released
        function releaseJump() {
            if (jumpHeld && player.jumping && player.vy < 0) {
                // Still rising - cut the velocity for a short hop
                player.vy *= JUMP_RELEASE_MULTIPLIER;
            }
            jumpHeld = false;
        }

        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space') {
                e.preventDefault();
                if (gameState === 'playing') {
                    jump();
                } else if (gameState === 'gameover') {
                    startGame();
                } else if (gameState === 'leaderboard') {
                    gameState = 'menu';
                }
            }
            if (e.code === 'Escape') {
                if (gameState === 'leaderboard') {
                    gameState = 'menu';
                }
            }
        });

        // Release jump on keyup for variable jump height
        document.addEventListener('keyup', (e) => {
            if (e.code === 'Space') {
                releaseJump();
            }
        });

        // Menu states where clicks are handled as buttons
        const MENU_STATES = ['welcome', 'menu', 'gameover', 'leaderboard', 'lobby', 'multiplayer-menu', 'join-lobby', 'multiplayer-results'];

        function isMenuState() {
            return MENU_STATES.includes(gameState);
        }

        // Touch support for mobile
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            if (isMenuState()) {
                handleClick(touch.clientX, touch.clientY);
            } else {
                jump();
            }
        });

        // Release jump on touch end for variable jump height
        canvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            releaseJump();
        });

        canvas.addEventListener('click', (e) => {
            if (isMenuState()) {
                if (!handleClick(e.clientX, e.clientY)) {
                    if (gameState === 'gameover') {
                        startGame();
                    }
                }
            } else {
                jump();
            }
        });

        // Mouse up for variable jump height (when using click instead of touch)
        canvas.addEventListener('mouseup', (e) => {
            releaseJump();
        });

        // Spawn entity
        function spawn() {
            const land = lands[selectedLand];
            const isBanana = Math.random() < 0.35;

            if (isBanana) {
                // Spawn single banana
                const pixels = sprites.banana;
                const scale = ENTITY_SCALE;
                const h = pixels.length * scale;
                entities.push({
                    x: canvas.width + 20,
                    y: getGroundLevel() - h - BANANA_HEIGHT_OFFSET,
                    pixels: pixels,
                    scale: scale,
                    colors: colors.banana,
                    type: 'banana',
                    vx: 0
                });
            } else {
                // Spawn 1, 2, or 3 obstacles in a row
                const obstacleCount = Math.floor(Math.random() * 3) + 1;
                const pixels = land.obstacle;
                const scale = ENTITY_SCALE;
                const w = pixels[0].length * scale;
                const h = pixels.length * scale;
                const gap = 4; // Small gap between obstacles

                for (let i = 0; i < obstacleCount; i++) {
                    entities.push({
                        x: canvas.width + 20 + (i * (w + gap)),
                        y: getGroundLevel() - h,
                        pixels: pixels,
                        scale: scale,
                        colors: land.obstacleColors,
                        type: 'obstacle',
                        vx: 0
                    });
                }
            }
        }

        // Start/restart game
        function startGame() {
            gameState = 'playing';
            score = 0;
            bananasCollected = 0;
            gameTime = 0;
            speed = 6;
            spawnCounter = 0;
            scrollOffset = 0;
            entities = [];
            player.y = player.groundY;
            player.vy = 0;
            player.jumping = false;
            jumpBufferTime = 0;
            jumpHeld = false;
            scoreSaved = false;
        }

        // Update game logic
        function update() {
            if (gameState !== 'playing') return;

            gameTime++;
            speed += 0.002; // Gradually increase speed
            spawnCounter += speed;

            // Spawn logic (random spacing)
            if (spawnCounter > 280 + Math.random() * 220) {
                spawn();
                spawnCounter = 0;
            }

            // Player physics with variable jump height
            if (player.jumping) {
                // Base gravity
                let gravity = 0.8;

                // Apply extra gravity when:
                // - Falling (vy > 0), OR
                // - Rising but button released (for snappy short hops)
                if (player.vy > 0 || !jumpHeld) {
                    gravity *= FALL_GRAVITY_MULTIPLIER;
                }

                player.vy += gravity;
                player.y += player.vy;

                // Ceiling collision - prevent going above minimum margin
                if (player.y < MIN_CEILING_MARGIN) {
                    player.y = MIN_CEILING_MARGIN;
                    player.vy = 0;  // Stop upward momentum, start falling
                }

                // Ground collision
                if (player.y >= player.groundY) {
                    player.y = player.groundY;
                    player.jumping = false;
                    player.vy = 0;
                    jumpHeld = false;  // Reset held state on landing

                    // Check for buffered jump - if player pressed jump recently, jump again
                    if (jumpBufferTime > 0 && (Date.now() - jumpBufferTime) < JUMP_BUFFER_MS) {
                        player.vy = getJumpVelocity();
                        player.jumping = true;
                        jumpHeld = true;  // Assume held for buffered jump
                        jumpBufferTime = 0;
                    }
                }
            }

            // Update entities
            for (let i = entities.length - 1; i >= 0; i--) {
                const ent = entities[i];
                ent.x -= speed;

                // Remove off-screen entities
                const entW = ent.pixels[0].length * ent.scale;
                if (ent.x + entW < -50) {
                    entities.splice(i, 1);
                    continue;
                }

                // Collision detection - skip if player is a ghost in multiplayer
                if (gameMode === 'multiplayer' && !localPlayerAlive) {
                    continue;  // Ghost mode - no collisions
                }

                const pRight = player.x + PLAYER_WIDTH;
                const pBottom = player.y + PLAYER_HEIGHT;
                const eRight = ent.x + (ent.pixels[0].length * ent.scale);
                const eBottom = ent.y + (ent.pixels.length * ent.scale);

                if (player.x < eRight &&
                    pRight > ent.x &&
                    player.y < eBottom &&
                    pBottom > ent.y) {

                    if (ent.type === 'obstacle') {
                        if (gameMode === 'multiplayer') {
                            // In multiplayer: become a ghost, don't end game
                            localPlayerAlive = false;

                            // Update local player state
                            if (allPlayersStates[currentUser?.id]) {
                                allPlayersStates[currentUser.id].isAlive = false;
                                allPlayersStates[currentUser.id].score = score;
                                allPlayersStates[currentUser.id].bananas = bananasCollected;
                            }

                            // Broadcast death immediately
                            broadcastPlayerState();

                            // Check if all players dead
                            checkRoundOver();
                        } else {
                            // Solo mode: game over as before
                            gameState = 'gameover';

                            // Fetch game over stats (before saving so we compare against previous bests)
                            fetchGameOverStats(score, selectedLand);

                            // Save score if logged in and not already saved
                            if (!scoreSaved && currentUser) {
                                scoreSaved = true;
                                saveScore(score, bananasCollected, selectedLand);

                                // Check achievements (game time in seconds = gameTime / 60 fps)
                                const gameTimeSeconds = Math.floor(gameTime / 60);
                                checkAchievements(score, bananasCollected, gameTimeSeconds, false, false);
                            }
                        }
                    } else {
                        // Banana collection - only if alive
                        if (gameMode !== 'multiplayer' || localPlayerAlive) {
                            bananasCollected++;
                            entities.splice(i, 1);
                            // Debug log for multiplayer
                            if (gameMode === 'multiplayer') {
                                console.log(`[Banana] Collected! Total: ${bananasCollected}, Score: ${score}`);
                            }
                        }
                    }
                }
            }

            // Update score (time survived + banana bonuses) - but freeze on death in multiplayer
            if (gameMode !== 'multiplayer' || localPlayerAlive) {
                score = Math.floor(gameTime / 6) + (bananasCollected * 150);
            }

            scrollOffset = (scrollOffset + speed) % 40;

            // Update and broadcast game state in multiplayer (every 5 frames = ~12 updates/sec for smoother sync)
            if (gameMode === 'multiplayer' && gameTime % 5 === 0) {
                // Update local player state in shared state before broadcasting
                if (currentUser?.id && allPlayersStates[currentUser.id]) {
                    allPlayersStates[currentUser.id].y = player?.y || 0;
                    allPlayersStates[currentUser.id].score = score;
                    allPlayersStates[currentUser.id].bananas = bananasCollected;
                    allPlayersStates[currentUser.id].isAlive = localPlayerAlive;
                }
                broadcastPlayerState();
            }
        }

        // Draw menu action buttons
        function drawMenuButtons(buttons, startY) {
            const btnWidth = 200;
            const btnHeight = 50;
            const gap = 15;

            menuButtons = [];

            buttons.forEach((btn, i) => {
                const x = (canvas.width - btnWidth) / 2;
                const y = startY + i * (btnHeight + gap);

                menuButtons.push({ x, y, w: btnWidth, h: btnHeight, action: btn.action });

                // Draw button background
                ctx.fillStyle = btn.primary ? '#FFE135' : '#333';
                ctx.fillRect(x, y, btnWidth, btnHeight);

                // Draw border
                ctx.strokeStyle = btn.primary ? '#FFC107' : '#555';
                ctx.lineWidth = 2;
                ctx.strokeRect(x, y, btnWidth, btnHeight);

                // Draw text
                ctx.fillStyle = btn.primary ? '#000' : '#FFF';
                ctx.font = 'bold 18px monospace';
                ctx.textAlign = 'center';
                ctx.fillText(btn.label, x + btnWidth / 2, y + btnHeight / 2 + 6);
            });
        }

        // Draw land selection buttons
        function drawLandButtons(startY, showChangeText) {
            const landKeys = Object.keys(lands);
            // Responsive button sizes
            const btnWidth = Math.min(120, Math.round((canvas.width - DS.spacing.xl * 2) / landKeys.length - DS.spacing.sm));
            const btnHeight = Math.max(44, Math.round(canvas.width * 0.055));
            const gap = DS.spacing.sm;
            const totalWidth = landKeys.length * btnWidth + (landKeys.length - 1) * gap;
            const startX = (canvas.width - totalWidth) / 2;

            landButtons = [];

            landKeys.forEach((key, i) => {
                const land = lands[key];
                const x = startX + i * (btnWidth + gap);
                const y = startY;
                const isSelected = key === selectedLand;

                // Store button for click detection
                landButtons.push({ x, y, w: btnWidth, h: btnHeight, land: key });

                // Draw button with rounded corners
                ctx.fillStyle = isSelected ? land.ground : DS.colors.locked;
                ctx.beginPath();
                ctx.roundRect(x, y, btnWidth, btnHeight, DS.button.radius);
                ctx.fill();

                // Draw border
                ctx.strokeStyle = isSelected ? DS.colors.white : DS.colors.textMuted;
                ctx.lineWidth = isSelected ? 3 : 2;
                ctx.stroke();

                // Draw text
                ctx.fillStyle = DS.colors.white;
                ctx.font = DS.font('small', 'bold');
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(land.name, x + btnWidth / 2, y + btnHeight / 2);
            });

            if (showChangeText) {
                ctx.fillStyle = DS.colors.textSecondary;
                ctx.font = DS.font('tiny');
                ctx.textAlign = 'center';
                ctx.fillText('Tap a land to change, or tap anywhere to play', canvas.width / 2, startY + btnHeight + DS.spacing.lg);
            }
        }

        // Draw everything
        function draw() {
            const land = lands[selectedLand];
            const groundY = getGroundLevel();

            // Clear canvas
            ctx.fillStyle = '#FAFAFA';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw sky gradient with land colors
            const grad = ctx.createLinearGradient(0, 0, 0, groundY);
            grad.addColorStop(0, land.skyTop);
            grad.addColorStop(1, land.skyBottom);
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, canvas.width, groundY);

            // Draw scrolling ground with land colors
            ctx.fillStyle = land.ground;
            ctx.fillRect(0, groundY, canvas.width, canvas.height - groundY);

            // Draw ground bumps/dots (scrolling)
            ctx.fillStyle = land.groundAccent;
            let bumpX = (-scrollOffset) % 40;
            for (let i = 0; i < canvas.width / 20 + 3; i++) {
                const x = bumpX + (i * 40);
                ctx.fillRect(x, groundY - 4, 20, 8);
                ctx.fillRect(x + 22, groundY, 8, 8);
            }

            if (gameState === 'welcome') {
                // Welcome/Landing screen - shown before login
                resetClickables();
                ctx.fillStyle = DS.colors.bgOverlay;
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                const centerX = canvas.width / 2;

                // Compact mode for small screens
                const isCompact = canvas.height < 600;

                let y = isCompact ? DS.spacing.lg : DS.spacing.xxl;

                // Title - smaller on compact
                ctx.textAlign = 'center';
                ctx.fillStyle = DS.colors.primary;
                const titleSize = isCompact ? 'h2' : 'h1';
                ctx.font = DS.font(titleSize, 'bold');
                ctx.fillText('BANANA RUNNER', centerX, y + DS.fontSize(titleSize));
                y += DS.fontSize(titleSize) + (isCompact ? DS.spacing.md : DS.spacing.lg);

                // Draw banana sprite as logo - smaller on compact
                const bananaScale = isCompact ? Math.max(1, Math.round(canvas.width / 500)) : Math.max(2, Math.round(canvas.width / 400));
                const bananaWidth = sprites.banana[0].length * bananaScale;
                drawSprite(ctx, centerX - bananaWidth / 2, y, sprites.banana, bananaScale, colors.banana);
                y += sprites.banana.length * bananaScale + (isCompact ? DS.spacing.md : DS.spacing.xl);

                // Tagline
                ctx.fillStyle = DS.colors.textPrimary;
                ctx.font = DS.font(isCompact ? 'body' : 'h3');
                ctx.fillText('An endless runner adventure!', centerX, y);
                y += DS.fontSize(isCompact ? 'body' : 'h3') + (isCompact ? DS.spacing.md : DS.spacing.xl);

                // Features panel - condensed on compact
                if (!isCompact) {
                    const panelWidth = Math.min(500, canvas.width - DS.spacing.xl * 2);
                    const panelHeight = DS.fontSize('body') * 4 + DS.spacing.lg * 2;
                    drawPanel(centerX, y, panelWidth, panelHeight, { centered: true });

                    ctx.fillStyle = DS.colors.textSecondary;
                    ctx.font = DS.font('body');
                    const featureY = y + DS.spacing.lg + DS.fontSize('body');
                    ctx.fillText('Jump over obstacles & collect bananas', centerX, featureY);
                    ctx.fillText('Compete in multiplayer battles', centerX, featureY + DS.fontSize('body') + DS.spacing.sm);
                    ctx.fillText('Unlock achievements & climb ranks', centerX, featureY + (DS.fontSize('body') + DS.spacing.sm) * 2);
                    y += panelHeight + DS.spacing.xl;
                }

                // Feature highlights
                ctx.fillStyle = DS.colors.primary;
                ctx.font = DS.font('small', 'bold');
                ctx.fillText('4 LANDS  â€¢  MULTIPLAYER  â€¢  LEADERBOARDS', centerX, y);
                y += DS.fontSize('small') + (isCompact ? DS.spacing.lg : DS.spacing.xxl);

                // Login button - smaller on compact
                const btnWidth = Math.min(isCompact ? 220 : 280, canvas.width - DS.spacing.lg * 2);
                const btnHeight = isCompact ? Math.max(44, DS.button.height() * 0.85) : DS.button.height();
                const btnBounds = drawStyledButton(centerX, y, btnWidth, btnHeight, 'GET STARTED', { action: 'login', primary: true });
                addClickable(btnBounds);

                // Footer - only if room
                if (canvas.height - y - btnHeight > 50) {
                    ctx.fillStyle = DS.colors.textMuted;
                    ctx.font = DS.font('small');
                    ctx.fillText('Create an account to save progress', centerX, canvas.height - DS.spacing.md);
                }

            } else if (gameState === 'menu') {
                // Menu screen - shown after login
                resetClickables();
                ctx.fillStyle = DS.colors.bgOverlayLight;
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                const centerX = canvas.width / 2;

                // Compact mode for small screens
                const isCompact = canvas.height < 600;
                const compactSpacing = isCompact ? DS.spacing.sm : DS.spacing.md;
                const compactLgSpacing = isCompact ? DS.spacing.md : DS.spacing.lg;

                let y = isCompact ? DS.spacing.md : DS.spacing.xl;

                // Title - smaller on compact screens
                ctx.textAlign = 'center';
                ctx.fillStyle = DS.colors.white;
                const titleSize = isCompact ? 'h2' : 'h1';
                ctx.font = DS.font(titleSize, 'bold');
                ctx.fillText('BANANA RUNNER', centerX, y + DS.fontSize(titleSize));
                y += DS.fontSize(titleSize) + compactSpacing;

                // Draw banana sprite as logo - smaller on compact
                const bananaScale = isCompact ? Math.max(1, Math.round(canvas.width / 500)) : Math.max(2, Math.round(canvas.width / 400));
                const bananaWidth = sprites.banana[0].length * bananaScale;
                drawSprite(ctx, centerX - bananaWidth / 2, y, sprites.banana, bananaScale, colors.banana);
                y += sprites.banana.length * bananaScale + compactLgSpacing;

                // User stats panel - condensed on compact
                if (userProfile) {
                    const statsPanelWidth = Math.min(isCompact ? 320 : 420, canvas.width - DS.spacing.lg * 2);
                    const statsFont = isCompact ? 'small' : 'body';
                    const statsPanelHeight = isCompact
                        ? DS.fontSize('small') * 2.5 + DS.spacing.md * 2
                        : DS.fontSize('body') * 3 + DS.spacing.lg * 2;
                    drawPanel(centerX, y, statsPanelWidth, statsPanelHeight, { centered: true });

                    const statsY = y + (isCompact ? DS.spacing.md : DS.spacing.lg) + DS.fontSize(statsFont) / 2;
                    ctx.fillStyle = DS.colors.primary;
                    ctx.font = DS.font(statsFont, 'bold');
                    ctx.fillText(`${userProfile.username || 'Player'}  â€¢  High: ${userProfile.high_score || 0}`, centerX, statsY);

                    if (!isCompact) {
                        ctx.fillStyle = DS.colors.white;
                        ctx.font = DS.font('body');
                        ctx.fillText(`High Score: ${userProfile.high_score || 0}`, centerX, statsY + DS.fontSize('body') + DS.spacing.xs);
                    }

                    ctx.fillStyle = DS.colors.textSecondary;
                    ctx.font = DS.font('small');
                    const statsLine2Y = isCompact ? statsY + DS.fontSize('small') + DS.spacing.xs : statsY + (DS.fontSize('body') + DS.spacing.xs) * 2;
                    ctx.fillText(`${userProfile.total_bananas || 0} ðŸŒ  |  ${userProfile.total_games || 0} games`, centerX, statsLine2Y);
                    y += statsPanelHeight + compactLgSpacing;
                }

                // Land selection
                y = drawSectionTitle('SELECT LAND', y);
                const landBtnHeight = isCompact ? 40 : 50;
                drawLandButtons(y, false);
                y += landBtnHeight + compactLgSpacing;

                // Menu buttons - smaller on compact screens
                const btnWidth = Math.min(isCompact ? 200 : 240, canvas.width - DS.spacing.lg * 2);
                const btnHeight = isCompact ? Math.max(40, DS.button.height() * 0.8) : DS.button.height();
                const gap = isCompact ? DS.spacing.sm : DS.spacing.md;

                const soloBounds = drawStyledButton(centerX, y, btnWidth, btnHeight, 'SOLO PLAY', { action: 'solo', primary: true });
                addClickable(soloBounds);
                y += btnHeight + gap;

                const multiBounds = drawStyledButton(centerX, y, btnWidth, btnHeight, 'MULTIPLAYER', { action: 'multiplayer', primary: false });
                addClickable(multiBounds);
                y += btnHeight + gap;

                const leaderBounds = drawStyledButton(centerX, y, btnWidth, btnHeight, 'LEADERBOARD', { action: 'leaderboard', primary: false });
                addClickable(leaderBounds);

                // Instructions - only show if there's room
                if (canvas.height - y > 60) {
                    ctx.fillStyle = DS.colors.textMuted;
                    ctx.font = DS.font('small');
                    ctx.fillText('Press SPACE or tap to jump!', centerX, canvas.height - DS.spacing.md);
                }

            } else if (gameState === 'leaderboard') {
                // Leaderboard screen
                resetClickables();
                ctx.fillStyle = DS.colors.bgOverlay;
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // Header with back button
                const header = drawHeader('LEADERBOARD', true);
                addClickable(header.backBounds);

                const centerX = canvas.width / 2;
                let contentY = header.height + DS.spacing.lg;

                if (loadingLeaderboard) {
                    ctx.fillStyle = DS.colors.textSecondary;
                    ctx.font = DS.font('h3');
                    ctx.textAlign = 'center';
                    ctx.fillText('Loading...', centerX, canvas.height / 2);
                } else if (leaderboardData.length === 0) {
                    ctx.fillStyle = DS.colors.textSecondary;
                    ctx.font = DS.font('body');
                    ctx.textAlign = 'center';
                    ctx.fillText('No scores yet!', centerX, canvas.height / 2 - DS.spacing.md);
                    ctx.fillText('Be the first to play!', centerX, canvas.height / 2 + DS.spacing.md);
                } else {
                    // Draw leaderboard panel
                    const panelWidth = Math.min(500, canvas.width - DS.spacing.lg * 2);
                    const rowHeight = Math.max(36, DS.fontSize('body') + DS.spacing.md);
                    const panelHeight = rowHeight * (leaderboardData.length + 1) + DS.spacing.lg * 2;
                    const panelX = centerX - panelWidth / 2;

                    drawPanel(panelX, contentY, panelWidth, panelHeight);

                    // Table header
                    const tableY = contentY + DS.spacing.lg;
                    const colRank = panelX + DS.spacing.lg;
                    const colPlayer = panelX + DS.spacing.xl * 2;
                    const colScore = panelX + panelWidth - DS.spacing.lg;

                    ctx.fillStyle = DS.colors.textMuted;
                    ctx.font = DS.font('small', 'bold');
                    ctx.textAlign = 'left';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('RANK', colRank, tableY + rowHeight / 2);
                    ctx.fillText('PLAYER', colPlayer, tableY + rowHeight / 2);
                    ctx.textAlign = 'right';
                    ctx.fillText('SCORE', colScore, tableY + rowHeight / 2);

                    // Draw entries
                    leaderboardData.forEach((entry, i) => {
                        const y = tableY + (i + 1) * rowHeight + rowHeight / 2;
                        const isCurrentUser = currentUser && entry.player_id === currentUser.id;

                        ctx.fillStyle = isCurrentUser ? DS.colors.primary : DS.colors.white;
                        ctx.font = DS.font('body', isCurrentUser ? 'bold' : 'normal');

                        ctx.textAlign = 'left';
                        ctx.fillText(`#${i + 1}`, colRank, y);
                        ctx.fillText(entry.username || 'Anonymous', colPlayer, y);
                        ctx.textAlign = 'right';
                        ctx.fillText(entry.high_score?.toString() || '0', colScore, y);
                    });
                }

            } else if (gameState === 'multiplayer-menu') {
                // Multiplayer menu - Create or Join options
                resetClickables();
                ctx.fillStyle = DS.colors.bgOverlay;
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                const header = drawHeader('MULTIPLAYER', true);
                addClickable(header.backBounds);

                const centerX = canvas.width / 2;
                let y = header.height + DS.spacing.xl * 2;

                // Title
                ctx.textAlign = 'center';
                ctx.fillStyle = DS.colors.white;
                ctx.font = DS.font('h2', 'bold');
                ctx.fillText('Choose an option', centerX, y);
                y += DS.fontSize('h2') + DS.spacing.xl;

                const btnWidth = Math.min(280, canvas.width - DS.spacing.lg * 2);
                const btnHeight = DS.button.height();

                // Create Lobby button
                const createBounds = drawStyledButton(centerX, y, btnWidth, btnHeight, 'CREATE LOBBY', { action: 'create_lobby', primary: true });
                addClickable(createBounds);
                y += btnHeight + DS.spacing.sm;

                ctx.fillStyle = DS.colors.textMuted;
                ctx.font = DS.font('small');
                ctx.fillText('Start a new game and invite friends', centerX, y);
                y += DS.fontSize('small') + DS.spacing.xl;

                // Join Lobby button
                const joinBounds = drawStyledButton(centerX, y, btnWidth, btnHeight, 'JOIN LOBBY', { action: 'show_join', primary: false });
                addClickable(joinBounds);
                y += btnHeight + DS.spacing.sm;

                ctx.fillStyle = DS.colors.textMuted;
                ctx.font = DS.font('small');
                ctx.fillText('Enter a code to join a friend\'s game', centerX, y);

            } else if (gameState === 'join-lobby') {
                // Join lobby screen with code input
                resetClickables();
                ctx.fillStyle = DS.colors.bgOverlay;
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                const header = drawHeader('JOIN LOBBY', true);
                addClickable({ ...header.backBounds, action: 'back_to_mp_menu' });

                const centerX = canvas.width / 2;
                let y = header.height + DS.spacing.xl * 2;

                // Instructions
                ctx.textAlign = 'center';
                ctx.fillStyle = DS.colors.white;
                ctx.font = DS.font('body');
                ctx.fillText('Enter the 6-character lobby code', centerX, y);
                y += DS.fontSize('body') + DS.spacing.lg;

                // Code input display (styled as a panel)
                const inputWidth = 200;
                const inputHeight = 60;
                drawPanel(centerX, y, inputWidth, inputHeight, { centered: true });

                ctx.fillStyle = lobbyCodeInput ? DS.colors.primary : DS.colors.textMuted;
                ctx.font = DS.font('h2', 'bold');
                ctx.fillText(lobbyCodeInput || '______', centerX, y + inputHeight / 2 + DS.fontSize('h2') / 3);
                y += inputHeight + DS.spacing.md;

                // Error message
                if (lobbyJoinError) {
                    ctx.fillStyle = DS.colors.error || '#E53935';
                    ctx.font = DS.font('small');
                    ctx.fillText(lobbyJoinError, centerX, y);
                    y += DS.fontSize('small') + DS.spacing.md;
                } else {
                    y += DS.spacing.md;
                }

                // Virtual keyboard for code input (simple A-Z, 0-9)
                const keySize = Math.min(40, (canvas.width - DS.spacing.lg * 2) / 10);
                const keyGap = 4;
                const keys = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
                const keysPerRow = 9;

                y += DS.spacing.md;
                for (let i = 0; i < keys.length; i++) {
                    const row = Math.floor(i / keysPerRow);
                    const col = i % keysPerRow;
                    const rowWidth = Math.min(keysPerRow, keys.length - row * keysPerRow) * (keySize + keyGap) - keyGap;
                    const startX = centerX - rowWidth / 2;
                    const keyX = startX + col * (keySize + keyGap);
                    const keyY = y + row * (keySize + keyGap);

                    // Draw key
                    ctx.fillStyle = DS.colors.bgPanel;
                    ctx.fillRect(keyX, keyY, keySize, keySize);
                    ctx.strokeStyle = DS.colors.border;
                    ctx.lineWidth = 1;
                    ctx.strokeRect(keyX, keyY, keySize, keySize);

                    ctx.fillStyle = DS.colors.white;
                    ctx.font = DS.font('body', 'bold');
                    ctx.fillText(keys[i], keyX + keySize / 2, keyY + keySize / 2 + DS.fontSize('body') / 3);

                    // Add clickable for key
                    addClickable({ x: keyX, y: keyY, w: keySize, h: keySize, action: `key_${keys[i]}` });
                }

                const numRows = Math.ceil(keys.length / keysPerRow);
                y += numRows * (keySize + keyGap) + DS.spacing.lg;

                // Backspace and Join buttons
                const btnWidth = Math.min(120, canvas.width / 3);
                const btnHeight = DS.button.height();

                const backspaceBounds = drawStyledButton(centerX - btnWidth / 2 - DS.spacing.sm, y, btnWidth, btnHeight, 'â† DELETE', { action: 'key_backspace', primary: false });
                addClickable(backspaceBounds);

                const joinBounds = drawStyledButton(centerX + btnWidth / 2 + DS.spacing.sm, y, btnWidth, btnHeight, 'JOIN', { action: 'join_with_code', primary: true });
                addClickable(joinBounds);

            } else if (gameState === 'lobby') {
                // Lobby screen
                resetClickables();
                ctx.fillStyle = DS.colors.bgOverlay;
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // Header with back button
                const header = drawHeader('MULTIPLAYER LOBBY', true);
                addClickable({ ...header.backBounds, action: 'leave_lobby' });

                const centerX = canvas.width / 2;
                let contentY = header.height + DS.spacing.lg;

                if (currentLobby) {
                    // Lobby code panel
                    const codePanelWidth = Math.min(300, canvas.width - DS.spacing.xl * 2);
                    const codePanelHeight = DS.fontSize('body') + DS.fontSize('h2') + DS.spacing.lg * 2;
                    drawPanel(centerX, contentY, codePanelWidth, codePanelHeight, { centered: true });

                    ctx.textAlign = 'center';
                    ctx.fillStyle = DS.colors.textSecondary;
                    ctx.font = DS.font('small');
                    ctx.fillText('Lobby Code', centerX, contentY + DS.spacing.md + DS.fontSize('small') / 2);
                    ctx.fillStyle = DS.colors.primary;
                    ctx.font = DS.font('h2', 'bold');
                    ctx.fillText(currentLobby.code, centerX, contentY + DS.spacing.md + DS.fontSize('small') + DS.spacing.sm + DS.fontSize('h2') / 2);
                    contentY += codePanelHeight + DS.spacing.md;

                    // Land info
                    ctx.fillStyle = DS.colors.textMuted;
                    ctx.font = DS.font('small');
                    ctx.fillText(`Land: ${lands[selectedLand].name}`, centerX, contentY);
                    contentY += DS.fontSize('small') + DS.spacing.lg;

                    // Players section with count
                    contentY = drawSectionTitle(`PLAYERS (${lobbyPlayers.length}/${MAX_LOBBY_PLAYERS})`, contentY);

                    const playerRowHeight = Math.max(40, DS.fontSize('body') + DS.spacing.md);
                    // Sort players by join order (host first)
                    const sortedPlayers = [...lobbyPlayers].sort((a, b) => {
                        // Host always first
                        if (a.player_id === currentLobby.host_id) return -1;
                        if (b.player_id === currentLobby.host_id) return 1;
                        // Then by joined_at
                        return new Date(a.joined_at) - new Date(b.joined_at);
                    });

                    sortedPlayers.forEach((p, i) => {
                        const y = contentY + i * playerRowHeight;
                        const isMe = currentUser && p.player_id === currentUser.id;
                        const isHost = p.player_id === currentLobby.host_id;
                        const username = p.profiles?.username || 'Player';

                        // Player number and name
                        ctx.fillStyle = isMe ? DS.colors.primary : DS.colors.white;
                        ctx.font = DS.font('body', isMe ? 'bold' : 'normal');
                        ctx.textAlign = 'left';
                        const displayName = `${i + 1}. ${username}${isMe ? ' (You)' : ''}`;
                        ctx.fillText(displayName, centerX - 100, y + playerRowHeight / 2);

                        // Show host badge
                        if (isHost) {
                            ctx.fillStyle = DS.colors.primary;
                            ctx.font = DS.font('small', 'bold');
                            ctx.textAlign = 'right';
                            ctx.fillText('HOST', centerX + 100, y + playerRowHeight / 2);
                        }
                    });
                    contentY += sortedPlayers.length * playerRowHeight + DS.spacing.md;

                    // Status message
                    ctx.textAlign = 'center';
                    if (lobbyPlayers.length < 2) {
                        ctx.fillStyle = DS.colors.textMuted;
                        ctx.font = DS.font('body');
                        ctx.fillText('Waiting for players to join...', centerX, contentY);
                        ctx.font = DS.font('small');
                        ctx.fillText('Share the lobby code above!', centerX, contentY + DS.fontSize('body') + DS.spacing.xs);
                    } else if (!isLobbyHost) {
                        ctx.fillStyle = DS.colors.textSecondary;
                        ctx.font = DS.font('body');
                        ctx.fillText('Waiting for host to start...', centerX, contentY);
                    }

                    // Buttons
                    const btnWidth = Math.min(220, canvas.width - DS.spacing.xl * 2);
                    const btnHeight = DS.button.height();
                    const btnY = canvas.height - DS.spacing.xl - btnHeight * 2 - DS.spacing.md;

                    // Host sees START GAME, others see nothing (just waiting)
                    if (isLobbyHost) {
                        const canStart = lobbyPlayers.length >= 2;
                        const startBounds = drawStyledButton(centerX, btnY, btnWidth, btnHeight, 'START GAME', {
                            action: canStart ? 'start_game' : null,
                            primary: canStart,
                            disabled: !canStart
                        });
                        if (canStart) {
                            addClickable(startBounds);
                        }
                    }

                    const leaveBounds = drawStyledButton(centerX, btnY + btnHeight + DS.spacing.md, btnWidth, btnHeight, 'LEAVE LOBBY', { action: 'leave_lobby', primary: false });
                    addClickable(leaveBounds);

                    // Instructions at bottom
                    ctx.fillStyle = DS.colors.textMuted;
                    ctx.font = DS.font('small');
                    ctx.textAlign = 'center';
                    if (isLobbyHost && lobbyPlayers.length >= 2) {
                        ctx.fillStyle = DS.colors.success;
                        ctx.fillText('Ready to start! Click START GAME', centerX, canvas.height - DS.spacing.md);
                    }
                } else {
                    ctx.fillStyle = DS.colors.textSecondary;
                    ctx.font = DS.font('body');
                    ctx.textAlign = 'center';
                    ctx.fillText('Creating lobby...', centerX, canvas.height / 2);
                }

            } else if (gameState === 'playing') {
                // Draw entities first (behind players)
                entities.forEach(ent => {
                    drawSprite(ctx, ent.x, ent.y, ent.pixels, ent.scale, ent.colors);
                });

                // In multiplayer, draw all players
                if (gameMode === 'multiplayer') {
                    // Update local player state for broadcasting
                    if (allPlayersStates[currentUser?.id]) {
                        allPlayersStates[currentUser.id].y = player.y;
                        allPlayersStates[currentUser.id].score = score;
                        allPlayersStates[currentUser.id].bananas = bananasCollected;
                    }

                    // Draw all players (sorted by x position so front players overlap back)
                    const playersToDraw = Object.values(allPlayersStates)
                        .sort((a, b) => a.x - b.x);

                    playersToDraw.forEach(p => {
                        const isLocal = p.id === currentUser?.id;
                        const yPos = isLocal ? player.y : p.y;

                        // Ghost players are semi-transparent
                        if (!p.isAlive) {
                            ctx.globalAlpha = 0.4;
                        }

                        // Draw player sprite
                        drawSprite(ctx, p.x, yPos, land.runner, player.scale, land.runnerColors);

                        // Draw username above player
                        ctx.globalAlpha = p.isAlive ? 1 : 0.5;
                        ctx.fillStyle = isLocal ? DS.colors.primary : DS.colors.white;
                        ctx.font = 'bold 12px monospace';
                        ctx.textAlign = 'center';
                        ctx.fillText(p.username, p.x + PLAYER_WIDTH / 2, yPos - 5);

                        // Ghost label
                        if (!p.isAlive) {
                            ctx.fillStyle = '#888';
                            ctx.font = '10px monospace';
                            ctx.fillText('GHOST', p.x + PLAYER_WIDTH / 2, yPos - 18);
                        }

                        ctx.globalAlpha = 1;
                    });

                    // Show ghost spectating message if dead
                    if (!localPlayerAlive) {
                        ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                        ctx.fillRect(0, 0, canvas.width, 40);
                        ctx.fillStyle = DS.colors.primary;
                        ctx.font = 'bold 16px monospace';
                        ctx.textAlign = 'center';
                        ctx.fillText('ðŸ‘» SPECTATING - Waiting for others to finish...', canvas.width / 2, 26);
                    }

                    // Show all player scores on the right (with bananas)
                    ctx.textAlign = 'right';
                    let scoreY = 35;
                    Object.values(allPlayersStates)
                        .sort((a, b) => b.score - a.score)
                        .forEach((p, i) => {
                            const isLocal = p.id === currentUser?.id;
                            ctx.fillStyle = isLocal ? DS.colors.primary : (p.isAlive ? '#333' : '#888');
                            ctx.font = `${isLocal ? 'bold ' : ''}14px monospace`;
                            const status = p.isAlive ? '' : ' ðŸ‘»';
                            // Show score and banana count
                            ctx.fillText(`${p.username}: ${p.score} (ðŸŒ${p.bananas || 0})${status}`, canvas.width - 20, scoreY);
                            scoreY += 20;
                        });
                } else {
                    // Solo mode - draw single player
                    drawSprite(ctx, player.x, player.y, land.runner, player.scale, land.runnerColors);
                }

                // Draw local scores (left side)
                ctx.fillStyle = '#000';
                ctx.font = 'bold 28px monospace';
                ctx.textAlign = 'left';
                ctx.fillText(`Score: ${score}`, 20, 35);
                ctx.fillText(`Bananas: ${bananasCollected}`, 20, 70);

                // Show current land
                ctx.fillStyle = '#666';
                ctx.font = '18px monospace';
                ctx.textAlign = 'right';
                if (gameMode !== 'multiplayer') {
                    ctx.fillText(land.name, canvas.width - 20, 35);
                }

            } else if (gameState === 'gameover') {
                // Draw player and entities frozen
                drawSprite(ctx, player.x, player.y, land.runner, player.scale, land.runnerColors);
                entities.forEach(ent => {
                    drawSprite(ctx, ent.x, ent.y, ent.pixels, ent.scale, ent.colors);
                });

                // Dark overlay
                resetClickables();
                ctx.fillStyle = DS.colors.bgOverlay;
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                const centerX = canvas.width / 2;
                let y = canvas.height * 0.15;
                ctx.textAlign = 'center';

                // Show multiplayer result
                if (gameMode === 'multiplayer' && gameResult) {
                    const resultColors = { win: DS.colors.success, lose: DS.colors.error, tie: DS.colors.primary };
                    const resultText = { win: 'YOU WIN!', lose: 'YOU LOSE!', tie: 'TIE GAME!' };

                    ctx.fillStyle = resultColors[gameResult];
                    ctx.font = DS.font('h1', 'bold');
                    ctx.fillText(resultText[gameResult], centerX, y);
                    y += DS.fontSize('h1') + DS.spacing.lg;

                    ctx.fillStyle = DS.colors.white;
                    ctx.font = DS.font('h3', 'bold');
                    ctx.fillText(`Your Score: ${score}`, centerX, y);
                    y += DS.fontSize('h3') + DS.spacing.md;

                    ctx.fillStyle = DS.colors.error;
                    ctx.fillText(`Opponent: ${opponentScore}`, centerX, y);
                    y += DS.fontSize('h3') + DS.spacing.lg;
                } else {
                    ctx.fillStyle = DS.colors.white;
                    ctx.font = DS.font('h1', 'bold');
                    ctx.fillText('Game Over', centerX, y);
                    y += DS.fontSize('h1') + DS.spacing.md;

                    // Your score panel
                    const panelWidth = Math.min(340, canvas.width - DS.spacing.lg * 2);
                    const yourScorePanelHeight = DS.fontSize('h2') + DS.fontSize('small') + DS.spacing.lg;
                    drawPanel(centerX, y, panelWidth, yourScorePanelHeight, { centered: true });

                    ctx.fillStyle = DS.colors.primary;
                    ctx.font = DS.font('h2', 'bold');
                    ctx.fillText(score.toString(), centerX, y + DS.spacing.md + DS.fontSize('h2') / 2);

                    ctx.fillStyle = DS.colors.textSecondary;
                    ctx.font = DS.font('small');
                    ctx.fillText(`${bananasCollected} bananas collected`, centerX, y + DS.spacing.md + DS.fontSize('h2') + DS.spacing.xs);
                    y += yourScorePanelHeight + DS.spacing.md;

                    // New high score notification
                    if (currentUser && userProfile && score > (userProfile.high_score || 0)) {
                        ctx.fillStyle = DS.colors.primary;
                        ctx.font = DS.font('body', 'bold');
                        ctx.fillText('NEW PERSONAL BEST!', centerX, y);
                        y += DS.fontSize('body') + DS.spacing.sm;
                    }

                    // Stats comparison section
                    if (!gameOverStats.loading && supabaseClient) {
                        const statsRowHeight = DS.fontSize('small') + DS.spacing.sm;
                        const statsPanelHeight = statsRowHeight * 3 + DS.spacing.md * 2;
                        const currentLandName = lands[selectedLand].name;

                        y += DS.spacing.sm;
                        drawPanel(centerX, y, panelWidth, statsPanelHeight, { centered: true });

                        const statsX = centerX - panelWidth / 2 + DS.spacing.md;
                        const statsRightX = centerX + panelWidth / 2 - DS.spacing.md;
                        let statsY = y + DS.spacing.md + statsRowHeight / 2;

                        // Global top score
                        ctx.textAlign = 'left';
                        ctx.fillStyle = DS.colors.textSecondary;
                        ctx.font = DS.font('small');
                        ctx.fillText('Global Best', statsX, statsY);
                        ctx.textAlign = 'right';
                        if (gameOverStats.isNewGlobalBest) {
                            ctx.fillStyle = DS.colors.success;
                            ctx.font = DS.font('small', 'bold');
                            ctx.fillText('NEW RECORD!', statsRightX, statsY);
                        } else if (gameOverStats.globalTopScore !== null) {
                            ctx.fillStyle = DS.colors.white;
                            ctx.font = DS.font('small', 'bold');
                            ctx.fillText(`${gameOverStats.globalTopScore} by ${gameOverStats.globalTopPlayer}`, statsRightX, statsY);
                        }
                        statsY += statsRowHeight;

                        // Biome top score
                        ctx.textAlign = 'left';
                        ctx.fillStyle = DS.colors.textSecondary;
                        ctx.font = DS.font('small');
                        ctx.fillText(`${currentLandName} Best`, statsX, statsY);
                        ctx.textAlign = 'right';
                        if (gameOverStats.biomeTopScore !== null) {
                            const isNewBiomeRecord = score > gameOverStats.biomeTopScore;
                            if (isNewBiomeRecord) {
                                ctx.fillStyle = DS.colors.success;
                                ctx.font = DS.font('small', 'bold');
                                ctx.fillText('NEW RECORD!', statsRightX, statsY);
                            } else {
                                ctx.fillStyle = DS.colors.white;
                                ctx.font = DS.font('small', 'bold');
                                ctx.fillText(`${gameOverStats.biomeTopScore} by ${gameOverStats.biomeTopPlayer}`, statsRightX, statsY);
                            }
                        } else {
                            ctx.fillStyle = DS.colors.success;
                            ctx.font = DS.font('small', 'bold');
                            ctx.fillText('FIRST SCORE!', statsRightX, statsY);
                        }
                        statsY += statsRowHeight;

                        // Personal biome best
                        if (currentUser) {
                            ctx.textAlign = 'left';
                            ctx.fillStyle = DS.colors.textSecondary;
                            ctx.font = DS.font('small');
                            ctx.fillText(`Your ${currentLandName} Best`, statsX, statsY);
                            ctx.textAlign = 'right';
                            if (gameOverStats.isNewBiomeBest) {
                                ctx.fillStyle = DS.colors.success;
                                ctx.font = DS.font('small', 'bold');
                                ctx.fillText('NEW!', statsRightX, statsY);
                            } else if (gameOverStats.personalBiomeBest !== null) {
                                ctx.fillStyle = DS.colors.white;
                                ctx.font = DS.font('small', 'bold');
                                ctx.fillText(gameOverStats.personalBiomeBest.toString(), statsRightX, statsY);
                            }
                        }

                        y += statsPanelHeight + DS.spacing.md;
                    } else if (gameOverStats.loading) {
                        ctx.fillStyle = DS.colors.textMuted;
                        ctx.font = DS.font('small');
                        ctx.textAlign = 'center';
                        ctx.fillText('Loading stats...', centerX, y + DS.spacing.md);
                        y += DS.fontSize('small') + DS.spacing.lg;
                    }
                }

                // Land selection instruction
                ctx.textAlign = 'center';
                y = drawSectionTitle('SELECT LAND & TAP TO PLAY', y);
                drawLandButtons(y, false);
                y += Math.max(44, Math.round(canvas.width * 0.055)) + DS.spacing.lg; // Land button height + spacing

                // Back to menu button
                const menuBtnWidth = Math.min(180, canvas.width - DS.spacing.xl * 2);
                const menuBtnHeight = Math.max(40, DS.button.height() * 0.8);
                const menuBtnBounds = drawStyledButton(centerX, y, menuBtnWidth, menuBtnHeight, 'MENU', { action: 'back', primary: false });
                addClickable(menuBtnBounds);

            } else if (gameState === 'multiplayer-results') {
                // Multiplayer round results screen
                resetClickables();
                ctx.fillStyle = DS.colors.bgOverlay;
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                const centerX = canvas.width / 2;
                let y = DS.spacing.xl;

                // Title
                ctx.textAlign = 'center';
                ctx.fillStyle = DS.colors.primary;
                ctx.font = DS.font('h1', 'bold');
                ctx.fillText('ROUND OVER', centerX, y + DS.fontSize('h1'));
                y += DS.fontSize('h1') + DS.spacing.lg;

                // Result message
                if (gameResult === 'win') {
                    ctx.fillStyle = DS.colors.success;
                    ctx.font = DS.font('h2', 'bold');
                    ctx.fillText('ðŸ† YOU WON!', centerX, y + DS.fontSize('h2'));
                } else {
                    ctx.fillStyle = DS.colors.error;
                    ctx.font = DS.font('h2', 'bold');
                    ctx.fillText('Better luck next time!', centerX, y + DS.fontSize('h2'));
                }
                y += DS.fontSize('h2') + DS.spacing.xl;

                // Leaderboard panel
                const panelWidth = Math.min(400, canvas.width - DS.spacing.lg * 2);
                const results = Object.values(allPlayersStates)
                    .sort((a, b) => b.score - a.score);
                const rowHeight = 36;
                const panelHeight = rowHeight * (results.length + 1) + DS.spacing.lg * 2;

                drawPanel(centerX, y, panelWidth, panelHeight, { centered: true });

                // Header row
                const tableStartY = y + DS.spacing.lg;
                const panelLeft = centerX - panelWidth / 2;
                const colRank = panelLeft + DS.spacing.md;
                const colPlayer = panelLeft + DS.spacing.xl * 1.5;
                const colScore = panelLeft + panelWidth - DS.spacing.lg - 60;
                const colBananas = panelLeft + panelWidth - DS.spacing.md;

                ctx.fillStyle = DS.colors.textMuted;
                ctx.font = DS.font('small', 'bold');
                ctx.textAlign = 'left';
                ctx.fillText('#', colRank, tableStartY + rowHeight / 2);
                ctx.fillText('PLAYER', colPlayer, tableStartY + rowHeight / 2);
                ctx.textAlign = 'right';
                ctx.fillText('SCORE', colScore, tableStartY + rowHeight / 2);
                ctx.fillText('ðŸŒ', colBananas, tableStartY + rowHeight / 2);

                // Player rows
                results.forEach((p, i) => {
                    const rowY = tableStartY + (i + 1) * rowHeight + rowHeight / 2;
                    const isLocal = p.id === currentUser?.id;
                    const medal = i === 0 ? 'ðŸ¥‡' : (i === 1 ? 'ðŸ¥ˆ' : (i === 2 ? 'ðŸ¥‰' : ''));

                    ctx.fillStyle = isLocal ? DS.colors.primary : DS.colors.white;
                    ctx.font = DS.font('body', isLocal ? 'bold' : 'normal');
                    ctx.textAlign = 'left';
                    ctx.fillText(`${medal || (i + 1)}`, colRank, rowY);
                    ctx.fillText(p.username + (isLocal ? ' (You)' : ''), colPlayer, rowY);
                    ctx.textAlign = 'right';
                    ctx.fillText(p.score.toString(), colScore, rowY);
                    ctx.fillText(p.bananas.toString(), colBananas, rowY);
                });

                y += panelHeight + DS.spacing.xl;

                // Buttons - Play Again is prominent, Leave is minor
                const btnWidth = Math.min(220, canvas.width - DS.spacing.xl * 2);
                const btnHeight = DS.button.height();

                if (isLobbyHost) {
                    // Large prominent PLAY AGAIN button for host
                    const playAgainBounds = drawStyledButton(centerX, y, btnWidth, btnHeight * 1.2, 'PLAY AGAIN', { action: 'play_again', primary: true });
                    addClickable(playAgainBounds);
                    y += btnHeight * 1.2 + DS.spacing.xl;
                } else {
                    ctx.fillStyle = DS.colors.textMuted;
                    ctx.font = DS.font('body');
                    ctx.fillText('Waiting for host to start next round...', centerX, y + DS.fontSize('body') / 2);
                    y += DS.fontSize('body') + DS.spacing.xl;
                }

                // Minor text-link style "leave" option
                ctx.fillStyle = DS.colors.textMuted;
                ctx.font = DS.font('small');
                const leaveText = 'Leave Lobby';
                const leaveWidth = ctx.measureText(leaveText).width + 20;
                const leaveHeight = DS.fontSize('small') + 16;
                const leaveX = centerX - leaveWidth / 2;
                const leaveY = y;
                ctx.fillText(leaveText, centerX, leaveY + leaveHeight / 2 + 2);

                // Add subtle underline
                const textWidth = ctx.measureText(leaveText).width;
                ctx.beginPath();
                ctx.moveTo(centerX - textWidth / 2, leaveY + leaveHeight / 2 + 6);
                ctx.lineTo(centerX + textWidth / 2, leaveY + leaveHeight / 2 + 6);
                ctx.strokeStyle = DS.colors.textMuted;
                ctx.lineWidth = 1;
                ctx.stroke();

                addClickable({ x: leaveX, y: leaveY, w: leaveWidth, h: leaveHeight, action: 'leave_results' });
            }

            // Draw notifications on top of everything
            drawNotifications();

            ctx.textAlign = 'left';
        }

        // Game loop
        function gameLoop() {
            update();
            draw();
            requestAnimationFrame(gameLoop);
        }

        // Start the game
        gameLoop();
    </script>
</body>
</html>